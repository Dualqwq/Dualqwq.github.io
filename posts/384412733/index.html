<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Backward Induction 相关总结 | 天命之路 的博客</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="/js/gitalk.js"></script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/brands.min.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Brands';
 src: local('Font Awesome 6 Brands'), url('/lib/fontawesome/fa-brands.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Free';
 src: local('Font Awesome 6 Free'), url('/lib/fontawesome/fa-regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>Backward Induction 相关总结</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-05-02T06:20:14.310Z" id="date"> 2023-05-02</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-02-14T13:56:24.680Z" id="updated"> 2023-02-14</time></div></span></div></div><hr><div id="post-content"><p>Backward Induction ，译为逆向归纳法，常用于在有向图上做带环的 DP 与博弈，是一个很有用的技巧。</p>
<span id="more"></span>

<p>这种方法常用于，你要对每个点维护一个状态 $f_x$，而 $f_x$ 由后继 $f_y$ 推得的时候。</p>
<p>直接考虑环并不好做，我们先从简单的情况开始归纳，即 $x$ 没有出边的情况，这一般很简单。</p>
<p>然后对反图做类似拓扑排序 &#x2F; dijkstra 的 DP，让 $y$ 一步一步更新 $x$，在队列&#x2F;堆中存储已经确定的 $f_x$。</p>
<h3 id="有向图博弈"><a href="#有向图博弈" class="headerlink" title="有向图博弈"></a>有向图博弈</h3><p>有向图博弈，有环，那么就肯定存在平局。</p>
<p>要让博弈进行下去，肯定是有一方希望平局，另一方不希望平局。</p>
<p>先 DP 出每个状态是否为平局，再导出每个点的胜负状态即可。</p>
<p>DP 平局较为容易，没有出边肯定不是平局，对于希望平局的一方，后继有平则平，对于不希望平局的一方，后继有不平则不平，记录每个点在原图上的出度 $out[x]$，在原图上做拓扑排序式的 DP 即可。</p>
<p>怎么导出胜负状态呢？</p>
<p>我们一般会记录 $D[x][0&#x2F;1]$，表示 $x$ 为起点，$A&#x2F;B$ 先手，能到达多少个非平局后继。这样我们就可以在 DP 过程中判别， $x$ 的非平局后继是否都已经被确定。</p>
<p>如果 $x$ 的非平局后继都已经被确定，将其加入队列 &#x2F; 堆等数据结构，更新其它点即可。</p>
<h4 id="第一道例题"><a href="#第一道例题" class="headerlink" title="第一道例题"></a>第一道例题</h4><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6970">洛谷 P6970</a></p>
<p>Alice : 先平再赢后输</p>
<p>Bob : 先赢再输后平</p>
<p>我们先 DP 出 $drw[x][0&#x2F;1]$ 表示以 $x$ 为起点，$A&#x2F;B$ 先手，是否为平局。</p>
<p>讲一下 DP 过程中的细节：</p>
<p>我们一开始将无出度节点的 $drw$ 置为 $0$，其余点的 $drw$ 均置为 $1$。</p>
<p>维护一个队列 $Q$，里面只会存放非平局的状态。</p>
<p>取出队头 $(x,v \in {0,1})$，取出 $x$ 的前驱 $y$。</p>
<p>如果 $v &#x3D; 0$，那么对应的，$y$ 那里是 Bob 先手，既然 Bob 不喜欢平局，$drw[y][1]$ 肯定为 $False$，更新并入队即可。</p>
<p>如果 $v &#x3D; 1$，那么对应的，$y$ 那里是 Alice 先手，那得 $y$ 的所有后继均为非平局，$drw[y][0]$ 才是非平局，所以碰到 $(x,1)$，就把 $out[y] \gets out[y] - 1$，什么时候减到 $0$ 了，就更新并入队。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>&#123;<br>	deg[i] = out[i];<br>	<span class="hljs-keyword">if</span>(!deg[i]) Q.<span class="hljs-built_in">emplace</span>(i,<span class="hljs-number">0</span>),Q.<span class="hljs-built_in">emplace</span>(i,<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">else</span> drw[i][<span class="hljs-number">0</span>] = drw[i][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>	<span class="hljs-type">int</span> x = Q.<span class="hljs-built_in">front</span>().FI,tp = Q.<span class="hljs-built_in">front</span>().SE; <span class="hljs-comment">// 队列里只放非平局状态</span><br>	Q.<span class="hljs-built_in">pop</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y : Gr[x])<br>        <span class="hljs-keyword">if</span>((tp == <span class="hljs-number">0</span> &amp;&amp; drw[y][<span class="hljs-number">1</span>]) || (tp == <span class="hljs-number">1</span> &amp;&amp; !--deg[y]))<br>	 		drw[y][tp ^ <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>,Q.<span class="hljs-built_in">emplace</span>(y,tp ^ <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后对非平局状态 DP 出胜负即可，这个比较容易。</p>
<p>这题还有一个特殊情况，就是对于一些非平局状态，其在上一轮的 DP 中并没有确定胜负态。</p>
<p>对于 Bob 来说，这体现为该点在某个环上，后继有 Alice 的必胜与平局，在所有已经确定的状态都转移完之后，这些状态没有被转移到（因为在环上有相邻的点是非平局，导致无法进入这个环，因为相邻点的状态始终无法确定）。</p>
<p>那么这些点在环上，但为什么不是平局呢？</p>
<p>只有可能是 Bob 没法赢，但由不想平局，所以选择了输，特判这些点为 Alice 胜 Bob 败即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>	&#123;<br>		deg[i] = out[i];<br>		<span class="hljs-keyword">if</span>(!deg[i]) Q.<span class="hljs-built_in">emplace</span>(i,<span class="hljs-number">0</span>),Q.<span class="hljs-built_in">emplace</span>(i,<span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">else</span> F[i][<span class="hljs-number">0</span>] = F[i][<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v : G[i])<br>			D[i][<span class="hljs-number">0</span>] += !drw[v][<span class="hljs-number">1</span>],D[i][<span class="hljs-number">1</span>] += !drw[v][<span class="hljs-number">0</span>];<br>	&#125;<br>	<span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())<br>	&#123;<br>		<span class="hljs-type">int</span> x = Q.<span class="hljs-built_in">front</span>().FI,tp = Q.<span class="hljs-built_in">front</span>().SE;Q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 做出非平局状态的输赢</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y : Gr[x]) <br>			<span class="hljs-keyword">if</span>(!drw[y][tp ^ <span class="hljs-number">1</span>]) <span class="hljs-comment">// 目标状态非平局</span><br>			&#123;<br>				<span class="hljs-keyword">if</span>(F[x][tp]) &#123; <span class="hljs-keyword">if</span>(!--D[y][tp ^ <span class="hljs-number">1</span>]) Q.<span class="hljs-built_in">emplace</span>(y,tp ^ <span class="hljs-number">1</span>),F[y][tp ^ <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;&#125;<br>				<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(F[y][tp ^ <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>) Q.<span class="hljs-built_in">emplace</span>(y,tp ^ <span class="hljs-number">1</span>),F[y][tp ^ <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;&#125;<br>			&#125; <br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) <span class="hljs-comment">// 特判上述情况</span><br>	&#123;<br>		<span class="hljs-keyword">if</span>(F[i][<span class="hljs-number">0</span>] == <span class="hljs-number">-1</span>) F[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(F[i][<span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>) F[i][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="有向图-DP"><a href="#有向图-DP" class="headerlink" title="有向图 DP"></a>有向图 DP</h3><p>与有向图博弈的流程大同小异，先考虑没有出度的点，再使用类似 Dijkstra 的方式维护转移即可。</p>
<h4 id="第一道例题-1"><a href="#第一道例题-1" class="headerlink" title="第一道例题"></a>第一道例题</h4><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc261_h">AtCoder Beginning Contest 261 H</a></p>
<p>这道题是个博弈与 DP 结合的题，放在这里比较合适。</p>
<p>容易发现，Aoki 当然会尽量促成 “INFINITY”。</p>
<p>设 $F[x][0&#x2F;1]$ 表示以 $x$ 为起点，Takahashi&#x2F;Aoki 先手的最终得分，初始时 $F[x][0] &#x3D; \infty,F[x][1] &#x3D; 0$。</p>
<p>对于没有出度的点，$F[x][0] &#x3D; F[x][1] &#x3D; 0$，将其加入堆。</p>
<p>有转移：<br>$$<br>\begin{cases}<br>f_{x,0} \gets \min_{(x,y,w) \in E}f_{y,1} + w \<br>f_{x,1} \gets \max_{(x,y,w) \in E}f_{y,0} + w \<br>\end{cases}<br>$$<br>事实上，我们可以直接把平局的情况并入上述的转移。</p>
<p>如果有一个 $f_{y,1}$ 有值，那么 $f_{x,0}$ 就肯定有值。</p>
<p>如果所有的 $f_{y,0}$ 有值，那么 $f_{x,1}$ 才会有值。</p>
<p>上述的有值就是不为 $\infty$ 的情况。</p>
<p>以上述规则转移即可。</p>
<p>在这里，我们维护可用状态用的是小根堆，这与 dijkstra 是本质相同的，我们只会从小的 DP 值转移到大的 DP 值，什么时候一个状态从堆中被弹出了，那它就已经确定了，因为比它小的 DP 值已经都被弹出，所有能更新它的转移都已经做完了。</p>
<p>如果还使用队列的话，那么这就与 SPFA 本质相同，你就无法在每个状态第一次出队时确定它，而是需要若干次松弛，直到状态收敛，这样就无法保证复杂度了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FI first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SE second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n,m,s;<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; G[N],Gr[N];<br>ll f[N][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> out[N][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> x,tp;<br>	ll val;<br>	<span class="hljs-built_in">node</span>()&#123;&#125;<br>	<span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> _x,<span class="hljs-type">const</span> <span class="hljs-type">int</span> _tp,<span class="hljs-type">const</span> ll _val):<br>		<span class="hljs-built_in">x</span>(_x),<span class="hljs-built_in">tp</span>(_tp),<span class="hljs-built_in">val</span>(_val)&#123;&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node &amp;rhs) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> val &gt; rhs.val;&#125;<br>&#125;;<br>priority_queue&lt;node&gt; Q;<br><span class="hljs-type">int</span> deg[N][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> vst[N][<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Dijk</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())<br>	&#123;<br>		<span class="hljs-type">int</span> x = Q.<span class="hljs-built_in">top</span>().x,tp = Q.<span class="hljs-built_in">top</span>().tp;<br>		<span class="hljs-comment">// if(Q.top().val != f[x][tp]) &#123; Q.pop();continue;&#125;</span><br>		Q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span>(vst[x][tp]) <span class="hljs-keyword">continue</span>;<br>		vst[x][tp] = <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : Gr[x])<br>		&#123;<br>			<span class="hljs-type">int</span> y = it.FI,w = it.SE;<br>			<span class="hljs-keyword">if</span>(tp == <span class="hljs-number">0</span>) f[y][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">1</span>],f[x][<span class="hljs-number">0</span>] + w);<br>			<span class="hljs-keyword">if</span>(tp == <span class="hljs-number">1</span>) f[y][<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(f[y][<span class="hljs-number">0</span>],f[x][<span class="hljs-number">1</span>] + w);<br>			deg[y][tp ^ <span class="hljs-number">1</span>]--;<br>			<span class="hljs-keyword">if</span>(!deg[y][tp ^ <span class="hljs-number">1</span>]) Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(y,tp ^ <span class="hljs-number">1</span>,f[y][tp ^ <span class="hljs-number">1</span>]));<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tp == <span class="hljs-number">1</span>) Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(y,<span class="hljs-number">0</span>,f[y][<span class="hljs-number">0</span>])); <span class="hljs-comment">// 对于先手而言，只要一个转移边有值就可以更新</span><br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)<br>	&#123;<br>		<span class="hljs-type">int</span> a,b,c;<br>		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>		Gr[b].<span class="hljs-built_in">emplace_back</span>(a,c);<br>		++deg[a][<span class="hljs-number">0</span>];++deg[a][<span class="hljs-number">1</span>];<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>		f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">9e18</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>		<span class="hljs-keyword">if</span>(!deg[i][<span class="hljs-number">0</span>])<br>		&#123;<br>			Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(i,<span class="hljs-number">0</span>,f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>));<br>			Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(i,<span class="hljs-number">1</span>,f[i][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>));<br>		&#125;<br>	<span class="hljs-built_in">Dijk</span>();<br>	<span class="hljs-keyword">if</span>(!vst[s][<span class="hljs-number">0</span>]) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;INFINITY&quot;</span>);<br>	<span class="hljs-keyword">else</span> cout &lt;&lt; f[s][<span class="hljs-number">0</span>] &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，也是可以先按照上文的方法 DP 出每个状态是否平局，然后用优先队列转移非平局状态。</p>
<h4 id="第二道例题"><a href="#第二道例题" class="headerlink" title="第二道例题"></a>第二道例题</h4><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4042">洛谷 P4042</a></p>
<p>这题，令 $dp_i$ 表示消灭 $i$ 号怪兽的最小代价，那么有<br>$$<br>dp_i &#x3D; \min(K_i,S_i + \sum_{(i,j) \in E} dp_j)<br>$$<br>因为这题每个状态都最终会有个确定的值，并不需要像上一题一样加入特殊的转移规则，转移比较普通。</p>
<p>也是因此，我们可以等到每个点的后继均被确定，再将其入队，事实上，这样每个点只会被入队一次。</p>
<p>因为不确定要让哪些点的 DP 值取到 $K_i$，我们一开始将所有 $(i,K_i)$ 入队即可。</p>
<p>每个点算上最开始的一次入堆，最多被入堆两次，时间复杂度为 $\Theta(n \log n + m)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>,M = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> n,R[N];<br>ll S[N],K[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; G[N];<br>ll dp[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> id;ll val;<br>	<span class="hljs-built_in">node</span>()&#123;&#125;<br>	<span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> _id,<span class="hljs-type">const</span> ll _val):<span class="hljs-built_in">id</span>(_id),<span class="hljs-built_in">val</span>(_val)&#123;&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node &amp;rhs) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> val &gt; rhs.val;&#125;<br>&#125;;<br>priority_queue&lt;node&gt; Q;<br><span class="hljs-type">int</span> vst[N];<br>ll ans[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>	&#123;<br>		cin &gt;&gt; S[i] &gt;&gt; K[i];<br>		<span class="hljs-type">int</span> k;<br>		cin &gt;&gt; k;R[i] = k;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>,x;j &lt;= k;j++)<br>			cin &gt;&gt; x,G[x].<span class="hljs-built_in">push_back</span>(i);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>	&#123;<br>		dp[i] = S[i]; <span class="hljs-comment">// 维护 S[i] + \sum dp_j</span><br>		Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(i,K[i]));<br>	&#125;<br>	<span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())<br>	&#123;<br>		<span class="hljs-type">int</span> x = Q.<span class="hljs-built_in">top</span>().id;<br>		ll val = Q.<span class="hljs-built_in">top</span>().val;<br>		Q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span>(vst[x]) <span class="hljs-keyword">continue</span>;<br>		vst[x] = <span class="hljs-literal">true</span>;ans[x] = val;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y : G[x])<br>		&#123;<br>			<span class="hljs-keyword">if</span>(vst[y] || dp[y] &gt; K[y]) <span class="hljs-keyword">continue</span>;<br>			R[y]--;dp[y] += val;<br>			<span class="hljs-keyword">if</span>(!R[y]) Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(y,dp[y]));<br>		&#125;<br>	&#125;<br>	cout &lt;&lt; ans[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种在有向图上的 DP 有一个共性：由小的 DP 值转移到大的 DP 值，所以用小根堆维护当前可用的状态即可。</p>
<p>这与 dijkstra 的正确性是本质相同的，事实上，最短路问题也可以看作在有环图上的最优化 DP。</p>
<h4 id="第三道例题"><a href="#第三道例题" class="headerlink" title="第三道例题"></a>第三道例题</h4><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7831">[CCO2021] Travelling Merchant</a></p>
<p>设 $f_x$ 表示从 $x$ 出发，至少需要多少资产可以一直走下去，可以写一个转移： $f_x \gets \min_{(x,y,r,p) \in E}\max(r,f_y - p)$。</p>
<p>还是考虑没有出度的点，显然  $f_x$ 为 $\infty$，答案为 $-1$。</p>
<p>如果不断删去出度为 $0$ 的点，最后剩下的点一定是有答案的（即在环上的点）</p>
<p>读者从前面的题可以发现，对于这种有环的 DP,我们可以考察答案的界，来看看答案会收敛成什么样子。</p>
<p>我们考虑这些点的答案上界。</p>
<p>显然，取出当前最大的 $r$，那么如果你初始有 $r$ 的资产，那就可以通行全图，因为资产不会减少。</p>
<p>取出这条边的起点 $u$，并将 $f_u$ 对 $r$ 取 $\min$，再删掉这条边。</p>
<p>如果删完之后这条边已经没有出边了，说明 $f_x$ 已经确定，可以拿来更新其它的点，将其放入一个队列。</p>
<p>跑类似上文的 DP 即可，一边松弛答案，一边观察目标点的后继是否全被删空，要注意，给每条边打个标记，使得每条边只被删一次。</p>
<p>在寻常的 Backward DP 中，打标记并不是必要的，一来每个状态入队不一定只有一次（比如上一道题），二来不打标记也只会对常数造成影响。</p>
<p>但是这道题中，我们要一边找当前 $r$ 最大的边，一边去做 Backward DP 来更新 $f$ 数组，为了让这两个过程不重复统计，我们对每条边打了个删除标记。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>	<span class="hljs-type">int</span> a,b,r,p;<br>	<span class="hljs-built_in">Edge</span>()&#123;&#125;<br>	<span class="hljs-built_in">Edge</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> _a,<span class="hljs-type">const</span> <span class="hljs-type">int</span> _b,<span class="hljs-type">const</span> <span class="hljs-type">int</span> _r,<span class="hljs-type">const</span> <span class="hljs-type">int</span> _p):<br>		<span class="hljs-built_in">a</span>(_a),<span class="hljs-built_in">b</span>(_b),<span class="hljs-built_in">r</span>(_r),<span class="hljs-built_in">p</span>(_p)&#123;&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Edge &amp;rhs) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> r &gt; rhs.r;&#125;<br>&#125;;<br>Edge p[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; G[N];<br>queue&lt;<span class="hljs-type">int</span>&gt; Q;<br><span class="hljs-type">bool</span> vst[N];<br><span class="hljs-type">int</span> out[N];<br><span class="hljs-type">int</span> ans[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)<br>		cin &gt;&gt; p[i].a &gt;&gt; p[i].b &gt;&gt; p[i].r &gt;&gt; p[i].p;<br>	<span class="hljs-built_in">sort</span>(p + <span class="hljs-number">1</span>,p + m + <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)<br>		G[p[i].b].<span class="hljs-built_in">push_back</span>(i);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)<br>		++out[p[i].a];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>		ans[i] = <span class="hljs-number">2e9</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>		<span class="hljs-keyword">if</span>(!out[i]) Q.<span class="hljs-built_in">push</span>(i);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)<br>	&#123;<br>		<span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())<br>		&#123;<br>			<span class="hljs-type">int</span> x = Q.<span class="hljs-built_in">front</span>();Q.<span class="hljs-built_in">pop</span>();<br>			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> id : G[x])<br>			&#123;<br>				<span class="hljs-keyword">if</span>(vst[id]) <span class="hljs-keyword">continue</span>;<br>				<span class="hljs-type">int</span> y = p[id].a;<br>				vst[id] = <span class="hljs-literal">true</span>;<br>				--out[y];<br>				<span class="hljs-keyword">if</span>(ans[x] &lt; <span class="hljs-number">2e9</span>) ans[y] = <span class="hljs-built_in">min</span>(ans[y],<span class="hljs-built_in">max</span>(p[id].r,ans[x] - p[id].p));<br>				<span class="hljs-keyword">if</span>(!out[y])	<br>					Q.<span class="hljs-built_in">push</span>(y);<br>				<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(vst[i]) <span class="hljs-keyword">continue</span>;<br>		ans[p[i].a] = <span class="hljs-built_in">min</span>(ans[p[i].a],p[i].r);<br>		vst[i] = <span class="hljs-literal">true</span>;<br>		--out[p[i].a];<br>		<span class="hljs-keyword">if</span>(!out[p[i].a]) Q.<span class="hljs-built_in">push</span>(p[i].a);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>		<span class="hljs-keyword">if</span>(ans[i] &gt;= <span class="hljs-number">2e9</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1 &quot;</span>);<br>		<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans[i]);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/posts/3690709470/">← Next CF1368E 题解</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/posts/1021998316/">ARC118E 题解 Prev →</a></div></div></div><div id="comments"><div class="selector"><button class="gitalk-sel"></button></div><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Dualqwq</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E5%8D%9A%E5%BC%88"><span class="toc-number">1.</span> <span class="toc-text">有向图博弈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%81%93%E4%BE%8B%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">第一道例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE-DP"><span class="toc-number">2.</span> <span class="toc-text">有向图 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%81%93%E4%BE%8B%E9%A2%98-1"><span class="toc-number">2.1.</span> <span class="toc-text">第一道例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%81%93%E4%BE%8B%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">第二道例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%81%93%E4%BE%8B%E9%A2%98"><span class="toc-number">2.3.</span> <span class="toc-text">第三道例题</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'f3bca61c9bfc22f7350d',
 clientSecret: '313761dc715a2bba0f47651123ee2bb0952966a7',
 repo: 'Dualqwq.github.io',
 owner: 'Dualqwq',
 admin: ['Dualqwq'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");code.findCode();
document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>