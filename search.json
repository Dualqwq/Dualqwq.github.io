[{"title":"CF1773G 题解","url":"/posts/1150304450/","content":"这题增进了我对概率论的一些理解。\r\n\r\n设当前局面为  。\r\n容易发现，在一次  的过程中，大部分的题目都不会对  产生影响。\r\n我们称对  序列产生影响的题目是\r\n\"关键的\"，显然，夹在两个“关键”题目之间的非关键题目可以任意排列，它们不会对概率产生影响。（这是比较重要的一点）。\r\n那我们的任务主要就是，在确定 \r\n序列的过程中，顺便确定 \"关键题目的排列\"。\r\n 只会越变越小，这给了我们 DP\r\n的状态和方式：设  表示到达局面\r\n 的概率，转移则枚举子集。\r\n枚举从  转到  是因为哪道题目，设为 ，那么有 。设能够改变  的题目有  个（即满足  的  的个数），那么这  个题目显然不会在  以前的地方出现（否则当前局面就不是\r\n\r\n了）。在这一类题目中，我们要求当前枚举的  最早出现，对应的概率就是 ，那么就会有 。\r\n这显然过不去，但是注意到后继局面（即 ） 相同的转移可以合并，故设  表示满足  的  的个数，那么 ，上述转移就改写为 。\r\n\r\n可以递推预处理，具体地，取任意不属于  的元素 ，有 。\r\n上述工作都可以在 \r\n时间内完成，故总时间复杂度为 ，可以通过。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5,M = 1 &lt;&lt; 17;typedef double db;vector&lt;int&gt; g[M];db f[M],ans;int n,m;int cnt[M];int pop[M];int cc[M];#define lowbit(x) ((x)&amp;(-(x)))int tid[M];int main(){\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tstring st;int S = 0;\t\tcin &gt;&gt; st;\t\tfor(int j = 0;j &lt; m;j++)\t\t\tif(st[j] == '1') S |= (1 &lt;&lt; j);\t\t++cnt[S];\t}\tfor(int i = 1;i &lt; (1 &lt;&lt; m);i++) pop[i] = pop[i &gt;&gt; 1] + (i &amp; 1);\tfor(int S = (1 &lt;&lt; m) - 1;S &gt;= 0;--S)\t{\t\tg[S].resize(1 &lt;&lt; pop[S]);\t\tif(S + 1 == (1 &lt;&lt; m))\t\t{\t\t\tfor(int T = S &amp; (S - 1),i = 0;T;T = (T - 1) &amp; S,++i)\t\t\t\tg[S][i] = cnt[T],cc[S] += cnt[T];\t\t\tcontinue;\t\t}\t\tint from = S | lowbit(((1 &lt;&lt; m) - 1) ^ S),p = lowbit(((1 &lt;&lt; m) - 1) ^ S);\t\tfor(int T = from &amp; (from - 1),i = 0;T;T = (T - 1) &amp; from,++i)\t\t\ttid[T] = i;\t\tfor(int T = S &amp; (S - 1),i = 0;T;T = (T - 1) &amp; S,++i)\t\t\tg[S][i] = g[from][tid[T]] + g[from][tid[T | p]],cc[S] += g[S][i];\t}\tf[(1 &lt;&lt; m) - 1] = 1;\tfor(int S = (1 &lt;&lt; m) - 1;S;--S)\t{\t\tif(cc[S] == 0)\t\t{\t\t\tif(S &amp; 1) ans += f[S];\t\t\tcontinue;\t\t}\t\tfor(int T = S &amp; (S - 1),i = 0;T;T = (T - 1) &amp; S,++i)\t\t\tf[T] += f[S] * g[S][i] / cc[S];\t}\tprintf(\"%.9lf\\n\",ans);\treturn 0;}\r\n","tags":["counting"]},{"title":"省选至暑假期间的计划","url":"/posts/2035328838/","content":"之前因为种种原因，浪费了一些时间，但我还有一年时间，既然方向明确了，剩下的就是执行。\r\n\r\n在有 whk\r\n的时候，晚自习基本无法做题，不用强求，强行做题反而导致质量下降。\r\n周末有一天，除去上午和晚上用来写作业，只有一个下午的时间，能做 2\r\n道题。\r\n脱产期间，一天应该可以完成 4 题，差不多够了。\r\n先板刷 AT 吧，ARC 和 AGC 换着做。\r\n然后去寻找 CF 的题（题目来源主要是一些人的 VP 手记 和\r\n集训队作业）。\r\n可能还会去做 qoj 上的毛子题 (ptzcamp)。\r\n以及 JOISC。\r\n如果在瞎逛的时候发现好的题单也会加在这里。\r\n对于专题的训练应该要等到暑假。鉴于省选出了 4\r\n道图论，就先从图论开始练习，然后是最优化（包括贪心最优化和 DP\r\n最优化，虽然也有交叉部分），最后是计数（no poly）。\r\n希望有用。\r\n"},{"title":"模拟赛出题避坑指南","url":"/posts/1991476744/","content":"讲一下出模拟赛时踩到的坑，下次不要出锅了。\r\n\r\n数据\r\n\r\n样例也是数据的一部分，数据要检查的样例也要检查。\r\n一定要写 vaildator !!!（校验器）\r\n要时刻保证电脑上只存了一个版本的数据！\r\n上传题目前要检查每个点的数据范围是否与题面匹配。\r\n有时间就多想几个暴力/假做法，塞几组 hack 进去。\r\n上传之前用 std 再跑一遍，确保输出正确。\r\n构造题样例只需要给 .in，不需要给 .out！\r\n\r\n题面\r\n\r\n检查输入输出格式是否写全，检查是否写了多组数据，检查交互格式是否清楚\r\n检查数据范围是否与数据匹配。\r\n检查对于数据的限制有没有写全。\r\n尽量选择题意不容易产生歧义的题目搬。\r\n写样例解释。\r\n\r\n题解\r\n\r\n检查事实性错误和 typo\r\n\r\n时空限制\r\n\r\n开到 std 的两到三倍，尽量避免卡常。\r\n\r\n"},{"title":"ARC165E 题解","url":"/posts/796494018/","content":"比较强的概率转化，如果没见过真的很难想。\r\n\r\n原过程中，一个点被选的概率与当前  的连通块有关，根本做不得。\r\n考虑进行转化，我们不妨允许找到一个所在连通块大小小于 \r\n的点进行切分，但是如果出现这种情况，我们定义这次操作不消耗时间，称其为“无效操作”。\r\n容易发现，无效操作怎么做都不会影响有效操作的情况，而且每个有效操作的执行概率仍然是均等的。所以这个转化的正确性可以理解。\r\n转化完之后，我们把每一步删去的点列出来，设  表示第  步删除的点。我们对所有排列  算贡献之和即可。\r\n一个排列  中，如果位置  满足，当删到  时，其所属的连通块大小 ，那么这个位置就有  的贡献。\r\n枚举 。假设我们可以枚举删到这个点时其所属的连通块 。设  的周围一圈的点集为 。那么删到  时连通块为  ，当且仅当所有  中的点都在  前被删，所有  中的点都在 \r\n后被删。因为我们只需算概率，所以只用考虑这  个点的相对位置，那么  在  之前的概率为 ， 在  中第一个被删的概率为 。那么，删到  时连通块恰好为  的概率就是 。\r\n于是我们只需对于每个 \r\n计算， 且  的连通块数即可。以 \r\n为根跑一遍树形背包即可，单次背包的复杂度为 。\r\n所以总时间复杂度为 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e2 + 5,P = 998244353;inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}int fac[N],ifac[N],inv[N];inline void init(int n) {\tfac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tinv[1] = 1;\tfor(int i = 2;i &lt;= n;i++) inv[i] = 1ll * inv[P % i] * (P - P / i) % P;\tifac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) ifac[i] = 1ll * ifac[i - 1] * inv[i] % P;}inline int C(int n,int m) { if(n &lt; 0 || m &lt; 0 || n &lt; m) return 0;return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;}inline int invC(int n,int m) { if(n &lt; 0 || m &lt; 0 || n &lt; m) return 0;return 1ll * ifac[n] * fac[m] % P * fac[n - m] % P;}int dp[N][N][N],sze[N]; // 选一个包含根的连通块，[根][内点][界点]int n,K;vector&lt;int&gt; G[N];void DP(int x,int fa) {\tstatic int tmp[N][N];\tmemset(tmp,0,sizeof tmp);\tmemset(dp[x],0,sizeof dp[x]);\tdp[x][0][0] = 1;sze[x] = 0;\tint cnt = 0;\tfor(auto y : G[x]) {\t\tif(y == fa) continue;\t\tDP(y,x);++cnt;\t\tfor(int a = 0;a &lt;= sze[x];a++)\t\t\tfor(int b = 0;a + b &lt;= sze[x];b++) {\t\t\t\tPlus(tmp[a][b + 1],dp[x][a][b]); // 这个子树不选任何一个点\t\t\t\tfor(int c = 0;c &lt;= sze[y];c++)\t\t\t\t\tfor(int d = 0;c + d &lt;= sze[y];d++)\t\t\t\t\t\tPlus(tmp[a + c][b + d],1ll * dp[x][a][b] * dp[y][c][d] % P);\t\t\t}\t\tsze[x] += sze[y];\t\tfor(int a = 0;a &lt;= sze[x];a++)\t\t\tfor(int b = 0;a + b &lt;= sze[x];b++)\t\t\t\tdp[x][a][b] = tmp[a][b],tmp[a][b] = 0;\t}\t++sze[x];\tfor(int a = sze[x];a &gt;= 1;a--)\t\tfor(int b = 0;a + b &lt;= sze[x];b++)\t\t\tdp[x][a][b] = dp[x][a - 1][b],dp[x][a - 1][b] = 0;}int Solve(int x) {\tint res = 0;\tDP(x,0);\tfor(int a = K + 1;a &lt;= n;a++)\t\tfor(int b = 1;a + b &lt;= n;b++) {\t\t\tPlus(res,1ll * dp[x][a][b] * invC(a + b,a) % P * inv[a] % P);\t\t}\treturn res;}int main() {\tcin &gt;&gt; n &gt;&gt; K;\tfor(int i = 1,a,b;i &lt; n;i++)\t\tcin &gt;&gt; a &gt;&gt; b,G[a].push_back(b),G[b].push_back(a);\tinit(n);\tint res = 1;\tfor(int i = 1;i &lt;= n;i++) Plus(res,Solve(i));\tcout &lt;&lt; res &lt;&lt; endl;\treturn 0;}\r\n","tags":["DP","counting"]},{"title":"ARC153E 题解","url":"/posts/3075754571/","content":"很牛逼的题啊，虽然感觉自己跟正解已经差得不多了，但还是没做出来。\r\n两点启发：\r\n1.\r\n设计状态时尽量设计转移跨度较小的，能多次转移的问题就不要一次转移全解决\r\n2. 二维的 DP\r\n状态放在平面上考虑，有时会得到格路等有用性质\r\n\r\n首先考虑 \r\n的过程。如果当前决策的元素比当前的队头大，将其加到队头显然不优，否则显然不劣。\r\n回到 \r\n序列中，那么加入队头的元素是一段递增前缀 ，而 \r\n对应到  ，则是  中的非严格前缀最小值。\r\n假如说我们枚举一个 ，那么就是将\r\n 插入到  中，使得  是  的前缀最小值。\r\n设  表示最小的  使得 。\r\n那么设  表示左边当前插入到\r\n ，右边当前插入到  ，那么有转移： \r\n初始设 ，跑这个 DP 即可做到 。\r\n注意到这个状态是二维的，放在平面上考虑，发现其只会转移到相邻的点。\r\n从大到小枚举 ，每次将\r\n 相同的一个连续段  一起转移，求出  右边第一个  的位置 ，那么 \r\n的转移就是一个格路计数，可以直接算出通过这个连续段， 从  转移到  的方案，是个与  有关的组合数。NTT\r\n即可完成转移，转移完之后，将  的 DP 值赋为 ，然后转移下一个连续段。这个算法复杂度是\r\n\r\n的，因为值域很小所以可以通过。\r\n后半段比较潦草，可以看代码理解。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = (1 &lt;&lt; 19) | 5,P = 998244353;inline int Add(const int &amp;a,const int &amp;b) { return (a + b &gt;= P) ? (a + b - P) : (a + b);}inline int Sub(const int &amp;a,const int &amp;b) { return (a &lt; b) ? (a - b + P) : (a - b);}inline int qpow(int a,int b) { int res = 1;while(b) { if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;} return res;}inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}const int G = 3,Gi = qpow(G,P - 2);int rev[N];inline void calc_rev(int len) {\tfor(int i = 0;i &lt; len;i++) {\t\trev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1;\t\tif(i &amp; 1) rev[i] |= len &gt;&gt; 1;\t}}int Gs[N],Gs2[N];inline int GetLen(int x) {\tint len = 1;\twhile(len &lt;= x) len &lt;&lt;= 1;\treturn len;}inline void initG(int len) {\tfor(int i = 1;i &lt; len;i &lt;&lt;= 1) {\t\tGs[i] = Gs2[i] = 1;\t\tGs[i + 1] = qpow(G,(P - 1) / (i &lt;&lt; 1));\t\tGs2[i + 1] = qpow(Gi,(P - 1) / (i &lt;&lt; 1));\t\tfor(int j = 2;j &lt; i;j++)\t\t\tGs[i + j] = 1ll * Gs[i + j - 1] * Gs[i + 1] % P,\t\t\tGs2[i + j] = 1ll * Gs2[i + j - 1] * Gs2[i + 1] % P;\t}}inline void FFT(int *F,int len,int type) {\tfor(int i = 0;i &lt; len;i++)\t\tif(i &lt; rev[i]) swap(F[i],F[rev[i]]);\tfor(int k = 1;k &lt; len;k &lt;&lt;= 1)\t\tfor(int j = 0;j &lt; len;j += k + k)\t\t\tfor(int i = 0;i &lt; k;i++) {\t\t\t\tint cur = type == 1 ? Gs[k | i] : Gs2[k | i];\t\t\t\tint u = F[i | j],v = 1ll * cur * F[i | j | k] % P;\t\t\t\tF[i | j] = Add(u,v);\t\t\t\tF[i | j | k] = Sub(u,v);\t\t\t}\tif(type == -1)\t\tfor(int i = 0,Inv = qpow(len,P - 2);i &lt; len;i++)\t\t\tF[i] = 1ll * F[i] * Inv % P;} int n,fac[N],inv[N],ifac[N];inline void init(int n) {\tfac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tinv[1] = 1;\tfor(int i = 2;i &lt;= n;i++) inv[i] = 1ll * (P - P / i) * inv[P % i] % P;\tifac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) ifac[i] = 1ll * ifac[i - 1] * inv[i] % P;}inline int C(int n,int m) { if(n &lt; 0 || m &lt; 0 || n &lt; m) return 0;return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;}char s[N];int tf[N],tg[N],ans[N];int main() {\tscanf(\"%s\",s + 1);\tn = strlen(s + 1);\tinitG(1 &lt;&lt; 19);\tinit(n);\tint lim = n;\tfor(int i = 1;i &lt; n;i++)\t\tif(s[i] &gt; s[i + 1]) {lim = i;break;}\tfor(int i = 1;i &lt;= lim;i++) ans[i] = 1;\tint len = GetLen(n + n + 2);\tcalc_rev(len);\t\tfor(int c = '9';c &gt;= '1';c--) {\t\tint tl,tr,ct;\t\ttl = tr = ct = -1;\t\tfor(int i = 1;i &lt;= n;i++) if(s[i] == c) { tl = i;break;}\t\tif(tl == -1 || tl &gt; lim) continue;\t\ttr = tl;while(tr &lt; n &amp;&amp; s[tr + 1] == c) ++tr;\t\tct = tr + 1;\t\twhile(ct &lt;= n &amp;&amp; s[ct] &gt; c) ++ct;\t\tfor(int i = 0;i &lt; len;i++) tf[i] = tg[i] = 0;\t\tfor(int i = tr;i &lt; ct;i++) tf[i] = ans[i];\t\tfor(int i = 0;i &lt; ct - tr;i++) tg[i] = C(tr - tl + i,i);\t\tFFT(tf,len,1);FFT(tg,len,1);\t\tfor(int i = 0;i &lt; len;i++) tf[i] = 1ll * tf[i] * tg[i] % P;\t\tFFT(tf,len,-1);\t\tfor(int i = tr;i &lt; ct;i++) ans[i] = tf[i];\t\tfor(int i = tl;i &lt; tr;i++) ans[i] = 1;\t}\tcout &lt;&lt; ans[n] &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting"]},{"title":"CF1693D 题解","url":"/posts/358131794/","content":"DP\r\n状态取值不多这件事情一般很难发现，所以很容易被被刺，做题时需要考虑这种可能性。\r\n\r\n首先考虑如何判定。\r\n这种将一个序列划分为两个序列的东西，有通用的设计 DP 状态的办法： 表示  在序列  中时，另一个序列需要记录的信息。\r\n回到这里就是： 表示\r\n\r\n在递增序列时，递减序列末位数的最大值； 表示 \r\n在递减序列时，递增序列某位数的最小值。这里记录的值是对后面限制最松的情况，最优性显然。转移时讨论\r\n 和  在哪个序列即可。无解就是 。\r\n考虑如何算合法区间个数。首先，对于固定的 ，合法的  一定是某个区间。只需求出最大的合法的\r\n 即可。\r\n这个 DP 形式看上去就很难用 DS 动态维护。故考虑在  变化时暴力更新所有  的 DP 值。因为  的 DP 值只与 \r\n有关，所以如果某次更新没有产生影响，那后面的数就都不需要更新了。\r\n因为 DP 值的变化是单调的，所以暴力更新的开销跟所有 DP\r\n值的取值个数之和是同阶的。事实上，每个 DP 值的取值个数不是很多。以  为例，我们找到最大的  满足 。那么  和  中必须有一个在递减序列中。因为  后面的数都是递增的，所以递减序列的最小值只可能在  或  中取（当然还有 ）。所以单个  只有最多  种取值。 同理。综上所述，每个  值最多被更新  次，故更新的总开销是  的。（如果不存在 ，情况是平凡的）\r\n综上所述，我们在 \r\n的复杂度解决了此题。\r\n#include &lt;bits/stdc++.h&gt;template&lt;typename T&gt; inline bool ckmax(T &amp;x,const T &amp;y) { return (x &lt; y) &amp;&amp; (x = y,true);}template&lt;typename T&gt; inline bool ckmin(T &amp;x,const T &amp;y) { return (x &gt; y) &amp;&amp; (x = y,true);}const int N = 2e5 + 5;int n;int p[N];int inc[N],dec[N];int main() {\tstd::cin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++) std::cin &gt;&gt; p[i];\tfor(int i = 1;i &lt;= n;i++) inc[i] = 0,dec[i] = n + 1;\tlong long ans = 0;\tfor(int i = n,r = n;i;i--) {\t\tinc[i] = n + 1;dec[i] = 0;\t\tfor(int j = i + 1;j &lt;= n;j++) {\t\t\tint ni = 0,nd = n + 1;\t\t\tif(p[j - 1] &lt; p[j]) ckmax(ni,inc[j - 1]);\t\t\tif(p[j - 1] &gt; p[j]) ckmin(nd,dec[j - 1]);\t\t\tif(inc[j - 1] &gt; p[j]) ckmin(nd,p[j - 1]);\t\t\tif(dec[j - 1] &lt; p[j]) ckmax(ni,p[j - 1]);\t\t\tif(ni == inc[j] &amp;&amp; nd == dec[j]) break;\t\t\tinc[j] = ni;dec[j] = nd;\t\t}\t\twhile(r &gt;= i &amp;&amp; (inc[r] == 0 &amp;&amp; dec[r] == n + 1))\t\t\t--r;\t\tans += (r - i + 1);\t}\tstd::cout &lt;&lt; ans &lt;&lt; std::endl;\treturn 0;}\r\n","tags":["DP"]},{"title":"ARC158F 题解","url":"/posts/3146699637/","content":"感觉转化限制的那一步比较难，和题解想的不大一样，怎么都难以优化。\r\n\r\n首先观察一个操作序列，显然，只有每个数位最后一次出现的位置是有用的。假设操作序列中一共出现了\r\n 种数位，那么可以设一个大小为\r\n 的排列 ，  表示数位 \r\n最后一次出现的位置排在第几名（也就是这个关键字第几个被考虑到）。\r\n显然，一个排列能被多少个操作序列生成只与排列大小 \r\n有关，因为每一位的地位是相同的。进一步地，方案数就是 。分子是第二类斯特林数，表示将每次操作分配给一个数位，每种数位都必须出现。这个斯特林数包含了所有大小为\r\n\r\n的排列，单个排列的方案除以阶乘即可。\r\n接下来考虑什么样的排列 \r\n能生成序列 。我们只需让\r\n 排在  的前面，而不需要尝试保证任何\r\n 都在  前面。\r\n考虑一对  和 ，对于每个关键字，存在一些位\r\n 满足 ，令这些位组成的集合为 。存在一些位  满足 \r\n，令这些位组成的集合为 。那么对于任意 ，都必须存在一个  使得  比  先作为依据进行排序。另外，如果  和  在 \r\n中的出现位置是逆序，那么整个过程中也必须以  中的某个  为依据进行排序。（代码中将 \r\n出现的位置也当作一个关键字处理了）\r\n那么，设  表示  集合中是否存在一个必须比  先作为依据排序的关键字。在处理一对\r\n 时，先将  赋值为 。再对  做一遍高维前缀或即可处理出  数组。\r\n那么生成原来的排列 \r\n也很简单了。按照高优先级到低优先级的顺序进行 DP。设  表示当前已经以 \r\n中的关键字为依据排序过的可行排列数。转移时枚举 ，使得  为假，转移到 即可。\r\n时间复杂度 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5,Sz = (1 &lt;&lt; 18) | 5,P = 998244353,MxK = 20;inline void Plus(int &amp;a,const int &amp;b) { a += b;if(a &gt;= P) a -= P;}inline int qpow(int a,int b) { int res = 1;while(b) {if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;} return res;}typedef long long ll;int n,m,K;ll a[N],b[N];bool h[MxK][Sz];int dp[Sz];inline int C(int n,int m) {\tif(n &lt; 0 || m &lt; 0 || n &lt; m) return 0;\tint res = 1;\tfor(int i = n - m + 1;i &lt;= n;i++) res = 1ll * res * i % P;\tfor(int i = 1;i &lt;= m;i++) res = 1ll * res * qpow(i,P - 2) % P;\treturn res;}inline int Strling(int n,int m) {\tif(n &lt; 0 || m &lt;= 0 || n &lt; m) return 0;\tint res = 0;\tfor(int i = 0;i &lt;= m;i++)\t\tif(i &amp; 1) Plus(res,P - 1ll * C(m,i) * qpow(m - i,n) % P);\t\telse Plus(res,1ll * C(m,i) * qpow(m - i,n) % P);\treturn res;}ll Pow10[MxK];inline int Get(ll x,int v) { return (x / Pow10[v]) % 10;} // v 从 0 开始为最低位int f[N],g[N];int keys[N][MxK];map&lt;ll,vector&lt;int&gt; &gt; aps;int main() {\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; K;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i],aps[a[i]].push_back(i);\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; b[i];\tPow10[0] = 1;\tfor(int i = 1;i &lt;= K;i++) Pow10[i] = 10ll * Pow10[i - 1];\tfor(int i = n;i &gt;= 1;i--) {\t\tfor(int j = 0;j &lt; K;j++)\t\t\tkeys[i][j] = Get(b[i],j);\t\tkeys[i][K] = aps[b[i]].back();\t\taps[b[i]].pop_back();\t}\tfor(int i = 1;i &lt;= K;i++) {\t\tf[i] = Strling(m,i);\t\tfor(int j = 1;j &lt;= i;j++)\t\t\tf[i] = 1ll * f[i] * qpow(j,P - 2) % P;\t}\tfor(int i = 1;i &lt; n;i++) {\t\tint S = 0,T = 0;\t\tfor(int j = 0;j &lt;= K;j++) {\t\t\tif(keys[i][j] &lt; keys[i + 1][j] &amp;&amp; j &lt; K) S |= (1 &lt;&lt; j);\t\t\tif(keys[i][j] &gt; keys[i + 1][j]) T |= (1 &lt;&lt; j);\t\t}\t\tfor(int j = 0;j &lt;= K;j++)\t\t\tif(T &gt;&gt; j &amp; 1)\t\t\t\th[j][S] = 1;\t}\tauto PreSum = [&amp;](int id) {\t\tfor(int k = 1;k &lt; (1 &lt;&lt; K);k &lt;&lt;= 1)\t\t\tfor(int j = 0;j &lt; (1 &lt;&lt; K);j += k + k)\t\t\t\tfor(int t = 0;t &lt; k;t++)\t\t\t\t\th[id][j | t | k] |= h[id][j | t];\t};\tfor(int i = 0;i &lt;= K;i++) PreSum(i);\tdp[0] = 1;\tfor(int S = 0;S &lt; (1 &lt;&lt; K);++S) {\t\tfor(int i = 0;i &lt;= K;i++) \t\t\tif(!h[i][(1 &lt;&lt; K) - 1 - S] &amp;&amp; (~S &gt;&gt; i &amp; 1)) {\t\t\t\tif(i == K) Plus(g[__builtin_popcount(S)],dp[S]);\t\t\t\telse Plus(dp[S | (1 &lt;&lt; i)],dp[S]);\t\t\t}\t}\tint ans = 0;\tfor(int i = 0;i &lt;= K;i++)\t\tPlus(ans,1ll * f[i] * g[i] % P);\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["DP","counting"]},{"title":"ARC160F 题解","url":"/posts/3949054574/","content":"这道题加深了我对排列转化为 01 序列这个技巧的理解。\r\n\r\n首先考虑怎么解决单次询问。排列的大小关系不好考虑，但如果我们考虑每个值\r\n，将  的值标为 ， 的值标为 ，那么一个排列将对应一个  个 01\r\n序列构成的组。或者说，对应了在 \r\n维空间中，一条从 \r\n走到 \r\n的路径。那么一个合法的排列，其对应的路径中的每个 01\r\n序列必须是能被当前拥有的操作排好序的，因此，我们只需对于每个 01\r\n序列算出其经过当前拥有的操作后是否排好序，然后进行状压 DP\r\n即可。这一部分复杂度为单次 。\r\n但因为有 \r\n询问，这个复杂度难以承受，考虑减小询问次数。\r\n定义\r\n“有用操作”为，存在一个排列，在进行了这个操作前的所有操作后，仍然能被这个操作改变状态。\r\n考虑一个有用操作 \r\n和其对应的一个  的排列\r\n，以及一个位置  满足 。在进行一次 \r\n后，\r\n这个操作本身会变得无用，但仍然可以使一些操作从无用变为有用，或从有用变为无用。假设操作完之后\r\n\r\n从无用变得有用了，那么这说明一开始有 ，交换之后， ，此时 \r\n又从有用变得无用了。此时，我们发现无用操作数量增大了 。对于  和 \r\n的情况，也是类似的，所以我们可以说明，进行一次有用操作后，无用操作数量会增大至少\r\n。\r\n也就是说，整个过程中，其实只有  个操作是有效的。我们处理数组  表示当前操作 \r\n是否有效。在进行了一次有效操作后，我们发现只有 \r\n形式的操作的有效性会受影响，此时我们枚举所有 01\r\n序列，暴力更新这些操作的可行性即可。这单次也是  的。\r\n所以总复杂度为 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 20,Sz = 1 &lt;&lt; 15;typedef long long ll;int n,m;bool eff[N][N];int bec[Sz]; // 一个 01 序列会被交换成什么样子bool sorted[Sz];ll dp[Sz];int Get(int S,int x) { return S &gt;&gt; x &amp; 1;}inline ll DP() {\tmemset(dp,0,sizeof dp);\tint all = (1 &lt;&lt; n) - 1;\tdp[all] = 1; // 在 i = 1 时序列全是 1，满足条件\tfor(int S = all - 1;S &gt;= 0;S--) {\t\tif(!sorted[bec[S]]) continue;\t\tfor(int j = 0;j &lt; n;j++)\t\t\tif(!Get(S,j))\t\t\t\tdp[S] += dp[S | (1 &lt;&lt; j)];\t}\treturn dp[0];}int main() {\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 0;i &lt; n;i++)\t\tfor(int j = i + 1;j &lt; n;j++)\t\t\teff[i][j] = 1;\tfor(int i = 0;i &lt;= n;i++)\t\tsorted[((1 &lt;&lt; i) - 1) &lt;&lt; (n - i)] = true;\tfor(int i = 0;i &lt; (1 &lt;&lt; n);i++)\t\tbec[i] = i;\tll lastans = 1;\tfor(int _ = 1;_ &lt;= m;_++) {\t\tint a,b,c,d;\t\tcin &gt;&gt; c &gt;&gt; d;\t\tc = (c + lastans) % n;\t\td = (d + lastans + lastans) % n;\t\ta = min(c,d);b = max(c,d);\t\tif(eff[a][b]) {\t\t\tfor(int i = 0;i &lt; a;i++) eff[i][a] = 0;\t\t\tfor(int i = a + 1;i &lt; n;i++) eff[a][i] = 0;\t\t\tfor(int i = 0;i &lt; b;i++) eff[i][b] = 0;\t\t\tfor(int i = b + 1;i &lt; n;i++) eff[b][i] = 0;\t\t\tfor(int i = 0;i &lt; (1 &lt;&lt; n);i++) {\t\t\t\tif(Get(bec[i],a) &gt; Get(bec[i],b))\t\t\t\t\tbec[i] ^= (1 &lt;&lt; a) ^ (1 &lt;&lt; b);\t\t\t\tfor(int j = 0;j &lt; a;j++) eff[j][a] |= Get(bec[i],j) &gt; Get(bec[i],a);\t\t\t\tfor(int j = a + 1;j &lt; n;j++) eff[a][j] |= Get(bec[i],a) &gt; Get(bec[i],j);\t\t\t\tfor(int j = 0;j &lt; b;j++) eff[j][b] |= Get(bec[i],j) &gt; Get(bec[i],b);\t\t\t\tfor(int j = b + 1;j &lt; n;j++) eff[b][j] |= Get(bec[i],b) &gt; Get(bec[i],j);\t\t\t}\t\t\tlastans = DP();\t\t\tprintf(\"%lld\\n\",lastans);\t\t} else printf(\"%lld\\n\",lastans);\t}\treturn 0;}\r\n","tags":["counting"]},{"title":"ABC306H 题解","url":"/posts/1820642954/","content":"集合划分容斥练手题。\r\n\r\n首先要注意到这是一个类似 DAG 定向的模型。实际上，如果没有 \"=\"\r\n的情况，这就是经典的 DAG 定向问题。\r\n先考虑没有 \"=\" 怎么做。设 \r\n表示将点集  的导出子图定向为 DAG\r\n的方案数。\r\n考虑按层构建出一个 DAG，也就是说，我们枚举  表示  中入度为  的点集，从\r\n 转移到 。那么在  与  之间的边，方向显然是从  连到 。转移条件也显然， 必须是个独立集。\r\n但直接这么枚举肯定会算重，毕竟这个 “入度为  的点集“ 并不是极大的。\r\n但这里去重的手段很有限，最好的办法就是配凑容斥系数了。\r\n我们希望对每个集合 \r\n赋一个容斥系数 ，使得每个\r\n“极大的入度为  的点集” 的系数和为\r\n。\r\n设  对应的集合幂级数为 。\r\n那一个极大的点集 \r\n的系数和是什么呢？是 。\r\n我们希望 ，其中  的每一项均为\r\n。\r\n计算集合幂级数的逆可以得到 。\r\n那么从  转移到  时，乘上  的系数即可。\r\n回到原问题。\r\n现在我们仍然尝试枚举“入度为 \r\n的点集”  ，此时 \"=\"\r\n的边不算在入度中。\r\n我们之前限制 \r\n必须是个独立集，但现在 \r\n中可以有边了，只不过所有边都得是 \"=\"。\r\n所以将 \"=\" 号形成的连通块缩点，设连通块个数为  ，那这个点集  实际上等效于没有 \"=\" 的情况中一个大小为\r\n 的点集，所以给  一个  的容斥系数即可。\r\n暴力 DP 转移是 \r\n的，使用集合幂级数求逆可以做到 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 18,Sz = 1 &lt;&lt; 17,M = 400,P = 998244353;inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}inline int qpow(int a,int b) { int res = 1;while(b) {if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;} return res;}int n,m;int U[M],V[M];inline void GetInv(int *f,int *g,int n) {\tint finv = g[0] = qpow(f[0],P - 2);\tfor(int i = 1;i &lt; n;i++) {\t\tint res = 0;\t\tfor(int j = 1;j &lt;= i;j++)\t\t\tPlus(res,P - 1ll * f[j] * g[i - j] % P);\t\tg[i] = 1ll * res * finv % P;\t}}inline void FWT(int *F,int len,int op) {\tfor(int k = 1;k &lt; len;k &lt;&lt;= 1)\t\tfor(int j = 0;j &lt; len;j += k + k)\t\t\tfor(int i = 0;i &lt; k;i++)\t\t\t\tif(op == 1) Plus(F[i | j | k],F[i | j]);\t\t\t\telse Plus(F[i | j | k],P - F[i | j]);}int siz[Sz];int fa[N];int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]);}inline void Merge(int x,int y) { fa[find(x)] = find(y);}inline int Getcoef(int S) {\tfor(int i = 0;i &lt; n;i++) fa[i] = i;\tfor(int i = 1;i &lt;= m;i++)\t\tif((S &gt;&gt; U[i] &amp; 1) &amp;&amp; (S &gt;&gt; V[i] &amp; 1))\t\t\tMerge(U[i],V[i]);\tint res = 1;\tfor(int i = 0;i &lt; n;i++)\t\tif((S &gt;&gt; i &amp; 1) &amp;&amp; find(i) == i) \t\t\t++res;\t// res = 0;\treturn (res &amp; 1) ? P - 1 : 1;}int f[N][Sz];int dp[Sz];int main() {\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1;i &lt;= m;i++) \t\tcin &gt;&gt; U[i] &gt;&gt; V[i],--U[i],--V[i];\tint all = 1 &lt;&lt; n;\tfor(int i = 1;i &lt; all;i++)\t\tsiz[i] = siz[i &gt;&gt; 1] + (i&amp;1);\tfor(int i = 1;i &lt; all;i++)\t\tf[siz[i]][i] = Getcoef(i);\t// dp[0] = 1;\t// for(int S = 1;S &lt; all;++S)\t// \tfor(int T = S;T;T = (T - 1) &amp; S)\t// \t\tPlus(dp[S],1ll * f[siz[T]][T] * dp[S - T] % P);\t// cout &lt;&lt; dp[all - 1] &lt;&lt; endl;\tf[0][0] = 1;\tfor(int i = 1;i &lt; all;i++) f[siz[i]][i] = P - f[siz[i]][i];\tfor(int i = 0;i &lt;= n;i++)\t\tFWT(f[i],all,1);\tfor(int t = 0;t &lt; all;t++) {\t\tstatic int g[N],h[N];\t\tfor(int i = 0;i &lt;= n;i++)\t\t\tg[i] = f[i][t];\t\tGetInv(g,h,n + 1);\t\tfor(int i = 0;i &lt;= n;i++)\t\t\tf[i][t] = h[i];\t}\tfor(int i = 0;i &lt;= n;i++)\t\tFWT(f[i],all,-1);\tcout &lt;&lt; f[n][all - 1] &lt;&lt; endl;\treturn 0;}\r\n","tags":["DP","counting"]},{"title":"CF1499G 题解","url":"/posts/1452645614/","content":"非常神的题目啊。\r\n\r\n考虑不加边的时候这个问题怎么解决。显然照搬 CF547D\r\n，建立虚点，将虚点与原图所有度数为奇数的点连边，跑个欧拉回路，对回路上的边黑白染色，即可达到答案下界：\r\n。\r\n接下来考虑图上加边怎么处理。现在无法再沿用虚点，因为原图上加边会引起虚点上的加边删边，很难维护。但如果把虚点拆掉，注意到欧拉回路会分成许多环和路径，考虑直接维护这些环和路径。\r\n在一般图中是做不到的，但这题是二分图。况且，每个点只可能是一条路径的端点，如果有多于一条路径以同一个点为端点，这些路径自然可以接起来。\r\n对每条边赋权值 ，表示其从左部指向有部还是从右部指向左部。\r\n考虑加一条边  的情况：\r\n\r\n如果  和  都不是某条路径的端点，那直接将  作为一条新路径即可。\r\n如果  是某条路径的端点而  不是，那将  接到  所在路径上即可。\r\n如果  和 \r\n都是某条路径的端点，那就要分类讨论。如果这两条路径同向，那么将这条边改到对应的方向即可。否则，我们需要整体翻转一条路径，并将这两条路径于这条边合并。\r\n\r\n我们需要一个支持整体翻转和合并的数据结构，标算写的是启发式合并堆。但实际上有非常简单的带权并查集维护法，毕竟我们并不考虑路径中点的具体顺序，只考虑路径的点集和每条边的权值（方向）。\r\n简略介绍带权并查集：假设我们要维护每个点的值 ，那么我们存储的是  使得  到根上所有点  的  之和就是原来的 。那么在找祖先时，我们先往父亲递归，然后将自己存储的值加上父亲的\r\n\r\n","tags":["graph theory"]},{"title":"CF1474F 题解","url":"/posts/1975077780/","content":"做的时候没有觉得这是一道找性质题，以至于连突破口都没找到。\r\n\r\n其实原序列更一般的序列最大的区别在于，其相邻两项的差只有  或 。说明如果存在 ，那么对于任意 ，都存在一个  使得 。这就是连续函数性质的离散版本。\r\n所以，任何一个 LIS 都是公差为 \r\n的等差数列，否则一定可以调整使其变大。\r\n类似地可以证明，所有 LIS 的起点或终点一定在原序列的波峰或波谷上 （即\r\n\r\n或  的位置）。如果不在的话，假设终点  满足 ，那么可以将终点调整到  。如果是 ，那可以将其调整到其所属下降区间的最左端，这样一定可以在前面多选一些数，故原方案也是劣的。\r\n那么第一问就好解决了，显然波峰或波谷只可能在给出的每一段的端点。设\r\n 表示第  段结尾的数，答案就是 。\r\n设 ，将所有  的二元组提出来按 \r\n排序，那么 \r\n一定是单调不增的（如果出现了  使得  ，那么  显然比  更大）。另一方面，如果把所有  相同的连续段都一起考虑，设其中最大的\r\n 为 ，这些  对应的最小的  为 ，那么区间 \r\n显然是互不相交的。所以可以分开处理，最后将每个区间的答案加起来。\r\n现在对于每个区间，我们已经知道了 LIS 的构成就是 。那直接从小往大填。设  表示当前填到了数 ，这个数在第  段的方案数。每次从  转移到 。但是  的规模很大，所以将值域按照  中每一段的端点的值划分为 \r\n段，每一段内的转移方程是相同的，用矩阵快速幂优化即可。\r\n时间复杂度 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55,P = 998244353;inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}typedef long long ll;struct Mat {\tint a[N][N];\tMat() { memset(a,0,sizeof a);}\tint * operator [](const int p) { return a[p];}\tMat operator * (const Mat &amp;rhs) const {\t\tMat res;\t\tfor(int i = 0;i &lt; N;i++)\t\t\tfor(int k = 0;k &lt; N;k++)\t\t\t\tfor(int j = 0;j &lt; N;j++)\t\t\t\t\tPlus(res.a[i][j],1ll * this-&gt;a[i][k] * rhs.a[k][j] % P);\t\treturn res;\t}\tvoid init() {\t\tfor(int i = 0;i &lt; N;i++)\t\t\tfor(int j = 0;j &lt; N;j++)\t\t\t\ta[i][j] = (i == j);\t}};int n,a[N];ll sum[N];ll vals[N &lt;&lt; 1];inline int Solve(int l,int r) {\tint len = 0;\tfor(int i = l + 1;i &lt;= r;i++) {\t\tll L = sum[i - 1] + (a[i] &gt; 0 ? 1 : -1),R = sum[i];\t\tif(L &gt; R) swap(L,R);\t\tif(L - 1 &gt;= sum[l]) vals[++len] = L - 1;\t\tvals[++len] = R;\t}\tsort(vals + 1,vals + len + 1);\tlen = unique(vals + 1,vals + len + 1) - vals - 1;\tvals[0] = -0x3f3f3f3f;\tMat T;\tfor(int i = l;i &lt;= r;i++)\t\tif(sum[i] == sum[l]) T[0][i] = 1;\tfor(int i = 2;i &lt;= len;i++) { // (vals[i - 1],vals[i]]\t\tMat trs;\t\tvector&lt;int&gt; V;\t\tfor(int j = l + 1;j &lt;= r;j++) {\t\t\tll L = sum[j - 1] + (a[j] &gt; 0 ? 1 : -1),R = sum[j];\t\t\tif(L &gt; R) swap(L,R);\t\t\tif(L &lt;= vals[i - 1] + 1 &amp;&amp; vals[i] &lt;= R)\t\t\t\tV.push_back(j);\t\t}\t\t\tfor(auto id : V)\t\t\tfor(int j = l;j &lt; id;j++)\t\t\t\ttrs[j][id] = 1;\t\tfor(auto id : V)\t\t\tif(a[id] &gt; 0) trs[id][id] = 1;\t\tint tim = vals[i] - vals[i - 1];\t\twhile(tim) { if(tim &amp; 1) T = T * trs;trs = trs * trs;tim &gt;&gt;= 1;}\t}\tint res = 0;\tfor(int i = l;i &lt;= r;i++) Plus(res,T[0][i]);\treturn res;}int main() {\tscanf(\"%d%*d\",&amp;n);\tfor(int i = 1;i &lt;= n;i++) scanf(\"%d\",&amp;a[i]);\tstatic int b[N];int tn = 0;\tfor(int i = 1;i &lt;= n;i++) if(a[i]) b[++tn] = a[i];\tn = tn;swap(a,b);\tif(!n) return puts(\"1 1\"),0;\tfor(int i = 1;i &lt;= n;i++) sum[i] = sum[i - 1] + a[i];\tll mx = 0;\tfor(int i = 0;i &lt;= n;i++)\t\tfor(int j = i + 1;j &lt;= n;j++)\t\t\tmx = max(mx,sum[j] - sum[i]);\tif(mx == 0) return printf(\"%d %lld\\n\",1,(-sum[n] + 1) % P),0;\tint ans = 0;\tfor(int i = 0;i &lt;= n;i++) {\t\tint p = -1;\t\tfor(int j = i + 1;j &lt;= n;j++)\t\t\tif(sum[j] - sum[i] == mx) p = j;\t\tif(~p) Plus(ans,Solve(i,p)),i = p;\t}\tprintf(\"%lld %d\\n\",mx + 1,ans);\treturn 0;}\r\n","tags":["counting"]},{"title":"CF1508D 题解","url":"/posts/4076501828/","content":"感觉稍微降智了，没有手玩清楚。\r\n\r\n先不考虑线段不相交的限制，那么将点权归位只需在每个置换环中找一个点\r\n，然后不断交换  和  的值\r\n，这样一次操作就会让环的大小减少 ，最后就归位了。\r\n此时连出的线段都以 \r\n为端点，它们自然不会相交，无论一个置换环的点在平面上的形态如何。（我当时以为凹多边形不能这么换，就自闭在这了）\r\n那么我们策略就是先将所有点拼成一个大环，然后在大环上做上面的操作。\r\n怎么拼呢？对两个不在一个环中的元素做交换可以令这两个环合并。对于这些交换，直觉告诉我们尽量用凸包上的相邻点做交换就可以避免相交。\r\n这样的问题在于会遗漏一些点拼不成一个大环。\r\n回顾 Graham\r\n求凸包的过程：先找到一个最左下的基准点，然后将其他点按照与该点形成的极角排序。\r\n事实上，排完序之后的相邻点之间的线段就不会相交了。所以在这个序列上，如果相邻点不在一个环内，就交换并合并，最后在大环上一起还原即可。\r\n","tags":["constructive algorithm"]},{"title":"CF1508E 题解","url":"/posts/1045461978/","content":"非常好题目。做完之后感觉，自己归纳性质的能力需要加强，不能让思考仅仅停留在手玩和感性理解，要尝试将一些东西往已知的模型上想。\r\n\r\n设 在树原来的 dfs 序为位置\r\n。\r\n手玩一下操作过程，发现操作可以分为若干个阶段，每个阶段都是将数\r\n 从根换到下面，并把  换到根。\r\n换  的时候，它会沿着 \r\n最小的一条链一路换下去，最后换到某个叶子。事实上，这个叶子就是 DFS\r\n过程中，第一个出栈的节点。\r\n换完之后，除这个叶子，剩下的  个节点上的数仍然按原来的 DFS\r\n序排列，也就是说，这个过程可以归纳地进行下去。\r\n那我们就知道树上的数在很多次操作后的形状了。每个节点上的数将从 DFS\r\n序变为出栈序。\r\n而且，每次将数 \r\n恰好换到其对应位置的时候，数  所在的节点的出栈序是  ，而数  在剩下的节点中，按 DFS\r\n序的顺序排列。\r\n再次观察操作过程，发现任何时候，儿子之间  的相对大小关系是不变的。\r\n证明：\r\n考虑点  和它的儿子  ，。\r\n一次关于  的交换，  显然会找到第一个  的儿子\r\n。所以有 。\r\n那么将  替换为 ，相对大小关系肯定不变。\r\n而如果还要交换 \r\n与其子节点，显然  仍然成立，同时，\r\n不是这个操作阶段正在下移的数的目标节点。\r\n所以，在交换之后，  的值，在\r\n这个操作阶段结束前，值都不会改变，所以它们仍然按原图的\r\nDFS 序排列，所以它们的相对大小关系不变。\r\n那么  就直接可以通过将  排序后 DFS 来产生，所以题面中的“多解输出任意解”是假的。\r\n回到原问题。\r\n考虑先算出当前在哪个操作阶段。如果 ，说明此时未进行任何操作，否则当前阶段数就是 。（即数  正在从上往下移动）。令 。\r\n算出来之后，手动回退一部分操作，使得当前局面为该阶段的开头。\r\n接下来检查合法性，我们需要确保  都换到了出栈序为  的节点，同时 \r\n按原来的 DFS 序排列。\r\n然后计算天数。\r\n中的每个节点，都是从根换到其现在的位置的，所以答案就是之前回退的天数加上\r\n，其中 \r\n表示数  现在的位置。\r\n\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5 + 5;int n;int a[N];int fir[N],nxt[N &lt;&lt; 1],to[N &lt;&lt; 1],ect = 1;inline void addedge(int u1,int v1) {\tnxt[++ect] = fir[u1];fir[u1] = ect;to[ect] = v1;}vector&lt;int&gt; sons[N];int dep[N],fa[N];int pos[N];int frt[N]; // 最初的 dfs 序int ext[N]; // 出栈序long long ans;void dfs0(int x,int f) {\tfor(int i = fir[x],y;y = to[i],i;i = nxt[i]) {\t\tif(y == f) continue;\t\tdep[y] = dep[x] + 1;\t\tfa[y] = x;\t\tdfs0(y,x);\t\tsons[x].push_back(y);\t}\tsort(sons[x].begin(),sons[x].end(),[&amp;](const int &amp;x,const int &amp;y) { return a[x] &lt; a[y];});}int ps_frt[N],ps_ext[N];void dfs1(int x) {\tfrt[x] = ++frt[0];ps_frt[frt[x]] = x;\tfor(auto y : sons[x]) dfs1(y);\text[x] = ++ext[0];ps_ext[ext[x]] = x;}bool Isanc(int u,int v) { // v 是不是 u 的祖先\tif(u == v) return true;\tif(u == 1) return false;\treturn Isanc(fa[u],v);}void GoBack(int u) {\tif(u == 1) return;\tswap(a[u],a[fa[u]]);\t++ans;\tGoBack(fa[u]);} int main() {\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i];\tfor(int i = 1,u,v;i &lt; n;i++)\t\tcin &gt;&gt; u &gt;&gt; v,addedge(u,v),addedge(v,u);\tdfs0(1,0);\tdfs1(1);\tif(a[1] == 1) {\t\tfor(int i = 1;i &lt;= n;i++)\t\t\tif(frt[i] != a[i]) return puts(\"NO\"),0;\t\tputs(\"YES\");\t\tputs(\"0\");\t\tfor(int i = 1;i &lt;= n;i++) printf(\"%d \",frt[i]);printf(\"\\n\");\t\treturn 0;\t}\tint cur = a[1] - 1; // 当前调整到的值\t\tfor(int i = 1;i &lt;= n;i++) pos[a[i]] = i;\tif(!Isanc(ps_ext[cur],pos[cur])) return puts(\"NO\"),0; // 无法调整到出栈序位置\tGoBack(pos[cur]);\tfor(int i = 1;i &lt;= n;i++) pos[a[i]] = i;\tfor(int i = 1;i &lt; cur;i++)\t\tif(ext[pos[i]] != i) return puts(\"NO\"),0;\tfor(int i = cur;i &lt; n;i++)\t\tif(frt[pos[i]] &gt; frt[pos[i + 1]]) return puts(\"NO\"),0;\tputs(\"YES\");\tfor(int i = 1;i &lt; cur;i++) ans += dep[pos[i]];\tprintf(\"%lld\\n\",ans);\tfor(int i = 1;i &lt;= n;i++) printf(\"%d \",frt[i]);printf(\"\\n\");\treturn 0;}\r\n","tags":["constructive algorithm"]},{"title":"CF1510H 题解","url":"/posts/4048529197/","content":"怎么这题还要还原方案的。 /fn\r\n\r\n首先，看到区间之间包含或不交，考虑按照包含关系建树，每个区间的父亲是包含它的长度最小的区间。建完树后将一个点的儿子按位置关系排序。\r\n然后在树上考虑 DP。设一个点 \r\n共有  个儿子，那么其会将  分为  段。考虑属于  的答案怎么填。一共就两种情况：\r\n\r\n其可以完全被某个儿子包含，相当于在这个儿子处 DP\r\n时要多处理一条线段。\r\n也可以跨过这 \r\n段中的一段，并可能与某个儿子的后半部分拼接，和另一个儿子的前半部分拼接。\r\n\r\n那么 DP 状态就可以设出来了。设  表示在  子树中，填 \r\n条线段，是否有一条线段的左端点在  外，是否有一条线段的右端点在  外的最优答案。（ 表示  的子树大小， 其实就表示从祖先处传过来  条线段，对应情况 1）注意，对于左端点在\r\n\r\n左边的那条线段，我们先不将其左端点对答案的贡献计入 DP\r\n值，这条线段也不计入  中。等到某次\r\nDP 时，这个左端点被确定了，再将其算进来。\r\n考虑如何进行转移：设  表示在点  的前  个儿子及其中间的空段中，多填入  条线段 （\r\n的意义类似上面），前后是否有未完全确定的线段。\r\n设  表示  的第  个儿子，  的转移是简洁的：  第二个转移表示在  和 \r\n之间的空档填了一条线段。此时  中记录了该线段左端点的贡献，\r\n中记录了该线段右端点的贡献，直接相加就可以将这一条线段的贡献算入 DP\r\n值中。\r\n设  表示点  的最后一个儿子。那么  也可以从  转移过来：  第一条式子其实没有新增任何线段，但因为  本身就要求填一条线段，所以\r\n“多填的线段数”就少了一条。第二条式子中，如果 ，那么相当于闭合一条在 \r\n中还未完全确定的线段并加上贡献。第三条式子同理。\r\n这个 DP 乍一看是 \r\n的，毕竟我们没有说明 \r\n的规模。但事实上，一个有 \r\n个儿子的点最多将自己划分为 \r\n段，所以  子树最多被划分为  段。所以，如果线段条数多于\r\n，那 \r\n子树中的所有位置都可以被答案线段覆盖。所以只需记录  的 DP\r\n值即可得到正确答案。\r\n接下来考虑怎么还原方案。\r\n首先从 \r\n开始，考虑回溯转移路径，这个可以用递归函数实现。然后分几种情况讨论答案线段的位置。\r\n","tags":["DP"]},{"title":"CF1852E 题解","url":"/posts/2260956935/","content":"怎么还会新建一种元素的。不过没有这种情况也称不上 *3400 了。\r\n\r\n首先有一个显然的观察： 对于一个数 ，只有其出现的最左/最右位置会对子区间权重产生影响。那么，可以将每个序列中的数抽象为一个三元组\r\n。\r\n容易发现，对于  ，且\r\n 的  包含了  的  ，那 \r\n就不可能是任何子区间的权重，这个数就没用了。\r\n删去这样的数之后，所有的数都会是某个子区间的权重，而且，这样的数的两个端点都已经确定，不会改变。\r\n考虑如何填写那些并不是某个数的区间端点的位置。\r\n一个显然的想法是对位置  ，填\r\n 包含它的  中  最大者，下文设这个值为 。但你发现这么写过不了样例中\r\n1 1 1 1 4 4 3 3 3\r\n的数据。然后你惊奇地发现答案中出现了原序列没有的数。\r\n不过好消息是，只会出现一种新的数，因为如果出现了两种，显然可以把小的数全都变成大的数，子区间权重不变。\r\n设这个数为 。假设我们已经知道了  的左右端点 ，那就必须存在一个  的  ，使得 ，否则 \r\n就会成为某个子区间的权重，产生矛盾。换个角度来说，如果我们枚举这个 ，那么 \r\n就必须是小于它的，最大的没有出现过的元素，这样显然是最优的。\r\n考虑枚举  之后怎么填 。我们从大到小枚举 ，并将  的位置先填上 。将  的位置全部填上 。但这么填还不一定能满足上面的条件，所以如果上一步在\r\n 的左边没有填上 ，就得找一个 已经填了  的数，将其改为 ，显然找最小的最优。  的右边同理。\r\n于是本题就做完了，时间复杂度 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pii;#define FI first#define SE secondconst int N = 1e5 + 5;int n,a[N];pii Mn[N &lt;&lt; 2];void pushup(int k) { Mn[k] = min(Mn[k &lt;&lt; 1],Mn[k &lt;&lt; 1 | 1]);}void Change(int k,int l,int r,int pos,int v) {\tif(l == r) { Mn[k] = make_pair(v,pos);return;}\tint mid = l + r &gt;&gt; 1;\tif(pos &lt;= mid) Change(k &lt;&lt; 1,l,mid,pos,v);\telse Change(k &lt;&lt; 1 | 1,mid + 1,r,pos,v);\tpushup(k);}pii Query(int k,int l,int r,int x,int y) {\tif(x &lt;= l &amp;&amp; r &lt;= y) return Mn[k];\tint mid = l + r &gt;&gt; 1;\tif(y &lt;= mid) return Query(k &lt;&lt; 1,l,mid,x,y);\telse if(x &gt; mid) return Query(k &lt;&lt; 1 | 1,mid + 1,r,x,y);\telse return min(Query(k &lt;&lt; 1,l,mid,x,y),Query(k &lt;&lt; 1 | 1,mid + 1,r,x,y));}void build(int k,int l,int r) {\tMn[k] = make_pair(1e9,1e9);\tif(l == r) return;\tint mid = l + r &gt;&gt; 1;\tbuild(k &lt;&lt; 1,l,mid);build(k &lt;&lt; 1 | 1,mid + 1,r);}vector&lt;int&gt; vals,usd;map&lt;int,vector&lt;int&gt; &gt; Qu;int Ans[N];inline void work() {\tvals.clear();Qu.clear();\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++)\t\tcin &gt;&gt; a[i],Qu[Ans[i] = a[i]].push_back(i);\tfor(auto i : Qu) vals.push_back(i.FI);\tbuild(1,1,n);\tusd.clear();\treverse(vals.begin(),vals.end());\tfor(auto &amp;i : Qu) {\t\tfor(int j = 1;j &lt; i.SE.size() - 1;j++)\t\t\tAns[i.SE[j]] = 0;\t}\tfor(auto i : vals) {\t\tint l = Qu[i][0],r = Qu[i].back();\t\tif(Query(1,1,n,l,r).FI &lt;= r)\t\t\tAns[l] = Ans[r] = 0;\t\telse Change(1,1,n,l,r),usd.push_back(i);\t}\tvector&lt;int&gt; lst(usd.size());\tlst.back() = usd.back() - 1;\tfor(int j = lst.size() - 2;j &gt;= 0;j--)\t\tif(usd[j] - 1 != usd[j + 1]) lst[j] = usd[j] - 1;\t\telse lst[j] = lst[j + 1];\tlong long mxans = 0;\tint mxval = 0;\tbuild(1,1,n);\tset&lt;int&gt; S;\tfor(int i = 1;i &lt;= n;i++) if(!Ans[i]) S.insert(i),Change(1,1,n,i,-1);\tlong long sum = 0; // 比 t 大的数之和\t\tvector&lt;pair&lt;int,int&gt; &gt; Upd;\tint lnew = -1,rnew = -1;\tint poi = 0;\tfor(int t = 0;t &lt; usd.size();t++)\t{\t\twhile(poi &lt; usd.size() &amp;&amp; usd[poi] &gt; lst[t]) {\t\t\tint l = Qu[usd[poi]][0],r = Qu[usd[poi]].back();\t\t\tauto it = S.lower_bound(l);\t\t\twhile(it != S.end() &amp;&amp; *it &lt;= r) {\t\t\t\tsum += usd[poi];\t\t\t\tChange(1,1,n,*it,usd[poi]);\t\t\t\tUpd.emplace_back(*it,usd[poi]);\t\t\t\tit = S.erase(it);\t\t\t}\t\t\t++poi;\t\t}\t\tif(!lst[t]) continue;\t\tint L = Qu[usd[t]][0],R = Qu[usd[t]].back();\t\tif(L == 1 || R == n) continue;\t\tpii lp = Query(1,1,n,1,L - 1),rp = Query(1,1,n,R + 1,n);\t\tif(lp.FI &gt;= 1e9 || rp.FI &gt;= 1e9) continue;\t\tlong long add = lst[t] * S.size() + (lp.FI == -1 ? 0 : lst[t] - lp.FI) + (rp.FI == -1 ? 0 : lst[t] - rp.FI);\t\tif(lst[t] &amp;&amp; sum + add &gt; mxans) {\t\t\tmxans = sum + add;\t\t\tmxval = lst[t];\t\t\tlnew = (lp.FI == -1 ? -1 : lp.SE);\t\t\trnew = (rp.FI == -1 ? -1 : rp.SE);\t\t\twhile(!Upd.empty()) {\t\t\t\tAns[Upd.back().FI] = Upd.back().SE;\t\t\t\tUpd.pop_back();\t\t\t}\t\t}\t}\tif(S.size() == 0 &amp;&amp; sum &gt; mxans) {\t\tmxans = sum;\t\tlnew = rnew = -1;\t\twhile(!Upd.empty()) {\t\t\tAns[Upd.back().FI] = Upd.back().SE;\t\t\tUpd.pop_back();\t\t}\t}\tif(~lnew) Ans[lnew] = 0;\tif(~rnew) Ans[rnew] = 0;\tfor(int i = 1;i &lt;= n;i++)\t\tprintf(\"%d \",Ans[i] ? Ans[i] : mxval);\tprintf(\"\\n\");}\tint main(){\tint T;\tcin &gt;&gt; T;\twhile(T--) work();\treturn 0;}\r\n","tags":["thinking","DS"]},{"title":"CF1528E 题解","url":"/posts/983935975/","content":"作者在草稿纸上其实把三种情况都画出来了，但是没有想到情况只有这三种。瞄了一眼题解之后，推\r\nDP 式子就较为简单了。\r\n还是对这种找性质题记一笔。以后遇到这种题不要畏难，多做一做就出来了。\r\n\r\n考虑第三个条件如何转化。其实需要发现，任意两点 \r\n之间的简单路径上，只能有一对相邻边的方向不同，否则 \r\n肯定找不到共同的能到达它或它能到达的点。容易发现，外向树或内向树都是一种不同相邻边不超过\r\n\r\n的方案，然而事实上还有一种，就是一棵内向树和一棵外向树在根处拼接，这个时候，对于内向树中的点\r\n 和外向树中的点 ， 之间的边方向全都相同。\r\n首先考虑外向树的方案数，这种树除了根以外都只能有  个儿子，那么先设  表示最大深度为 ，根最多两个儿子的方案数，设  表示  的前缀和。\r\n考虑  的转移：\r\n\r\n只有一个儿子，此时 。\r\n有两个儿子，此时必须有一个儿子的深度为 。先考虑所有儿子深度  的方案数，是 ，（为什么不是\r\n\r\n呢，因为如果两个子树的儿子形态不同，在这个式子里会被算两次，所以需要去重，就变成了上面这个组合数），再减去所有儿子深度\r\n\r\n的方案数，就得到了至少有一个儿子深度为  的方案数。\r\n\r\n综上所述，。\r\n那么，深度为 \r\n的内向树的方案就有 \r\n种，外向树同理。但因为一条单链会被内向树\r\n和外向树都算一遍，所以这一部分的答案是上式乘  再减  。\r\n再考虑内向树拼外向树怎么做。这两部分中间可能有一条链相连接，为了避免在这条链上重复计数，我们钦定外向树部分的根有恰好两个儿子\r\n。设  表示  ，即深度为 \r\n，且根恰好有两个儿子的方案数。那么答案就是 。减 \r\n是因为如果内向树部分是一条单链，那接起来之后还是一棵外向树，这一部分在前面算过了。\r\n于是本题就做完了，时间复杂度 。难点在于归纳答案的形态。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5,P = 998244353;const int inv2 = (P + 1) / 2,inv6 = (P + 1) / 6;inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}int n;int f[N],g[N];int sf[N];inline int C2(int x) { return 1ll * x * (x - 1) % P * inv2 % P;}inline int C3(int x) { return 1ll * x * (x - 1) % P * (x - 2) % P * inv6 % P;}int main(){\tcin &gt;&gt; n;\t// if(n == 1) { puts(\"5\");return 0;}\tf[0] = sf[0] = 1;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tf[i] = f[i - 1];\t\tPlus(f[i],(C2(sf[i - 1] + 1) - (i &gt;= 2 ? C2(sf[i - 2] + 1) : 0) + P) % P);\t\tsf[i] = sf[i - 1];Plus(sf[i],f[i]);\t}\tint ans = C3(sf[n - 1] + 2);\tif(n &gt;= 2) Plus(ans,P - C3(sf[n - 2] + 2)); // 外向树方案\tPlus(ans,f[n]);\tans = (2ll * ans - 1 + P) % P; // 最终方案\tg[1] = 1;\tfor(int i = 2;i &lt;= n;i++) \t\tg[i] = (C2(sf[i - 1] + 1) - C2(sf[i - 2] + 1) + P) % P;\tfor(int i = 1;i &lt; n - 1;i++)\t\tPlus(ans,1ll * g[i] * (f[n - 1 - i] - 1 + P) % P);\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["DP"]},{"title":"CF1540C2 题解","url":"/posts/3060868465/","content":"一开始做的时候花较长时间推了一个假做法，写完暴力发现做法假了之后就不想再想了，比较可惜。\r\n这种题能不能给个强一点的样例解释，样例解释的序列都只要操作  次（\r\n\r\n考虑操作  之后  和  不变化的条件：  你发现两个数对应的条件是一样的，也就是说，如果 ，那么都会变化，否则都不会变。这点可以引申出，是不会被这次操作影响的，即序列中所有数的和不变。\r\n如果变化了，容易发现 。\r\n设  表示  收敛之后的结果。\r\n那么如果 ，那么 。反过来说，如果 ，那么整个过程中就不会操作 。\r\n这一点我没归纳出来，看来还需要多分析终态的性质，不仅仅是操作过程的性质。\r\n如果我们能找到最小的  使得\r\n\r\n，那么， 和  是完全无关的！\r\n因为题目只关心 ，所以我们可以列出关于  的若干个方程，尝试解出 。  设 。\r\n那么 。\r\n但我们并不知道 \r\n的取值是多少，怎么办呢？\r\n我们可以将  取遍 ，每次都解一遍方程，然后让解的最小值作为  !\r\n接下来说明这为什么是对的。\r\n首先  肯定 ，因为肯定存在一个  满足 。\r\n另一方面，如果 ，那么在 \r\n之前肯定有一个 ，而 \r\n不变，所以为了跨度更大只能减小初值。故此时有 。\r\n那么  等价于 \r\n，也就是说，对于 ，都有 。这个条件与原限制等价。\r\n有了这个结论就可以直接背包来做 F1 了。\r\n考虑\r\nF2，唯一的不同在于询问很多，但是注意到有很多的询问都是没用的。\r\n具体地，如果  过小，使得  全为  都满足条件，那么答案显然为 。\r\n如果  过大，使得  都不满足条件（即存在 ），那么答案显然为 。\r\n考虑算出这两个界的具体值，设 。\r\n那么在  之外的  都可以用上面的判断解决。\r\n否则，不同的  只有  个，对这些  预处理答案即可。\r\n非常 math 的一道题，哪怕是 F1，严谨的分析过程也较长。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e2 + 5,M = 2e4 + 5,P = 1e9 + 7;inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}int n,c[N],b[N];int f[M],g[M];int sb[N];map&lt;int,int&gt; Ans;inline int Solve(int x){\tfor(int i = 0;i &lt; M;i++) f[i] = 0,g[i] = 1;\tint sc = 0;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tint lim = i * x + sb[i];sc += c[i];\t\tfor(int j = max(0,lim);j &lt; M;j++)\t\t\tf[j] = (g[j] - (j - c[i] - 1 &gt;= 0 ? g[j - c[i] - 1] : 0) + P) % P;\t\tg[0] = f[0];f[0] = 0;\t\tfor(int j = 1;j &lt; M;j++)\t\t\tg[j] = (g[j - 1] + f[j]) % P,f[j] = 0;\t}\treturn g[M - 1];}int main(){\tcin &gt;&gt; n;int m = 0,mul = 1;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; c[i],m = max(m,c[i]),mul = 1ll * mul * (c[i] + 1) % P;\tfor(int i = 1;i &lt; n;i++) cin &gt;&gt; b[i];\tfor(int i = 1;i &lt;= n;i++)\t\tfor(int j = 1;j &lt; i;j++)\t\t\tsb[i] += (i - j) * b[j];\tdouble lb = 0,rb = 1e9;\tfor(int i = 1;i &lt;= n;i++)\t\tlb = min(lb,-1.0 * sb[i] / i),\t\trb = min(rb,1.0 * (i * m - sb[i]) / i);\tlb = ceil(lb);rb = floor(rb);\t// printf(\"lb,rb:%.4lf,%.4lf\\n\",lb,rb);\tfor(int i = lb;i &lt;= rb;i++) Ans[i] = Solve(i);\tint q,x;\tcin &gt;&gt; q;\twhile(q--)\t{\t\tcin &gt;&gt; x;\t\tif(lb &lt;= x &amp;&amp; x &lt;= rb) cout &lt;&lt; Ans[x] &lt;&lt; endl;\t\telse if(x &lt; lb) cout &lt;&lt; mul &lt;&lt; endl;\t\telse cout &lt;&lt; 0 &lt;&lt; endl;\t}\treturn 0;}\r\n","tags":["DP"]},{"title":"CF1830F 题解","url":"/posts/732178469/","content":"分享一个 KTT 做法，并简单介绍一下 KTT。\r\n\r\n首先考虑 DP，设 \r\n表示最后一个选的点为 \r\n的方案数（暂时不计算 \r\n的贡献，等到 \r\n的下一个点再计算），那么有转移 。\r\n考虑用扫描线解决 \r\n的限制，或者说，维护  表示从\r\n 转移到当前位置  的代价，那么每次  时，单点修改  为  ，将所有  的区间提出，对于  中的所有  ，将 。转移时取  全局  即可。\r\n整理一下操作：单点修改 ，区间使 ，查询  全局 。\r\n分块维护凸包可以做到 ，但过不了，故不展开。\r\n介绍一下 KTT 这种数据结构（更详细的介绍参见 EI's\r\nblog)。\r\n对于每个 \r\n而言，其实质上是个一次函数 ，表示该点被区间操作了 \r\n次后的真实值。\r\n如果 ，那么我们只需在线段树上维护区间中  的  即可。\r\n如果 ，其实也可以维护\r\n 的 ，但是有一个问题在于，可能原本这个区间的\r\n\r\n在左儿子，但是进行若干次区间加之后，右儿子中的真实值更大了，这时再沿用原来的结果就会出问题。\r\nKTT 的处理思路就是，对线段树上的每个节点，处理出一个时间阈值  ，表示当前区间加了 \r\n次后，该节点或其后代节点中  的取向会发生改变。因为  两边的一次函数都是已知的，时间  容易被处理出来。\r\n对一个节点进行区间加时，如果当前加的值  比  小，那就直接让当前区间维护的一次函数的\r\n 加上 ，并更新区间加 tag。否则，就将\r\n 加上当前节点的  ，加到两个子区间，然后递归下去，再\r\npushup 更新当前节点的信息。\r\n复杂度证明详见 EI 的 blog。\r\n基本思想是，如果区间加的次数 \r\n极小， \r\n的取向不会发生改变，就用简单方法维护。否则就递归更新，势能分析保证复杂度。\r\n在本题使用 KTT，时间复杂度可以做到 。\r\n代码如下：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;namespace FastIO {\t#define iL (1 &lt;&lt; 20)\tchar ibuf[iL],*iS = ibuf + iL,*iT = ibuf + iL;\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf,1,iL,stdin),iS == iT ? EOF : *iS++) : *iS++)\ttemplate&lt;typename T&gt;\tinline void read(T &amp;a)\t{\t\tchar ch;int sign = 0;\t\tfor(ch = gc();!isdigit(ch);ch = gc())\t\t\tif(ch == '-') sign = 1;\t\ta = ch &amp; 15;\t\tfor(ch = gc();isdigit(ch);ch = gc())\t\t\ta = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch &amp; 15);\t\tif(sign) a = -a;\t}\tchar Out[iL],*iter = Out;\t#define flush() fwrite(Out,1,iter - Out,stdout),iter = Out\ttemplate&lt;typename T&gt;\tinline void write(T x,char end = '\\n')\t{\t\tint c[40],l = 0;if(x &lt; 0) *iter++ = '-',x = -x;\t\tdo c[++l] = x % 10,x /= 10; while(x);\t\twhile(l) *iter++ = c[l--] + '0';\t\t*iter++ = end;flush();\t}\t#undef iL \t#undef gc\t#undef flush}using namespace FastIO;const int N = 1e6 + 5,Sz = N &lt;&lt; 2;typedef long long ll;const ll llinf = 0x3f3f3f3f3f3f3f3f;#define FI first#define SE secondint n,m,p[N];int L[N],R[N];ll dp[N];vector&lt;int&gt; Qu[N];struct Func{\tint k;ll b;\tFunc() { k = b = 0;}\tFunc(const int _k,const ll _b):k(_k),b(_b){}\tFunc operator + (const Func &amp;rhs) const { return Func(k + rhs.k,b + rhs.b);}\tvoid add(int v) { b += 1ll * k * v;} };inline pair&lt;Func,ll&gt; Max(Func a,Func b){\tif((a.k &lt; b.k) || (a.k == b.k &amp;&amp; a.b &lt; b.b)) swap(a,b);\tif(a.b &gt;= b.b) return make_pair(a,llinf);\telse return make_pair(b,(b.b - a.b) / (a.k - b.k));}struct Node{\tFunc Mx;\tll x; // 赶超阈值\tinline friend Node operator + (const Node &amp;a,const Node &amp;b)\t{\t\tNode res;\t\tres.x = min(a.x,b.x);\t\tauto tmp = Max(a.Mx,b.Mx);\t\tres.Mx = tmp.FI;res.x = min(res.x,tmp.SE);\t\treturn res;\t}};Node tr[Sz];int tag[Sz];void pushup(int x) { tr[x] = tr[x &lt;&lt; 1] + tr[x &lt;&lt; 1 | 1];}inline void Giv(int x,int v){\ttag[x] += v;\ttr[x].x -= v;\ttr[x].Mx.add(v);}inline void pushdown(int x){\tif(!tag[x]) return;\tGiv(x &lt;&lt; 1,tag[x]);Giv(x &lt;&lt; 1 | 1,tag[x]);\ttag[x] = 0;}void defeat(int k,int l,int r,int v){\tif(v &gt;= tr[k].x)\t{\t\tint mid = l + r &gt;&gt; 1;\t\tint t = tag[k] + v;tag[k] = 0;\t\tdefeat(k &lt;&lt; 1,l,mid,t);\t\tdefeat(k &lt;&lt; 1 | 1,mid + 1,r,t);\t\tpushup(k);\t}\telse Giv(k,v);}void modify(int k,int l,int r,int x,int y,int v){\tif(x &lt;= l &amp;&amp; r &lt;= y) return defeat(k,l,r,v);\tint mid = l + r &gt;&gt; 1;\tpushdown(k);\tif(x &lt;= mid) modify(k &lt;&lt; 1,l,mid,x,y,v);\tif(mid &lt; y) modify(k &lt;&lt; 1 | 1,mid + 1,r,x,y,v);\tpushup(k);}ll Query(int k,int l,int r,int x,int y){\tif(x &lt;= l &amp;&amp; r &lt;= y) return tr[k].Mx.b;\tint mid = l + r &gt;&gt; 1;\tpushdown(k);\tif(y &lt;= mid) return Query(k &lt;&lt; 1,l,mid,x,y);\telse if(x &gt; mid) return Query(k &lt;&lt; 1 | 1,mid + 1,r,x,y);\telse return max(Query(k &lt;&lt; 1,l,mid,x,y),Query(k &lt;&lt; 1 | 1,mid + 1,r,x,y));}void Change(int k,int l,int r,int pos){\tif(l == r) { \t\tFunc t(p[pos] + tag[k],dp[pos]);\t\ttr[k].Mx = t;tr[k].x = llinf;\t\treturn;\t}\tint mid = l + r &gt;&gt; 1;\tpushdown(k);\tif(pos &lt;= mid) Change(k &lt;&lt; 1,l,mid,pos);\telse Change(k &lt;&lt; 1 | 1,mid + 1,r,pos);\tpushup(k);}void build(int k,int l,int r){\ttr[k].Mx = Func(0,-llinf);\ttr[k].x = llinf;tag[k] = 0;\tif(l == r) return;\tint mid = l + r &gt;&gt; 1;\tbuild(k &lt;&lt; 1,l,mid);build(k &lt;&lt; 1 | 1,mid + 1,r);}inline void work(){\tread(n);read(m);\tfor(int i = 1;i &lt;= n;i++) read(L[i]),read(R[i]);\tfor(int i = 1;i &lt;= m;i++) Qu[i].clear();\tfor(int i = 1;i &lt;= n;i++) Qu[R[i]].push_back(i);\tfor(int i = 1;i &lt;= m;i++) read(p[i]),dp[i] = -llinf;\tp[++m] = 0;dp[m] = -llinf;\tbuild(1,0,m);\tdp[0] = 0;\tChange(1,0,m,0);\tfor(int i = 1;i &lt;= m;i++)\t{\t\tdp[i] = tr[1].Mx.b;\t\tChange(1,0,m,i);\t\tfor(auto k : Qu[i])\t\t\tmodify(1,0,m,L[k],R[k],1);\t}\tcout &lt;&lt; dp[m] &lt;&lt; endl;}int main(){\tint T;\tread(T);\twhile(T--) work();\treturn 0;}\r\n","tags":["DS"]},{"title":"CF1854D 题解","url":"/posts/963841555/","content":"非常好题目。其实我之前已经想到了二分环长除以常数次的做法，但因为不会问出整个环而只有一个\r\n\r\n的做法，非常可惜。\r\n\r\n首先题中的序列相当于一个内向基环树森林，最后的答案就是  所在的那个联通块的所有点。\r\n从  出发走  次只会到达一个点，我们可以用 \r\n次询问二分出这个点的编号，下文把这个点记作 。\r\n考虑 \r\n所在的联通块对应的环，如果我们能找到这个环的点集 ，那么，如果一个点属于答案，那么其走\r\n 步一定能到达  中的点，我们可以用  次询问判断。\r\n设环长为 。朴素做法是先问出\r\n\r\n，因为其一定在环上。然后用 \r\n次询问找到 ，进而找到整个环。\r\n因为 \r\n距离询问上界并不多，考虑在环上卡常，即只问出  除以常数个点，这里令这个常数为 。\r\n首先，我们问出所有的 ，将其作为初始的 。\r\n对于剩下的点，如果其在环上，那么只要走  步就一定能走到 \r\n中的点。\r\n 可以二进制分解为 ，那么接下来的做法也就清楚了：\r\n\r\n对于还不在  中的每个点，问其走\r\n 步能否到达  中的点，若是则加入 。\r\n对于还不在  中的每个点，问其走\r\n 步能否到达  中的点，若是则加入 。\r\n\r\n虽然上述过程可能加入一些在 \r\n的连通块中但不在环上的点，但这些点对答案判断是没有影响的。\r\n询问次数分析：第一步会使用 \r\n次询问，对于在环上的点，接下来两步会用  和 \r\n次询问。对于不在环上的点，整个过程会用  次询问。加起来一共是 ，甚至还有 \r\n次询问的空余时间。\r\n但是上文的分析基于我们知道环长 ，否则第一步我们就会问到很多重复的点，导致询问次数超出预期。考虑用剩下\r\n 次询问问出环长 。不过，我们并不需要知道这个 \r\n的精确值，只需知道一个估计值。那考虑使用 BSGS 的思想。我们先问出点集\r\n，然后询问  走\r\n 步能否到达  中的点，如果是，就将  作为环长的近似值，这样误差是  的，询问次数上界是 ，不超过 ，满足题目限制。\r\n再补充作者原来想到的做法：设定阈值  ，问出环上长度为  的一小段，然后判断答案时，如果一个点在\r\n 的联通块中，那么其走  次一定能到达这一段中的点，枚举这个  即可，询问次数是 ，取 ，即可得到前文提到的  复杂度。虽然 ，但因为带了个  的常数所以无法通过。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e2 + 5;typedef vector&lt;int&gt; vint;int n;void Reduce(vector&lt;int&gt; &amp;S) { \tsort(S.begin(),S.end());\tS.erase(unique(S.begin(),S.end()),S.end());}bool Ask(int u,int k,const vector&lt;int&gt; &amp;S){\tprintf(\"? %d %d %d \",u,k,(int)S.size());\tfor(auto i : S) printf(\"%d \",i);\tprintf(\"\\n\");\tfflush(stdout);\tint res;\tcin &gt;&gt; res;\treturn res;}bool Ask(int u,int k,int l,int r){\tvector&lt;int&gt; S;\tfor(int i = l;i &lt;= r;i++) S.push_back(i);\treturn Ask(u,k,S);}inline int Getnxt(int u,int k){\tif(k == 0) return u;\tint lef = 1,rig = n;\twhile(lef &lt; rig)\t{\t\tint mid = lef + rig &gt;&gt; 1;\t\tif(Ask(u,k,1,mid)) rig = mid;\t\telse lef = mid + 1;\t}\treturn lef;}inline int GetLen(int st){\tvector&lt;int&gt; st8;\tfor(int i = 0;i &lt;= 7;i++)\t\tst8.push_back(Getnxt(st,i));\tReduce(st8);\tfor(int i = 1;i * 8 &lt;= n;i++)\t\tif(Ask(st,i * 8,st8)) return i * 8;\treturn n;}vector&lt;int&gt; C;bool inc[N];void addc(int x) { if(inc[x]) return;inc[x] = true;C.push_back(x);}int main(){\tcin &gt;&gt; n;\tint st = Getnxt(1,n + 1);\tint len = GetLen(st);\tfor(int i = 0;i * 4 &lt;= len + 4;i++)\t\taddc(Getnxt(st,i * 4));\tfor(int i = 1;i &lt;= n;i++)\t\tif(!inc[i] &amp;&amp; Ask(i,2,C)) addc(i);\tfor(int i = 1;i &lt;= n;i++)\t\tif(!inc[i] &amp;&amp; Ask(i,1,C)) addc(i);\tvector&lt;int&gt; Ans;\tfor(int i = 1;i &lt;= n;i++)\t\tif(inc[i]) Ans.push_back(i);\t\telse if(Ask(i,n + 1,C)) Ans.push_back(i);\tprintf(\"! %d \",(int)Ans.size());\tfor(auto i : Ans) printf(\"%d \",i);\tprintf(\"\\n\");\tfflush(stdout);\treturn 0;}\r\n","tags":["constructive algorithm"]},{"title":"JOISC 2023 题解","url":"/posts/1870241081/","content":"感觉比 22 年出得阳间一些，D4T1 (通信题) 和 D4T2 (最小内向森林)\r\n不会做，没有这两题的题解。\r\n有些好题会尽量写得详细。\r\n\r\nD1T1 两种货币\r\n注意到原图是棵树，那么从  到\r\n\r\n的路径只有一条，用主席树+二分处理路径信息即可。\r\nSubmission\r\nD1T2 JOI 国的节日 2\r\n一道较难的好题。\r\n首先明确：\r\n\r\n最优策略是按 \r\n排序之后贪心选。\r\n最后算答案时，用总数减去 fake 解等于最优解的方案数。\r\n\r\n这种将区间作为计数对象的 DP ，一般会尝试设  表示 DP 到第  个位置，前  个位置一共有 \r\n个还未闭合的左端点作为状态。下文把这些左端点叫做“接口”。\r\n在这题，我们可以变通一下：设  ，表示 DP 到 第  个位置，设在 \r\n之前，最靠右的被选入最优解的区间的右端点 为 ，在  以前有 \r\n个接口（下文称其为“无用接口”，因为它们不会影响最优解），在  以后有  个接口（下文称其为“有用接口”）。 分别表示：\r\n\r\n：当前 fake\r\n解没有比最优解少一个区间，但在 fake\r\n策略下无可用接口（即不存在一个接口使得  连向该接口后 fake 解变大）。\r\n： 当前 fake\r\n解没有比最优解少一个区间，且在 fake 策略下有可用接口。\r\n：当前 fake\r\n解比最优解少一个区间，且在 fake 策略下有可用接口。\r\n\r\n我们没有记录 fake\r\n比最优少且无可用接口的情况，因为这种情况不可能转移回 fake\r\n等于最优的情况。\r\n需要指出的是，fake 只可能有 \r\n个可用接口，因为如果有的话，必须是 fake\r\n解最靠右的那个区间右边最靠左最左的接口，要不然与 fake\r\n的求解方式相矛盾。\r\n转移分类讨论，即可做到 。\r\n考虑优化。发现 \r\n这一维的存在根本不会影响最优解与 fake\r\n解的情况，只是在转移的时候贡献了一个系数。\r\n所以考虑状态中只记录 ，如果某次转移产生了新的\r\n 个无用接口，就直接在后面钦定\r\n 个右端点拼上去，转移到 ，系数是 。\r\n时间复杂度 ，空间需要滚动数组。因为 ，实现时要卡一下  的上下界。\r\n附一张图帮助理解状态： \r\n图中，红线代表 fake\r\n解中最靠右的区间，绿线代表最优解中最靠右的区间，紫色代表  这一维所记录的接口，黄色代表 fake\r\n策略的可用接口，黑色的竖线代表当前 DP 到的位置 。\r\n图左侧是 fake 比最优解少 \r\n的情况，右侧是 fake 解与最优解相等的情况。右侧的黄色接口也被算入  这一维中。\r\n理解状态之后，相信转移分讨起来不是很困难。\r\nSubmission\r\nD1T3 护照\r\n考虑如果只要到达 \r\n的所有国家怎么做，因为每次可达的点都是一段区间，我们只需能到达  号点即可。问题变为由  向  中所有点连边，求  到  的最短路。线段树优化建图即可。\r\n回到原问题，我们可以求出  到\r\n 和  到  的最短路，然后令 。这么做有一个问题就是我们会重复计算一些区间，也就是这两条最短路径可能在一开始出现重复部分。\r\n对于边  ，显然有 ，那么我们如果发现\r\n 的，就用  来更新 。如此往复，这样就可以保证  的正确性。\r\n如何实现这个操作呢？我们把所有 \r\n都丢进一个堆里，每次取出最小的进行松弛即可。这类似一个多源最短路的过程。\r\nSubmission\r\nD2T1 传送带\r\n考虑链怎么做。每隔三个点放一个点（这样任意两个产品就不会走到一起了），然后看最后这个点的产品走到哪。每次把已经知道的边的方向调整一下，使其不影响我们对未知边的询问即可。\r\n树的思路也差不多。考虑把点按照 \r\n分类，取出点数最多的那一类，每个点放一个产品。这样一次询问之后，放了一个产品的点最少可以确定一条邻边。如果一个点的所有邻边都被确定，我们就将其删去。选择类的时候选出未被删去的点数最多的那一类即可。\r\n每次询问都能至少确定  的边，询问次数上界为 。\r\nSubmission\r\nD2T2 议会\r\n对于一个人 \r\n，如果选他当议长，那么选副议长 \r\n的时候，只有那些原来票数就等于  ，且  投了票的议案会从通过变成不通过。那么设\r\n\r\n没投票的议案集合为 。选  做议长时，票数等于  的议案集合为\r\n。去掉一些可以快速计算的部分之后，我们只需对每个\r\n 算出  即可。\r\n显然上式等价于 。忽略  的限制，只需先做一遍超集和，再做一遍子集和即可。现在要 ，我们只需在统计子集信息时，记录答案最大值、次大值、以及编号与最大值不同的集合中最大的大小即可。\r\nSubmission\r\nD2T3 水羊羹 2\r\n首先有一个暴力 DP\r\n的思路，但是这个状态一点也不优美，看上去很难以拓展到原问题。\r\n先发现一个性质：小段长度一定为 。否则可以调整使得不劣。\r\n下文把将一个数作为一个小段称作“选这个数”。\r\n假如我们现在钦定选 ，那下一个选的位置显然要在满足条件的情况下尽量靠前，设其为\r\n。\r\n设  表示最大的  满足  ，，即 \r\n和  可以同时选。\r\n那么  就是最小的满足  的  （注意我们这里没写 ，因为如果 ，我们可以把  调整到  的位置，显然也是不劣的，所以  就能取得更小）。\r\n那么我们选小段的过程，就是从 \r\n开始向后跳跃， 的过程。\r\n如果不带修的话，可以用个倍增维护跳跃的步数。\r\n如果带修的话，我们需要一个观察：如果  存在，。\r\n实际上你考虑 \r\n递增的情况就能很容易发现这个性质。\r\n那么单点修改  就只会改变至多\r\n 个 ，且单步跳跃长度也不超过 。\r\n于是可以写一棵线段树维护跳跃。每个区间记录前 \r\n个点在区间内最远跳到的位置和步数即可。\r\n时间复杂度 。\r\nSubmission\r\nD3T1 合唱\r\n首先，我们只关注一个序列能够形成的最少的曲目数，因为一个大曲目可以被拆成若干个小曲目。\r\n经过手玩可以发现，不管曲目如何安排，从左往右第  个 A 一定配上第  个 B。\r\n进一步地说，如果我们要让第  个 A 唱一首歌，那么第  个 B 就要移到这些 A 的后面，设  表示第  个 A 前面有多少个 B，那么对于  ，其就对代价有  的 贡献。\r\n同时可以发现不同曲目之间的代价没有影响，因为一个曲目的移动不会影响后面曲目的\r\n。\r\n那么设  表示前  个 A 唱了  首歌的最小代价，就有 。\r\n设  表示  的最大  ，并将  对  取 。设后面这个  为 。设  的前缀和为  。那么有 。\r\n证明 \r\n函数满足四边形不等式是简单的，拆开之后发现除了  的项都可以消掉。根据 Itst\r\n的博客，可以说明答案关于歌曲数目存在凸性。\r\n那就可以 wqs 二分解决曲目个数的限制，内层 DP 形如  （  是二分的斜率）。斜率优化 DP\r\n即可。\r\n时间复杂度 。\r\n好题啊。\r\nD3T2 曲奇\r\n","tags":["板刷记录"]},{"title":"ARC128F 题解","url":"/posts/1498597388/","content":"非常好题目，不会第一步。\r\n\r\n令 。\r\n考虑  固定的时候怎么做。\r\n把所有数按照 \r\n从大到小排成一排。此时贪心选最大的  肯定是错的，因为如果第二大的  马上就要被 Bot 吃掉，而最大的 \r\n并不急着被吃，我们先选第二大的肯定比先选最大的优。\r\n不妨换个角度考虑，对于 A 选的一个位置集合 ，其合法当且仅当 ，因为在其前面，我们至少要选  个位置。\r\n那么贪心策略就容易得出了。维护一个优先队列，按 \r\n从大到小，每次把两个数加入优先队列，然后 A\r\n选出优先队列中最大的那个数并弹出就是答案。\r\n观察上述过程，发现其只取决于 \r\n的相对大小关系，所以可以设 \r\n表示第 \r\n大的数在多少种方案中被选择，最后答案就是 。\r\n但”第 \r\n大的数“还是难以考虑，不妨考虑“前 \r\n大的数”，故设  表示前  大的数被选择次数之和。然后，我们把”前\r\n 大的数“视为 ，其余视为 。问题变成计数所有的  序列中，一共 pop 了多少个 。注意，我们在这里认为  和  ， 和  之间没有区别，最后将方案乘上  即可。\r\n考虑计算 ，设第  轮插入时给优先队列提供了  个 ，显然 ，且 。设 \r\n表示当前优先队列中一共有几个 \r\n。在经过第  轮插入后，。我们设 ，并将 \r\n看成二维平面上的点。那么一轮插入就等价于向右走一步，并向上走  步，且在  时有  的系数 （因为 \r\n时原排列有两种填数的方案）。如果走到了  轴以下，就强行扳回  轴。如下图： \r\n其中红边表示扳回 \r\n轴的步数。一次扳回等价于我们在优先队列中 pop 了一个 。所以用  减去红边个数就得到了 pop  的个数。\r\n这种不断对  chkmax\r\n有一个转化：我们不妨允许路径走到 \r\n轴一下，此时路径会停在 ，同时原先 chkmax\r\n的位置就等于现在纵坐标的前缀最小值位置，如下图： \r\n因为 \r\n，所以前缀最小值每次变少时都只会减少 。也就是说，一条路径中的红边个数，就是最低点纵坐标的相反数。\r\n设 ，显然最低点纵坐标在  之间取。枚举 ，我们要计算路径最低点纵坐标\r\n\r\n的方案数。差分，变为路径不越过直线  的方案数。\r\n引理 ：从  走到 \r\n，且每一步向右上/向右/向右下的方案分别为 ，那么总方案数为 。\r\n证明：方案数等于 \r\n那么，路径不越过直线 \r\n的方案数，可以运用经典的折线法计算。我们把限制变为”不经过 “，那么对于每一条经过  的路径，我们把该条路径与  的第一个交点前面的部分，沿\r\n 翻折，它就映射到了一条从\r\n 开始，\r\n结束的一条任意路径。容易证明这个映射是双射。那么不合法路径方案数就是\r\n\r\n所以，路径纵坐标最小值 \r\n的方案数就是 。\r\n所以最小值  的方案数就是\r\n。\r\n那么我们就可以列出 \r\n的计算式了：  这个 \r\n中的组合数上指标是固定的，预处理之后容易做到  计算。\r\n那么最后答案就是  了！\r\n时间复杂度 。不可多得的好题。\r\nconst int N = 1e6 + 5,P = 998244353;inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}int n,a[N];int fac[N],ifac[N];int bs[N];inline void init(int n){\tfac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tifac[1] = 1;\tfor(int i = 2;i &lt;= n;i++) ifac[i] = 1ll * ifac[P % i] * (P - P / i) % P;\tifac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) ifac[i] = 1ll * ifac[i - 1] * ifac[i] % P;}inline int C(int n,int m) { if(n &lt; 0 || m &lt; 0 || n &lt; m) return 0;return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;}int g[N];int main(){\tread(n);\tfor(int i = 1;i &lt;= n;i++) read(a[i]);\tsort(a + 1,a + n + 1,greater&lt;int&gt;());\tn /= 2;\tinit(n + n);\tfor(int i = 2 * n;i &gt;= 0;i--)\t\tbs[i] = bs[i + 2],Plus(bs[i],C(n + n,i));\tfor(int m = 0;m &lt;= n + n;m++)\t{\t\tint p = max(0,n - m);\t\tg[m] = 1ll * (n - p) * C(n + n,m + p + p) % P;\t\tPlus(g[m],P - (m + p + p + 2 &lt;= n + n ? bs[m + p + p + 2] : 0));\t\tg[m] = 1ll * g[m] * fac[m] % P * fac[n + n - m] % P;\t}\tint ans = 0;\tfor(int i = 1;i &lt;= n + n;i++)\t\tPlus(ans,1ll * a[i] * (g[i] - g[i - 1] + P) % P);\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting"]},{"title":"NOI2023 游记","url":"/posts/3558578486/","content":"省流：旅游很开心，博主 Cu 了，但是高一。文学水平退化。\r\n\r\nDay -28\r\n开始为期一个月的守家训练。守家的起因是感觉联考模拟赛对自己提升不大。所以干脆在本校机房探索自己的训练方式。\r\n也是因为这一层原因，博主对于这次 NOI\r\n的成绩没有那么看重，更多将其看成一次试验，继而通过试验结果调整自己的训练方法。\r\n这一个月主要的训练途径就是 VP + 板刷 CF，顺便穿插计数和图论的 CF\r\n专项训练。虽然说是专项训练，其实一个专题就只有五六道题。图论训得最多，专门盯着\r\ngraph 的 tag 做了十余道题。\r\n后来的结果大家都知道，今年 noi 只有 D2T1 沾了点图论的边。\r\n不过这一个月的训练仍然带给了我经验、教训和提升。有了这一个月的训练作为数据和样板，我可以更好地调整接下来一年的训练方法。无论题目如何变幻，我都相信自己收获了一些不会褪色的进步。\r\nDay -?\r\n提前到达成都七中，打了四场模拟赛，有两场不会 T1\r\n。考完当晚非常郁闷，后来也就没当回事了。\r\n期间跟 lcm 交流了一下，确信考前做几道 JOI/USACO\r\n题暖暖机是个正确的选择。比起 CF 而言，JOI/USACO 的风格其实更贴近\r\nCNOI。\r\n提前准备好了乒乓球拍，这次 NOI 的面基策略就是：乒乓球外交。\r\nDay -6 至 Day -1\r\n拿胸牌和背包，并获悉自己跟高二学长一个寝室，而且全 HN 的人都在 4\r\n楼那一个拐角附近！这下半夜茶话会了。\r\n当天下午就在病友群问有无人打乒乓球。成功找到一个内蒙小哥。\r\n后来学弟 xh 和同届群友 xsi 也来打球。还面到了 huashanlunjian\r\n，此人抽球很猛。\r\nday1\r\n考完之后去打乒乓球，被学长薄纱。其实在休息日打乒乓球是个很好的选择，赢了心情好，输了\r\nrp 涨，桌上足球同理。\r\n说到桌上足球，那是在 cdqz\r\n男生宿舍楼一楼的东西，我两天玩了四把，把中锋转得跟烧烤架一般。管他赢不赢，转就完了！\r\n关于 NOI ，管它赢不赢，打就完了！\r\nDay 0\r\n笔试 99，以为复试丢密码条自行解决，没有绷住。\r\nDay 1\r\n进考场先读三道题。 T1 非常可做，但是看上去细节很多，先看 T2，注意到\r\n ,  ,  , 三个方向。看 T3 ，一眼没啥思路。然后开始写 T1\r\n扫描线，写完后一直在调样例 2。样例 2\r\n还是很强的，甚至连两条斜线重叠的情况都有。当时先写个对拍，一边拍一边调，10\r\n: 00 过了样例和拍。然后看 T2，花了半个小时写了 ，然后就在想 。当时有两种方向：在树上从小到大插点和依据树形结构\r\nDP。我当时觉得前者过于反直觉，难以思考，就直接看后者，想了 1h\r\n，期间去洗了两次脸，强行让自己冷静下来，才想到一个关于树大小的\r\nDP，期间也想过转换方向，但又放弃了，然后一直写 + 调到\r\n12:00，一直没过样例。\r\n到了 12:00 开始看\r\nT3，然后猛然发现原条件等价于没有非树边覆盖根（即没有横叉边），然后就好做了，会了一个容斥，但是当时没有看到\r\n 有专门给  的分，直接写了个 。然后看链，原先以为只有在钦定的点集最左边之前和最右边之后的边才会有贡献，写完发现完全不对，调到\r\n12:40 才意识到问题，然而此时只能够写  的链了。暴力离场。\r\n出来之后 ，T2\r\n没写前 10 分暴力、思考方向不对和没能早点发现 T3\r\n较好拿分都给最后的结果埋下了伏笔。后来我在成都地铁站恍然大悟 T2 的 70\r\n分，其实只要在“从小到大插点”的方向再深入一些就能想出来。之前在省选 D2T2\r\n也出过类似的选错方向的问题，当时决定的改进策略是把所有想法写在纸上提醒自己。虽然这次确实写在了纸上，但是考场上在意识到不对劲时，依然没有换方向的决心。这个决心的形成不仅仅需要自身心性的提升，也需要在比赛前期尽可能高效地拿到暴力分，这样换方向就不会有顾虑。\r\nDay 1.5\r\n乒乓球。Dead cell。初二打 Dead cell\r\n时卡时钟室了。现在来打就一遍过了。不清楚 Dead cell 对 rp\r\n产生的影响，但它起到了明显的解压作用。推荐 Dead cell\r\n，点个近战杀敌减少技能 CD 之后砍人是真的爽。\r\n如何度过休息日还是有学问的。毕竟 Day1\r\n考完之后的心态会在休息日被放大，如果休息日找不到事情做的话，很可能陷入消极情绪中，导致\r\nDay2 爆炸（这一部分因人而异，主要取决于 Day1\r\n成绩）。我觉得，跟熟人朋友打打球，或者打打隔膜，都是不错的选择。\r\nDay 2\r\n吸取 Day1 教训，Day2\r\n决定打稳一点，只要不出策略失误，考多少分已经是其次了。\r\n开场先看 T1，看完 Sub 之后发现 70 很容易拿，但 100\r\n暂时没想法，可能是分治之类的。记在纸上，然后看 T2，因为有 D2T2\r\n是区分度题的意识，看到 36 分暴力可拿之后就将性质 A,B 重点标记。然后看\r\nT3，略想一会儿会了 \r\n（其实当时再想一会儿应该就会 ，但是我认为这题的重要程度不如前两题，且 T1\r\n还没过，所以就没管了）。\r\n先写了 T1 40 和 T2 36 和 T3 20 ，10:00 写完了 T2 性质 A，10:30\r\n写完了后两题的拍，然后开始想\r\nT1，一开始想的边分，想了好久觉得难以处理，把所有能观察到的性质都写出来，再经过约\r\n20 min 的神秘过程后发现，只要处理出每个点到自己后代的最短路，就可以在\r\n 的  处统计  的贡献，此时已经 11:30\r\n了，写完之后到 12:00 多，12:20 过了样例\r\n1，然后瞪了一会儿，调不出来，于是 5\r\n分钟冲了个对拍（得益于之前写了暴力）。紧张地调到了 12:50\r\n，发现算贡献时有一项漏乘了，这才过了所有数据。\r\n调完之后整个人瘫在凳子上，想着随便了， 应该不会寄得很惨。\r\n事实证明，如果真的是 \r\n的话，我至少还有个 Ag，但是 T1 因为写法问题数组越界，挂了 25 分，T3\r\n状压写挂，挂了  分，后来我才发现\r\n,我把 T3 数据分治后的代码拿去对拍了，相当于是爆搜和爆搜在对拍（\r\n赛后在宿舍楼逛了  分钟，会了\r\nD2T2 的单 log 做法 ，无语住了。\r\nDay2 的缺陷主要在于 D2T1 想太久，超过了平均时长，导致 D2T2 连性质 B\r\n都没时间思考。这次考试让我更为深刻地认识到：为何在考场上，我们难以发挥出平时做题时的水平。考试的限时，心态的波动，考场环境的影响，以及题目设计的风格，都会左右我们的心态，折磨我们的意志。\r\n不过，在经历过 NOI2022，NOIP2022，联合省选2023，NOI2023\r\n之后，我觉得我的心理素质已经得到了较大提升。毕竟，已经见过了出题组多种多样的创人方法了。\r\n这次的题目出得很好拿分，所以更多考察选手如何把这 5\r\n个小时更高效地利用起来。这么说起来，倒是有 speedforce 那味了。\r\n加训！\r\n","tags":["游记"]},{"title":"CF1721F 题解","url":"/posts/1088791454/","content":"这题考察终态的思想，有启发意义和教育性。\r\n\r\n考虑最后删到最大匹配为 \r\n的时候是什么状态，此时没有任何一对点之间有边，即图是个独立集。这就提示我们向独立集转化问题。\r\n注意到最大独立集 +\r\n最大匹配在每个时刻都等于总点数，所以一次操作后，点数 ，最大匹配 ，所以最大独立集不变。\r\n所以，只要我们每次都删一个非最大独立集的点，就可以保证最大匹配恰好减少\r\n 了 ！\r\n那么匹配边如何维护呢？\r\n设最大独立集为 ，那么  与  之间一定有完美匹配，因为如果有一个\r\n\r\n中的点无法匹配，那么其肯定可以被纳入独立集中，与最大性矛盾。所以我们在最初求出\r\n 和  中的最大匹配，然后每次删点的\r\n时候就把对应的匹配边删掉即可。\r\n事实上，我们求最大独立集的时候会跑出一个最大匹配，而这个最大匹配恰恰就是\r\n 与 \r\n之间的最大匹配，因为每条匹配边至少有一个端点不属于 ，而匹配大小等于 \r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4e5 + 5,M = 2e6 + 5;int n1,n2,m,tot,Q;int fir[N],nxt[M],to[M],w[M],ect = 1;vector&lt;int&gt; G[N];inline void addedge(int u1,int v1,int w1){\tnxt[++ect] = fir[u1];fir[u1] = ect;to[ect] = v1;w[ect] = w1;}inline void ins(int u1,int v1,int w1) { addedge(u1,v1,w1);addedge(v1,u1,0);}int dep[N],cur[N];inline bool bfs(int S,int T){\tfor(int i = 1;i &lt;= tot;i++) dep[i] = 1e9,cur[i] = fir[i];\tqueue&lt;int&gt; Q;Q.push(S);dep[S] = 0;\twhile(!Q.empty())\t{\t\tint x = Q.front();Q.pop();\t\tfor(int i = fir[x],y;y = to[i],i;i = nxt[i])\t\t\tif(w[i] &amp;&amp; dep[y] &gt; dep[x] + 1)\t\t\t{\t\t\t\tdep[y] = dep[x] + 1;\t\t\t\tQ.push(y);\t\t\t}\t}\treturn dep[T] &lt; 1e9;}int dfs(int u,int t,int limit){\tif(u == t || !limit) return limit;\tint flow = 0,f;\tfor(int i = cur[u],v;v = to[i],i;i = nxt[i])\t{\t\tcur[u] = i;\t\tif((dep[v] == dep[u] + 1) &amp;&amp; w[i] &amp;&amp; (f = dfs(v,t,min(limit,w[i]))))\t\t{\t\t\tflow += f;\t\t\tlimit -= f;\t\t\tw[i] -= f;\t\t\tw[i ^ 1] += f;\t\t\tif(!limit) break;\t\t}\t}\treturn flow;}inline int dinic(int S,int T){\tint res = 0;\twhile(bfs(S,T)) res += dfs(S,T,2e9);\treturn res;}int vx[N],vy[N];int ml[N],mr[N]; // 下标是左、右部点bool inset[N];void dfs0(int x){\tif(vx[x]) return;\tvx[x] = true;\tfor(auto y : G[x])\t\tif(mr[y] &amp;&amp; !vy[y] &amp;&amp; mr[y] != x)\t\t{\t\t\tvy[y] = true;\t\t\tdfs0(mr[y]);\t\t}}void GetSet(){\tfor(int i = 1;i &lt;= n1;i++)\t\tfor(int e = fir[i],v;v = to[e],e;e = nxt[e])\t\t\tif(v &gt; n1 &amp;&amp; v &lt;= n1 + n2 &amp;&amp; w[e] == 0)\t\t\t\tmr[v - n1] = i;\tfor(int i = 1;i &lt;= n2;i++)\t\tml[mr[i]] = i;\tfor(int i = 1;i &lt;= n1;i++)\t\tif(!ml[i]) dfs0(i);\tfor(int i = 1;i &lt;= n1;i++) if(vx[i]) inset[i] = true;\tfor(int i = 1;i &lt;= n2;i++) if(!vy[i]) inset[i + n1] = true;\t// printf(\"inset:\");for(int i = 1;i &lt;= n1 + n2;i++) printf(\"%d \",inset[i]);printf(\"\\n\");}\tint nd[N],cnt;long long sum[N];map&lt;pair&lt;int,int&gt;,int&gt; mp;int main(){\tcin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m &gt;&gt; Q;\ttot = n1 + n2 + 2;\tfor(int i = 1;i &lt;= m;i++)\t{\t\tint u,v;\t\tcin &gt;&gt; u &gt;&gt; v;\t\tins(u,v + n1,1);\t\tG[u].push_back(v);\t\tmp[make_pair(u,v)] = i;\t}\tint S = n1 + n2 + 1,T = n1 + n2 + 2;\tfor(int i = 1;i &lt;= n1;i++) ins(S,i,1);\tfor(int i = 1;i &lt;= n2;i++) ins(i + n1,T,1);\tdinic(S,T);\tGetSet();\t// printf(\"ml: \");for(int i = 1;i &lt;= n1;i++) printf(\"%d \",ml[i]);printf(\"\\n\");\t// printf(\"mr: \");for(int i = 1;i &lt;= n2;i++) printf(\"%d \",mr[i]);printf(\"\\n\");\tfor(int i = 1;i &lt;= n1 + n2;i++) if(!inset[i]) nd[++cnt] = i;\tfor(int i = 1;i &lt;= cnt;i++)\t{\t\tint u = nd[i],v = u &lt;= n1 ? ml[u] : mr[u - n1];\t\tassert(v);\t\t// if(u &lt;= n1) printf(\"mth:%d-%d\\n\",u,v);\t\t// else printf(\"mth:%d-%d\\n\",v,u - n1);\t\tsum[i] = sum[i - 1] + mp[u &lt;= n1 ? make_pair(u,v) : make_pair(v,u - n1)];\t}\tfor(int _ = 1;_ &lt;= Q;_++)\t{\t\tint op;\t\tcin &gt;&gt; op;\t\tif(op == 1)\t\t{\t\t\tprintf(\"1\\n\");\t\t\tif(nd[cnt] &gt; n1) printf(\"%d\\n\",-(nd[cnt] - n1));\t\t\telse printf(\"%d\\n\",nd[cnt]);\t\t\tprintf(\"%lld\\n\",sum[--cnt]);\t\t}\t\telse\t\t{\t\t\tprintf(\"%d\\n\",cnt);\t\t\tfor(int i = 1;i &lt;= cnt;i++) \t\t\t{\t\t\t\tint u = nd[i],v = u &lt;= n1 ? ml[u] : mr[u - n1];\t\t\t\tassert(v);\t\t\t\tprintf(\"%d \",mp[u &lt;= n1 ? make_pair(u,v) : make_pair(v,u - n1)]);\t\t\t}\t\t\tprintf(\"\\n\");\t\t}\t\tfflush(stdout);\t}\treturn 0;}\r\n","tags":["graph theory","graph matching"]},{"title":"CF1648F 题解","url":"/posts/550943298/","content":"一道 Educational 的题，做完后学到了很多！\r\n\r\n显然，如果我们割去一条边的话，我们显然会割一座桥。\r\n所以就有一个思路是把边双缩一下，然后考虑割掉两座桥的贡献。\r\n但是因为这里是割两条边，所以其实可以割两条边双内的边，这不好处理。\r\n所以这个思路是错误的，边双内的问题和原图的问题本质相同，不好处理。\r\n那我们换个思路，既然这是个连通性问题，考虑一个 DFS 树。\r\n对于每条树边 ，设  对关键点中，在树上的路径经过  的点对数为 ，设在  条非树边中，覆盖树边  的非树边集合为 （\"覆盖\"是指端点在树上的路径经过\r\n\r\n）。在实现时，可以对每个非树边赋一个 \r\n的随机权值，树边权值为覆盖其的非树边权值的异或和。这样就可以比较  和  的关系了。\r\n考虑答案的几种情况：\r\n\r\n割两条割边。因为割边肯定是树边，答案为 ，满足 \r\n割一条树边，同时割掉覆盖它的所有非树边，这种情况需要 ，贡献为 。\r\n割两条树边，这是本题最难的情况。这两条树边需要满足 。也就是说，在割了这两条边之后，原树会分成三个部分。我们要求没有非树边连接中间的部分与两边的部分。此时的贡献为\r\n“恰好 跨过 \r\n中一条边的关键点路径数”。\r\n\r\n前两种情况较为平凡，考虑第三种。\r\n设  表示同时经过  和  的路径数，那么贡献就是 。\r\n发掘  和  的性质。\r\n\r\n因为 DFS 树上的非树边都是祖先连向后代的边，所以要使得 ， 和 \r\n之间也必然是祖先-后代的关系。\r\n另一方面，一条链上的 \r\n不会出现类似  的情况，即每种\r\n\r\n的出现区间包含而不交叉，这个也是可以手画来理解的。\r\n\r\n性质 \r\n对另一个做法会有所帮助，但我们这里不讲。\r\n考虑基于性质 \r\n，我们如何快速算出 \r\n。\r\n因为 \r\n是祖先-后代关系，我们可以将关键点路径  拆成两条不相干的路径 ，并在对应的  点和  点记录这两条路径。\r\n注意到在固定  的时候，  和 \r\n具有相同的含义，都可以确定一条边，所以我们对每个点  建立一棵以 \r\n为下标的线段树。处理到一个点时，我们取出这个点上记录的路径 ，并在  点的线段树上，将  对应的值 。做完后，再把子树内的线段树合并即可。\r\n查询的时候，我们只需查询 \r\n对应的线段树（实际上是 \r\n的端点中深度较深的那个对应的线段树）中， 的区间和即可 （ 指  端点中深度较浅的那个）。\r\n但我们还是要统计很多对 \r\n的贡献。\r\n注意到在固定  的时候， 是具有决策单调性的。\r\n即对于 ，它们对应的  一定有 。\r\n这个可以通过四边形不等式，交叉优于包含来证明。\r\n所以在处理一种 \r\n时，把属于那种颜色的边全部取出来，跑一个决策单调性分治即可。\r\n时间复杂度 ，空间卡得很紧。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5,M = N &lt;&lt; 1;typedef unsigned long long ull;typedef tuple&lt;int,int,int&gt; Ans_t;typedef pair&lt;int,int&gt; pii;#define FI first#define SE second#define mkp make_pair#define mkt make_tupletemplate&lt;typename T&gt; inline void ckmax(T &amp;x,const T &amp;y) { if(x &lt; y) x = y;}namespace FastIO {\t#define iL (1 &lt;&lt; 20)\tchar ibuf[iL],*iS = ibuf + iL,*iT = ibuf + iL;\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf,1,iL,stdin),iS == iT ? EOF : *iS++) : *iS++)\ttemplate&lt;typename T&gt;\tinline void read(T &amp;a)\t{\t\tchar ch;int sign = 0;\t\tfor(ch = gc();!isdigit(ch);ch = gc())\t\t\tif(ch == '-') sign = 1;\t\ta = ch &amp; 15;\t\tfor(ch = gc();isdigit(ch);ch = gc())\t\t\ta = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch &amp; 15);\t\tif(sign) a = -a;\t}\tchar Out[iL],*iter = Out;\t#define flush() fwrite(Out,1,iter - Out,stdout),iter = Out\ttemplate&lt;typename T&gt;\tinline void write(T x,char end = '\\n')\t{\t\tint c[40],l = 0;if(x &lt; 0) *iter++ = '-',x = -x;\t\tdo c[++l] = x % 10,x /= 10; while(x);\t\twhile(l) *iter++ = c[l--] + '0';\t\t*iter++ = end;flush();\t}\t#undef iL \t#undef gc\t#undef flush}using namespace FastIO;int n,m,Q,mxdep;int U[N],V[N];int fir[N],nxt[M],to[M],Id[M],ect = 1;inline void addedge(int u1,int v1,int id1){\tnxt[++ect] = fir[u1];fir[u1] = ect;to[ect] = v1;Id[ect] = id1;}// int dfs_seq[N];vector&lt;int&gt; G[N];int dep[N],fa[N];bool intree[N];int fa_id[N];bool vis[N];void dfs0(int x,int from){\tvis[x] = true;\tfor(int i = fir[x],y;y = to[i],i;i = nxt[i])\t{\t\tif((from ^ 1) == i) continue;\t\tif(!vis[y]) {\t\t\tdep[y] = dep[x] + 1;fa[y] = x;\t\t\tintree[Id[i]] = true;\t\t\tfa_id[y] = Id[i];\t\t\tdfs0(y,i);\t\t\tG[x].push_back(y);\t\t}\t}}mt19937_64 Rnd(1919810);ull hsh[N];int cov[N];// void dfssum()// {// \tfor(int i = n;i &gt;= 1;i--)// \t{// \t\tint u = dfs_seq[i];// \t\tif(u == 1) continue;// \t\tcov[fa[u]] += cov[u];// \t\thsh[fa[u]] ^= hsh[u];// \t}// }void dfssum(int x){\tfor(auto y : G[x])\t\tdfssum(y),hsh[x] ^= hsh[y],cov[x] += cov[y];}const int Sz = N * 60;int lc[Sz],rc[Sz],sum[Sz],rt[N],tot = 0;inline int NewNode() { int k = ++tot;sum[k] = lc[k] = rc[k] = 0;return k;}inline void pushup(int x) { sum[x] = sum[lc[x]] + sum[rc[x]];}void modify(int &amp;k,int l,int r,int pos,int v){\tif(!k) k = ++tot;\tsum[k] += v;\tif(l == r) {return;}\tint mid = l + r &gt;&gt; 1;\tif(pos &lt;= mid) modify(lc[k],l,mid,pos,v);\telse modify(rc[k],mid + 1,r,pos,v);}int Qsum(int k,int l,int r,int x,int y){\tif(!k) return 0;\tif(x &lt;= l &amp;&amp; r &lt;= y) return sum[k];\tint mid = l + r &gt;&gt; 1;\tif(y &lt;= mid) return Qsum(lc[k],l,mid,x,y);\telse if(x &gt; mid) return Qsum(rc[k],mid + 1,r,x,y);\telse return Qsum(lc[k],l,mid,x,y) + Qsum(rc[k],mid + 1,r,x,y);}int Merge(int x,int y,int l,int r){\tif(!x || !y) return x + y;\tint nd = NewNode();\tif(l == r) {sum[nd] = sum[x] + sum[y];return nd;}\tint mid = l + r &gt;&gt; 1;\tlc[nd] = Merge(lc[x],lc[y],l,mid);\trc[nd] = Merge(rc[x],rc[y],mid + 1,r);\tsum[nd] = sum[x] + sum[y];\treturn nd;}int sze[N],son[N],top[N];void dfs1(int x){\tsze[x] = 1;\tfor(auto y : G[x])\t{\t\tdfs1(y);\t\tsze[x] += sze[y];\t\tif(sze[y] &gt; sze[son[x]]) son[x] = y;\t}}void dfs2(int x,int topt){\ttop[x] = topt;\tif(son[x]) dfs2(son[x],topt);\tfor(auto y : G[x])\t\tif(y != son[x]) dfs2(y,y);}int lca(int x,int y){\twhile(top[x] != top[y])\t\tdep[top[x]] &gt; dep[top[y]] ? x = fa[top[x]] : y = fa[top[y]];\treturn dep[x] &lt; dep[y] ? x : y;}vector&lt;int&gt; Chg[N];inline int calc(int x,int y) {     // printf(\"calc:%d,%d,%d\\n\",x,y,cov[x] + cov[y] - 2 * Qsum(rt[y],0,n,0,dep[x] - 1));    return cov[x] + cov[y] - 2 * Qsum(rt[y],0,mxdep,0,dep[x] - 1);} // x in anc(y)void dfsMer(int x){    for(auto y : Chg[x])        modify(rt[x],0,mxdep,dep[y],1);    for(auto y : G[x])        dfsMer(y),rt[x] = Merge(rt[x],rt[y],0,mxdep);}Ans_t ans;void divide(vector&lt;int&gt; &amp;v,int l,int r,int ql,int qr){\tif(l &gt; r || ql &gt; qr) return;\tint mid = l + r &gt;&gt; 1,tmp = -1,k = 0;\tfor(int i = ql;i &lt;= min(qr,mid - 1);i++)\t{\t\tint val = calc(v[i],v[mid]);\t\tckmax(ans,mkt(val,fa_id[v[i]],fa_id[v[mid]]));\t\tif(val &gt; tmp) tmp = val,k = i;\t}\tdivide(v,l,mid - 1,ql,k);\tdivide(v,mid + 1,r,k,qr);}void Solve_c(vector&lt;int&gt; v){    // printf(\"v: \");    // for(auto it : v) printf(\"%d \",it);    // printf(\"\\n\");\tsort(v.begin(),v.end(),[&amp;](const int &amp;x,const int &amp;y) { return dep[x] &lt; dep[y];});\tdivide(v,0,v.size() - 1,0,v.size() - 1);}map&lt;ull,vector&lt;int&gt; &gt; cols;void Clr(){\tect = 1;ans = mkt(-1,0,0);\tfor(int i = 1;i &lt;= n;i++)\t{\t\tfir[i] = hsh[i] = cov[i] = dep[i] = fa[i] = fa_id[i] = rt[i] = vis[i] = 0;\t\tG[i].clear();Chg[i].clear();\t\tsze[i] = son[i] = top[i] = 0;\t}\tfor(int i = 1;i &lt;= m;i++)\t\tintree[i] = 0;\tcols.clear();\tfor(int i = 1;i &lt;= tot;i++)\t\tlc[i] = rc[i] = sum[i] = 0;\ttot = 0;mxdep = 0;\t// dfstime = 0;}map&lt;ull,int&gt; hshvals;vector&lt;pii&gt; bri;void Work(){\tread(n);read(m);Clr();\tfor(int i = 1;i &lt;= m;i++)\t\tread(U[i]),read(V[i]),addedge(U[i],V[i],i),addedge(V[i],U[i],i);\tdep[1] = 1;\tdfs0(1,0);\tdfs1(1);\tdfs2(1,1);\thshvals.clear();\tbri.clear();\tfor(int i = 1;i &lt;= n;i++) ckmax(mxdep,dep[i]);\tfor(int i = 1;i &lt;= m;i++) if(!intree[i])\t{\t\tint u = U[i],v = V[i];// \t\tprintf(\"outtree:%d,%d\\n\",u,v);\t\tull val = Rnd();hshvals[val] = i;\t\thsh[u] ^= val;hsh[v] ^= val;\t}\tread(Q);\tfor(int i = 1,u,v;i &lt;= Q;i++)\t{\t\tread(u);read(v);\t\tint lc = lca(u,v);\t\tcov[u]++;cov[v]++;cov[lc] -= 2;\t\tChg[v].push_back(lc);\t\tChg[u].push_back(lc);\t}\tdfssum(1);// \tprintf(\"cov: \");for(int i = 1;i &lt;= n;i++) printf(\"%d \",cov[i]);printf(\"\\n\");\tfor(int i = 2;i &lt;= n;i++)\t\tif(!hsh[i])\t\t\tbri.emplace_back(cov[i],fa_id[i]);\t// for(int i = 1;i &lt;= m;i++)\t// \tif(cut[i]) bri.emplace_back(cov[nd_id[i]],i);\tsort(bri.begin(),bri.end(),greater&lt;pii&gt;());\tif(bri.size() == 1) ckmax(ans,mkt(bri[0].FI,bri[0].SE,bri[0].SE == 1 ? 2 : 1));\telse if(bri.size()) ckmax(ans,mkt(bri[0].FI + bri[1].FI,bri[0].SE,bri[1].SE));//\treturn;\tfor(int i = 1;i &lt;= n;i++)\t\tif(hshvals.find(hsh[i]) != hshvals.end()) \t\t\tckmax(ans,mkt(cov[i],fa_id[i],hshvals[hsh[i]]));\tdfsMer(1);\t// dfsMer();\tfor(int i = 1;i &lt;= n;i++)\t\tif(hsh[i]) cols[hsh[i]].push_back(i);\tfor(auto it : cols)\t\tSolve_c(it.SE);\tif(ans == mkt(-1,0,0))\t\tprintf(\"0\\n%d %d\\n%d %d\\n\",U[1],V[1],U[2],V[2]);\telse\t{\t\tprintf(\"%d\\n\",get&lt;0&gt;(ans));\t\tprintf(\"%d %d\\n\",U[get&lt;1&gt;(ans)],V[get&lt;1&gt;(ans)]);\t\tprintf(\"%d %d\\n\",U[get&lt;2&gt;(ans)],V[get&lt;2&gt;(ans)]);\t}}int main(){\tint T;\tread(T);\twhile(T--) Work();\treturn 0;}\r\n","tags":["graph theory","DS"]},{"title":"NOI2017 蔬菜 题解","url":"/posts/908636711/","content":"题意： https://loj.ac/p/2306\r\n非常好题目，VP 时只会 60，其实再思考一下应该就会 80 了。\r\n\r\n首先，蔬菜变质是个非常难以处理的问题，你一边卖菜还要考虑之后会不会变质，不如将时间倒流，变为从某个时刻开始，每天进货若干单位的蔬菜。这个进货量是和你的销售无关的，所以在每个时刻，你只需选择当前有的，价格最大的\r\n\r\n单位蔬菜卖出即可。用堆维护，每次暴力实现进货过程，即可在  时间内解决单次询问，拿到\r\n 分的高分。\r\n考虑优化做法，发现卖菜的过程和每种菜进货的第一天（也就是\r\n原问题中每种菜的 deadline)\r\n都不是复杂度瓶颈。主要问题是每天要把已经进货的菜的个数加上 ，这很麻烦。\r\n我们发现这个过程其实完全没有必要，因为你买不买菜和进货数量也没有很强的关系，你也只关心当前有没有这种菜。所以你完全可以只用一个优先队列维护当前拥有的菜，再用一个数组维护每种菜当前卖掉的数量，这样每个时刻，堆顶每种菜拥有的数量都是可以计算的。直接做就行。\r\n 分代码部分：\r\nll Brute(int tim){\tll ans = 0;\twhile(!pq.empty()) pq.pop();\tfor(int i = 1;i &lt;= n;i++) usd[i] = 0;\tfor(int i = Lim;i &gt;= 1;i--) //Lim = 100000\t{\t\tfor(auto it : P[i])\t\t\tpq.emplace(a[it] + s[it],it);\t\tif(i &gt; tim) continue;\t\tvector&lt;node&gt; stk;\t\tfor(int now = m;now &amp;&amp; pq.size();)\t\t{\t\t\tnode tmp = pq.top();pq.pop();\t\t\tif(usd[tmp.id] == 0)\t\t\t{\t\t\t\tans += tmp.c;usd[tmp.id]++;now--;\t\t\t\tif(c[tmp.id] &gt; 1) pq.emplace(a[tmp.id],tmp.id);\t\t\t}\t\t\telse\t\t\t{\t\t\t\tint dta = min(now,c[tmp.id] - usd[tmp.id] - (i - 1) * x[tmp.id]);\t\t\t\tans += 1ll * dta * tmp.c;usd[tmp.id] += dta;now -= dta;\t\t\t\tif(usd[tmp.id] &lt; c[tmp.id]) stk.push_back(tmp);\t\t\t}\t\t}\t\twhile(stk.size()) pq.push(stk.back()),stk.pop_back();\t}\treturn ans;}\r\n考虑 \r\n分怎么写，我们需要对每个天数求出答案。发现  和 \r\n之间其实只差了一点：就是我们要少卖  单位菜。那假设我们已经获得了  的解，在求解  时，如果当前卖掉的菜不多于\r\n，就不用管，否则我们需要撤销一道已经卖出去的菜。选择价格最小的菜撤销即可。这其实就是一种反悔贪心。\r\n上文我们没有提到 “第一次卖菜获得  收益”\r\n如何处理，其实这是简单的，在第一次进货时，将 \r\n加入堆中，如果这道菜被卖出去了，就弹出 ，加入 \r\n即可。撤销也是类似的，在这道菜被撤销到只剩一个单位时，将  加入小根堆中即可。\r\n如果从模拟费用流的视角来理解这道题，那最后 \r\n分恰恰相当于一个退流的过程，这再一次说明了模拟费用流和反悔贪心之间的紧密联系。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;namespace FastIO {\t#define iL (1 &lt;&lt; 20)\tchar ibuf[iL],*iS = ibuf + iL,*iT = ibuf + iL;\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf,1,iL,stdin),iS == iT ? EOF : *iS++) : *iS++)\ttemplate&lt;typename T&gt;\tinline void read(T &amp;a)\t{\t\tchar ch;int sign = 0;\t\tfor(ch = gc();!isdigit(ch);ch = gc())\t\t\tif(ch == '-') sign = 1;\t\ta = ch &amp; 15;\t\tfor(ch = gc();isdigit(ch);ch = gc())\t\t\ta = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch &amp; 15);\t\tif(sign) a = -a;\t}\tchar Out[iL],*iter = Out;\t#define flush() fwrite(Out,1,iter - Out,stdout),iter = Out\ttemplate&lt;typename T&gt;\tinline void write(T x,char end = '\\n')\t{\t\tint c[40],l = 0;if(x &lt; 0) *iter++ = '-',x = -x;\t\tdo c[++l] = x % 10,x /= 10; while(x);\t\twhile(l) *iter++ = c[l--] + '0';\t\t*iter++ = end;flush();\t}\t#undef iL \t#undef gc\t#undef flush}using namespace FastIO;const int N = 1e5 + 5,Lim = 1e5;int n,m,Q;int a[N],s[N],c[N],x[N];struct node{\tint c,id; \tnode(){}\tnode(const int _c,const int _id): c(_c),id(_id) {}\tbool operator &lt; (const node &amp;rhs) const { return c &lt; rhs.c;}};priority_queue&lt;node&gt; pq;vector&lt;int&gt; P[N];inline void Prework(){\tread(n);read(m);read(Q);\tfor(int i = 1;i &lt;= n;i++) read(a[i]),read(s[i]),read(c[i]),read(x[i]);\tfor(int i = 1;i &lt;= n;i++)\t{\t\tif(x[i] &gt; 0)\t\t{\t\t\tint tim = (c[i] + x[i] - 1) / x[i];\t\t\tP[min(tim,Lim)].push_back(i);\t\t}\t\telse P[Lim].push_back(i);\t}\t}int usd[N]; // 用掉了多少ll ans[N];ll Brute(int tim){\tll ans = 0;\twhile(!pq.empty()) pq.pop();\tfor(int i = 1;i &lt;= n;i++) usd[i] = 0;\tfor(int i = Lim;i &gt;= 1;i--)\t{\t\tfor(auto it : P[i])\t\t\tpq.emplace(a[it] + s[it],it);\t\tif(i &gt; tim) continue;\t\tvector&lt;node&gt; stk;\t\tfor(int now = m;now &amp;&amp; pq.size();)\t\t{\t\t\tnode tmp = pq.top();pq.pop();\t\t\tif(usd[tmp.id] == 0)\t\t\t{\t\t\t\tans += tmp.c;usd[tmp.id]++;now--;\t\t\t\tif(c[tmp.id] &gt; 1) pq.emplace(a[tmp.id],tmp.id);\t\t\t}\t\t\telse\t\t\t{\t\t\t\tint dta = min(now,c[tmp.id] - usd[tmp.id] - (i - 1) * x[tmp.id]);\t\t\t\tans += 1ll * dta * tmp.c;usd[tmp.id] += dta;now -= dta;\t\t\t\tif(usd[tmp.id] &lt; c[tmp.id]) stk.push_back(tmp);\t\t\t}\t\t}\t\twhile(stk.size()) pq.push(stk.back()),stk.pop_back();\t}\treturn ans;}int main(){\tPrework();\tans[Lim] = Brute(Lim);\twhile(!pq.empty()) pq.pop();\tfor(int i = 1;i &lt;= n;i++)\t\tif(usd[i] == 1) pq.emplace(-a[i] - s[i],i);\t\telse if(usd[i] &gt; 0) pq.emplace(-a[i],i);\tll sum = 0;\tfor(int i = 1;i &lt;= n;i++) sum += usd[i];\tfor(int i = Lim - 1;i &gt;= 1;i--)\t{\t\tans[i] = ans[i + 1];\t\twhile(sum &gt; i * m &amp;&amp; pq.size())\t\t{\t\t\tnode tmp = pq.top();\t\t\ttmp.c *= -1;\t\t\tif(usd[tmp.id] &gt; 1)\t\t\t{\t\t\t\tint dta = min(sum - 1ll * i * m,(ll)usd[tmp.id] - 1);\t\t\t\tusd[tmp.id] -= dta;ans[i] -= 1ll * dta * tmp.c;\t\t\t\tsum -= dta;\t\t\t\tif(usd[tmp.id] == 1) pq.pop(),pq.emplace(-a[tmp.id]-s[tmp.id],tmp.id);\t\t\t}\t\t\telse ans[i] -= tmp.c,usd[tmp.id]--,sum--,pq.pop();\t\t}\t}\tfor(int _ = 1,x;_ &lt;= Q;_++)\t\tread(x),write(ans[x]);\treturn 0;}\r\n","tags":["greedy"]},{"title":"CF1768F 题解","url":"/posts/3853366719/","content":"神仙题，被教育了。\r\n观察性质的能力不足，需要改进。\r\n\r\n DP 比较显然，\r\n要做这题，首先要注意到 \r\n这个条件，并猜测这个条件有蹊跷（我当时看到了也没管）。\r\n如果我们想一步跳多个格子，会耗费  的代价\r\n但我们肯定有一种策略就是一步一步跳过去，耗费  的代价，其上界为 。\r\n所以从  能转移到  的前提条件是 。\r\n可以得到 。\r\n那么这里就一定有一项 \r\n分类讨论：\r\n\r\n，这一部分可以暴力转移，时间复杂度 \r\n\r\n这个时候只靠上面的观察就不够了，我们还需继续发现性质。\r\n考察三个数 ，如果说 ，那我直接从  跳到 ，显然是不如从  跳到 ，再从  跳到  更优的。因为这三次跳跃的  都是 ，而  是显然的。\r\n所以  能转移到  还必须满足对于所有  ，都有 ，也就是说\r\n 或 。\r\n继续分类讨论：\r\n\r\n，我们维护一个从栈顶向栈底严格递减的单调栈，此时\r\n 显然是单调栈中的元素，因为\r\n，我们在维护单调栈时只需要把 \r\n的元素入栈即可。而单调栈中的元素互不相同，所以单调栈的长度显然不会超过\r\n。因此，暴力枚举单调栈中的每个元素转移即可。\r\n，我们可以往前找到第一个  的元素 ，在  中的  都可以转移过来，我们暴力枚举这样的\r\n 转移即可。\r\n接下来证明这一部分的时间复杂度： 设  表示最大的  满足 ，那么 ，即 。\r\n把  相同的所有元素一起考虑\r\n，其  之和显然是  的。\r\n因为这里只考虑 \r\n的  ，所以 被考虑到的所有  的总和都是  的，那  之和自然也是  的。\r\n\r\n\r\n综上所述，我们在 \r\n的时间复杂度内解决了本题。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4e5 + 5;typedef long long ll;template&lt;typename T&gt; inline void ckmin(T &amp;x,const T &amp;y) { if(x &gt; y) x = y;}int n;int a[N];ll dp[N];int stk[N],top;int main(){\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i];\tint lim = sqrt(n) + 0.5;\tdp[1] = 0;stk[top = 1] = 1;\tfor(int i = 2;i &lt;= n;i++)\t{\t\tdp[i] = 1e18;\t\tfor(int l = 1,mn = a[i];l &lt;= min(i - 1,lim + 1);l++)\t\t\tmn = min(mn,a[i - l]),\t\t\tckmin(dp[i],dp[i - l] + 1ll * l * l * mn);\t\tfor(int j = 1;j &lt;= top;j++)\t\t\tif(a[stk[j]] &lt;= a[i])\t\t\tckmin(dp[i],dp[stk[j]] + 1ll * (i - stk[j]) * (i - stk[j]) * a[stk[j]]);\t\tif(a[i] &lt;= lim)\t\t{\t\t\tfor(int j = i - 1;j &gt;= 1;j--)\t\t\t{\t\t\t\tif(a[j] &lt;= a[i]) break;\t\t\t\tckmin(dp[i],dp[j] + 1ll * (i - j) * (i - j) * a[i]);\t\t\t}\t\t\twhile(top &amp;&amp; a[stk[top]] &gt;= a[i]) --top;\t\t\tstk[++top] = i;\t\t}\t}\tfor(int i = 1;i &lt;= n;i++) printf(\"%lld \",dp[i]);printf(\"\\n\");\treturn 0;}\r\n","tags":["DP"]},{"title":"CF1408H 题解","url":"/posts/1692119499/","content":"牛逼题，被教育了。\r\n\r\n当时笔者看到这个题面就直接胡了一个贪心，发现假了之后改成了网络流，然后因模型过于复杂不会模拟流而宣告失败。事实上对于这题，简化问题和网络流建模是必不可少的两步。这题也告诉我们，模拟最大流时，一般将最大流转为最小割，然后用数据结构维护割边的方案。\r\n设  为  的个数，那么答案上界显然为 。\r\n也就是说，如果对于一个非零点，其某一边至少有  个 ，那么我们就不需要管这一边的匹配方案了，这边肯定是能匹配上的。\r\n容易发现，每一个非零点的两边都至少有一边的  的个数大于 。\r\n设  表示右边的零多于  的点的集合， 表示左边的零多于  的点的集合。\r\n对于一种颜色，我们要选取一个非零点  作为三元组的中间点，显然如果 ，我们会把  尽可能的往右调整，否则会把  尽可能地往左调整。这样在保证一边  的个数大于  的同时，还最大化了另一边的\r\n 的个数。\r\n所以对于一种颜色，我们可以处理出两个值  分别表示当  或  时， 的取值。\r\n此时再进行网络流建模就简单很多了。\r\n建三层图，一层表示所有颜色，一层表示所有非零点，一层表示所有零点。从\r\n 向所有颜色连边，每种颜色  向非零点 \r\n连边。所有非零点向其左边最靠右和右边最靠左的  连边。这些边的容量均为  。对于前  个 ，每个  连向它左边的第一个 ，容量为 。对于后  个 ，每个  连向它右边的第一个 ，容量为 。所有非零点向 \r\n连边，容量为  。\r\n接下来开始求解这个网络流模型的最大流。因为要表示一组最大流的解十分困难，我们不妨将最大流转化为最小割，考虑割边的方案。容易发现，如果我们割从某个颜色\r\n 向  或  的连边，这显然是不如割  连向 \r\n的边优的。同理，我们也不会割非零点向零点连的边。所以，只有  向颜色连的边和所有零点向  连的边有可能被割掉。\r\n如果说我们选择不割某一个颜色 \r\n，那么  左边的  和  右边的 \r\n就必须全部割掉。容易发现，不管颜色怎么选，被割掉的 \r\n肯定是一段前缀和一段后缀。那我们枚举被割掉的前缀 ，维护每个后缀  被割掉的代价，显然是  中  的个数 减去 \r\n的颜色个数。使用一棵支持区间减，全局取  的线段树即可维护。\r\n时间复杂度 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;namespace FastIO {\t#define iL (1 &lt;&lt; 20)\tchar ibuf[iL],*iS = ibuf + iL,*iT = ibuf + iL;\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf,1,iL,stdin),iS == iT ? EOF : *iS++) : *iS++)\ttemplate&lt;typename T&gt;\tinline void read(T &amp;a)\t{\t\tchar ch;int sign = 0;\t\tfor(ch = gc();!isdigit(ch);ch = gc())\t\t\tif(ch == '-') sign = 1;\t\ta = ch &amp; 15;\t\tfor(ch = gc();isdigit(ch);ch = gc())\t\t\ta = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch &amp; 15);\t\tif(sign) a = -a;\t}\tchar Out[iL],*iter = Out;\t#define flush() fwrite(Out,1,iter - Out,stdout),iter = Out\ttemplate&lt;typename T&gt;\tinline void write(T x,char end = '\\n')\t{\t\tint c[40],l = 0;if(x &lt; 0) *iter++ = '-',x = -x;\t\tdo c[++l] = x % 10,x /= 10; while(x);\t\twhile(l) *iter++ = c[l--] + '0';\t\t*iter++ = end;flush();\t}\t#undef iL \t#undef gc\t#undef flush}using namespace FastIO;const int N = 5e5 + 5;int n;int a[N];int pre[N],suf[N];int Lp[N],Rp[N];int Mi[N &lt;&lt; 2],tag[N &lt;&lt; 2];void pushup(int k) { Mi[k] = min(Mi[k &lt;&lt; 1],Mi[k &lt;&lt; 1 | 1]);}void AddTag(int k,int v) { tag[k] += v;Mi[k] += v;}void pushdown(int k) { if(tag[k]) AddTag(k &lt;&lt; 1,tag[k]),AddTag(k &lt;&lt; 1 | 1,tag[k]),tag[k] = 0;}void modify(int k,int l,int r,int x,int y,int v){\tif(x &lt;= l &amp;&amp; r &lt;= y) return AddTag(k,v);\tint mid = l + r &gt;&gt; 1;\tpushdown(k);\tif(x &lt;= mid) modify(k &lt;&lt; 1,l,mid,x,y,v);\tif(mid &lt; y) modify(k &lt;&lt; 1 | 1,mid + 1,r,x,y,v);\tpushup(k);}void build(int k,int l,int r){\tMi[k] = tag[k] = 0;\tif(l == r) {Mi[k] = l;return;}\tint mid = l + r &gt;&gt; 1;\tbuild(k &lt;&lt; 1,l,mid);build(k &lt;&lt; 1 | 1,mid + 1,r);\tpushup(k);}bool vis[N];inline void work(){\tread(n);\tfor(int i = 1;i &lt;= n;i++) Lp[i] = Rp[i] = vis[i] = 0;\tfor(int i = 1;i &lt;= n;i++) read(a[i]),vis[a[i]] = 1;\tfor(int i = 1;i &lt;= n;i++) pre[i] = pre[i - 1] + (a[i] == 0);\tsuf[n + 1] = 0;\tfor(int i = n;i &gt;= 1;i--) suf[i] = suf[i + 1] + (a[i] == 0);\tint lim = pre[n] / 2,L = 0,R = 0;\tfor(int i = 1;i &lt;= n;i++) if(pre[i] &lt;= lim) L = i;\tR = L + 1;int col = 0;\tfor(int i = 1;i &lt;= n;i++) col += vis[i];// \tprintf(\"%d,%d\\n\",L,R);\tfor(int i = 1;i &lt;= L;i++) Lp[a[i]] = i;\tfor(int i = n;i &gt;= R;i--) Rp[a[i]] = i;\tint m = suf[R],ans = min(col,lim);build(1,0,m);\tfor(int i = 1;i &lt;= n;i++)\t\tif(vis[i] &amp;&amp; !Lp[i])\t\t{\t\t\tmodify(1,0,m,suf[Rp[i]],m,-1);\t\t\tans = min(ans,col + Mi[1]);\t\t}\tfor(int i = 1;i &lt;= L;i++)\t{\t\tif(!a[i]) continue;\t\tif(Lp[a[i]] == i) modify(1,0,m,suf[Rp[a[i]]],m,-1);\t\tans = min(ans,col + pre[i] + Mi[1]);\t}\tcout &lt;&lt; ans &lt;&lt; endl;}int main(){\tint T;\tread(T);\twhile(T--) work();\treturn 0;}\r\n","tags":["flow"]},{"title":"CF1810G 题解","url":"/posts/3824941190/","content":"一道思路有启发意义的 DP 题，考察状态设计的优化。\r\n\r\n首先一个 \r\n的做法比较好想，枚举最大前缀和 ，在第一个 \r\n的地方统计每个序列的答案。这需要使用  算出在序列第  项， 且前面的  均不大于\r\n\r\n的方案数，故时间复杂度为立方。\r\n考虑平方怎么做。注意到这个 \r\n在转移中唯一的限制就是 ，我们却需要在 DP 中枚举  和  这两个维度，这看上去很浪费信息。我们把\r\n 变形为 ，那我们在 DP 中就只需要记录\r\n 和  这两维了。\r\n重写 DP 状态， 表示目前\r\nDP 到第  位，\r\n的方案数。但这会迎来两个问题。\r\n第一个问题：这个 \r\n要在哪里乘？实际上，在 \r\n的时候， 一定等于 ，所以在赋初值的时候，直接令  即可。\r\n第二个问题：如何统计答案？我们只需多记录一维 ，表示在前面的转移过程中， 是否等于过 ，最后统计答案时，把所有  相加即可。（这个技巧类似于\r\nAGC013D，但不完全相同）。\r\n综上，我们以 \r\n时间复杂度解决了本题。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e3 + 5,P = 1e9 + 7;inline int qpow(int a,int b) { int res = 1;while(b) {if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;} return res;}int n;int h[N];int f[N][N][2];int p[N];int ans[N];inline void work(){\tscanf(\"%d\",&amp;n);\tfor(int i = 1;i &lt;= n;i++)\t{\t\tint x,y;\t\tscanf(\"%d%d\",&amp;x,&amp;y);\t\tp[i] = 1ll * x * qpow(y,P - 2) % P;\t}\tfor(int i = 0;i &lt;= n;i++) scanf(\"%d\",&amp;h[i]);\tfor(int i = 0;i &lt;= n;i++)\t\tfor(int j = 0;j &lt;= n;j++)\t\t\tf[i][j][0] = f[i][j][1] = 0;\tfor(int i = 0;i &lt;= n;i++)\t{\t\tif(i == 0) f[0][0][1] = h[i];\t\telse f[0][i][0] = h[i];\t}\tfor(int i = 1;i &lt;= n;i++)\t\tfor(int j = 0;j &lt;= n;j++)\t\t{\t\t\tif(j != 0)\t\t\t{\t\t\t\tf[i][j][0] = (1ll * f[i - 1][j + 1][0] * p[i] % P + 1ll * f[i - 1][j - 1][0] * (P + 1 - p[i]) % P) % P;\t\t\t\tf[i][j][1] = (1ll * f[i - 1][j + 1][1] * p[i] % P + 1ll * f[i - 1][j - 1][1] * (P + 1 - p[i]) % P) % P;\t\t\t}\t\t\telse \t\t\t\tf[i][j][1] = (1ll * (f[i - 1][j + 1][0] + f[i - 1][j + 1][1]) * p[i] % P + 1ll * (f[i - 1][j - 1][0] + f[i - 1][j - 1][1]) * (P + 1 - p[i]) % P) % P;\t\t}\tfor(int i = 1;i &lt;= n;i++)\t{\t\tans[i] = 0;\t\tfor(int j = 0;j &lt;= n;j++)\t\t\t(ans[i] += f[i][j][1]) %= P;\t}\tfor(int i = 1;i &lt;= n;i++) \t\tprintf(\"%d \",ans[i]);\tprintf(\"\\n\");}int main(){\tint T;\tcin &gt;&gt; T;\twhile(T--) work();\treturn 0;}\r\n","tags":["DP","counting"]},{"title":"JOISC 2019 Day2 题解","url":"/posts/1371172839/","content":"这两道题都是十分具有 JOI 风格的数据结构题。\r\n都没有完全做出，不过确实感受到了数据结构的妙处和水平的提升。\r\n\r\nloj 3033 两根天线\r\n题意： https://loj.ac/p/3033\r\n不妨设 ，那么两根天线之间的限制为 \r\n使用 cdq\r\n分治+线段树处理这些偏序限制即可拿到除最后一个包的所有分。\r\n然后笔者卡在了这里，一直没有想到好的办法处理这些限制。\r\n考虑把节点  拆成两个事件，在\r\n 处出现，在  处消失。\r\n那么我们从小到大扫描 ，并同时维护每个  的最大成本 。\r\n一个询问的答案就是在  时的\r\n。\r\n我们不妨假设 ，因为最后是求  的最大值，我们把 \r\n变为原来的相反数再做一遍就不会漏统计了。\r\n此时绝对值就被去掉了。更方便的是，我们并不需要考虑  这个限制，因为\r\n的肯定不会被算入答案。\r\n那么此时，设  表示，如果\r\n 目前出现了且没有消失，那么 ，否则 。\r\n扫到一个  的时候就是把所有在\r\n 中且出现了的\r\n 的  值对  取 。\r\n在线段树上维护  和 ，维护一个标记表示从上次 pushdown\r\n到现在，这个节点被操作的 \r\n的最小值，就可以维护了！\r\n本题的难点主要在于这个扫描线，想到了之后其实不难使用这种线段树技巧完成维护。扫描线作为一种较为轻工业的数据结构技巧，其运用更加考验思维能力。\r\n代码： https://loj.ac/s/1803371\r\nloj3034 两道料理\r\n题意： https://loj.ac/p/3034\r\n首先显然有一个  的 DP。\r\n设  表示第一道菜做了前\r\n 个部分，第二道菜做了前  个部分，设 ，那么容易得出转移式： \r\n考虑优化这个 DP。\r\n我们枚举  ，同时维护 。\r\n我们注意到  只会从  以及上一个时刻的  转移，这启示我们考虑差分数组 。\r\n那么，转移式子中的  ，就相当于对 \r\n的  整体加上 ，也就是 \r\n那后半部分怎么办呢？设 。\r\n我们的操作相当于将每个  与\r\n 取 。\r\n但是我们发现，此时 \r\n的值并没有改变，但  的增大会使得\r\n 往后的  值都变大，所以我们要在  减去  变化前后的差值。\r\n这还是不好处理。\r\n考虑 ，我们对\r\n 的操作变成：\r\n\r\n单点加\r\n在  递增的过程中，每个  都会从  变成 ，在恰好从  变到  的这一刻， 要加上 。\r\n如果 ，让 。\r\n\r\n我们发现  的  并没有什么用， 操作中的  完全可以改写为 ”下一个  的位置“。\r\n注意到  操作最多新增  个  的 ，而一次  操作必定减少  个。\r\n所以我们用个  维护所有  的  即可，每次暴力修改所有涉及到的 ，易证只会修改  次。\r\n时间复杂度 。\r\n代码： https://loj.ac/s/1803767\r\n","tags":["DS","板刷记录"]},{"title":"CF1392H 题解","url":"/posts/618333468/","content":"计数能力退化力，以前最拿手的 min-max 也不大会用了。\r\n可能跟做题欲望有些消退有关。\r\n调整状态，抓紧时间奋斗 /fendou\r\n\r\n设  表示第 \r\n张牌被加入集合是在第几轮。因为每一轮的期望时间是确定的（也就是第一次抽出\r\nJoker 的时间）,我们设其为 ，答案即为 。\r\nmin-max 容斥： \r\n考虑 \r\n怎么求，显然这只与  有关。设\r\n，我们每次抽牌的时候，可以忽略既不在  ，也不是 JOKER\r\n的牌，因为它们不会对答案有任何影响。所以此时，抽出一张在  中的牌的概率就是 ，反之则有  的概率让轮数 。所以所求期望就是 。\r\n所以 \r\n接下来考虑  怎么算，设  表示恰好在第  张牌时抽出 Joker 的概率，那么 ，且 。综上，我们可以在  的时间里解决本题。\r\n一开始做的时候，就没把它当个概率题在做，设了一堆状态在那乱想。事实证明，研究概率问题时，要想放设法利用概率模型之间的独立性和概率的等价性，拆分和简化问题。\r\n","tags":["counting","min-max 容斥"]},{"title":"JOISC 2020 大部分题解","url":"/posts/2590094049/","content":"感觉能做的题目变多了，大概会做的题的比率跟  年差不多。\r\n对比之下，\r\n年还是较为阴间的。\r\n\r\nD1T1 建筑装饰 4\r\n题意：https://loj.ac/p/3271\r\n不好评价，对着  的 DP\r\n看了约一天，花了大部分的下课时间，没有发现可行转移点是个区间的性质，真是可惜。\r\n以上是本篇题解，相信读者可以完成其余的部分。\r\nD1T2 汉堡肉\r\n题意： https://loj.ac/p/3272\r\n之前听杂题的时候听过，要不然应该是没啥想法的。\r\n首先考虑，如果是 \r\n维情况，将右端点排序之后贪心即可。\r\n考虑什么时候  维会退化为 \r\n维，这当且仅当某一维上所有矩形的投影的交非空。\r\n此时我们在这一维上全选交集，另一维就是一维问题。\r\n如果没有这种情况的话，我们考虑这四条分界线： 。\r\n那么有 。\r\n对于最优解来说，答案里一定有 \r\n个点（可重合）满足 。\r\n也就是说，考虑直线 \r\n和直线 \r\n围成的矩形，那么答案一定在这个矩形的边界上。\r\n首先考虑如果有点在这个矩形的角上，我们可以枚举其在矩形的哪个角上，然后把与这个点有交的矩形删掉，再去找到新的\r\n，确定别的点。这就是个搜索的过程，时间复杂度\r\n。\r\n在 \r\n时跑这个搜索就做完了。在 \r\n时也可以先跑这个搜索。\r\n如果搜索找不到答案，那么 \r\n个点一定在矩形的四条边上。考虑一个点在某个位置时，其对另一个点的位置（准确的说是其对面的点的位置）有一个范围的限制，即其一定要在某个前缀或某个后缀中。使用\r\n2-SAT 刻画问题，容易在大常数 \r\n的时间复杂度中解决。\r\n代码咕了，感觉好难写。\r\nD1T3 扫除\r\n题意： https://loj.ac/p/3273\r\n离正解就差一个线段树分治。不知道是不是因为这题的思考时间都是零散的，导致最后一步没想出来。\r\n首先考虑 Sub 3，即满足 。感受一下就是一串蜿蜒向右下的点，容易证明在进行一次操作之后，这些点仍然满足这个性质。那么我们做每次操作时，二分出会受到影响的点的区间，进行一个区间赋值即可。这个操作可以使用线段树完成。\r\n然后考虑 Sub 4，即没有中途插入点的情况。直觉告诉我们这个点跟 Sub3\r\n关系紧密。事实上，如果有两个点 \r\n满足 ，那么如果一次操作扫到了点 ，那么  肯定也会被扫到， 就会满足 \r\n了。由此可以得出结论，对于那些被扫过一次的节点，它们互相之间是满足 Sub 3\r\n的性质的。\r\n那么我们对没被扫到过和被扫到过的节点分别维护即可。我们需要找到每个节第一次被扫到的时间，这个可以用一棵普通线段树比较方便地处理。对于那些被扫到过的节点，因为我们要往其中插入元素，故把原来的线段树改成平衡树即可。\r\n考虑正解。此时 Sub 4\r\n中推出的性质不一定满足，因为点的插入有了时间差别，但如果我们进行一个线段树分治，把点的存在时间拆为\r\n\r\n个线段树节点，然后对于每个线段树节点来说，问题就和 Sub 4\r\n没有区别了。\r\n时间复杂度 。\r\n虽然不知道为啥  出  然后放 。\r\n代码：https://loj.ac/s/1780245\r\n","tags":["板刷记录"]},{"title":"JOISC 2021 大部分题解","url":"/posts/499612066/","content":"感觉比 \r\n年的题目简单一些，能自己做出一些题目。\r\n这里有除了 【IOI 热病】 的所有传统题的题解。\r\n\r\nDay1T3 饮食区\r\n这道题再次说明 JOISC 的题目排序是乱序的。\r\n题意： https://loj.ac/p/3489\r\n容易发现，如果我们能求出这个队列目前一共 pop\r\n掉了多少人，那么我们进行整体二分/可持久化线段树+二分就可以求得答案。\r\n而求出 pop 掉多少人等价于求出这个队列现在有多少人。\r\n观察队列人数的变化，注意到操作  相当于区间加/区间减，同时每次操作后对\r\n 取 。\r\n当时脑子烧了，想了一个  的分块。实际上，Seg beats\r\n就可以做这个。然而，因为是区间操作，单点询问，我们甚至不需要 Seg\r\nbeats，只需维护一个二元标记 \r\n表示 ，给线段树上对应节点打标记即可。\r\n时间复杂度 。\r\n代码： https://loj.ac/s/1777073\r\nDay2T2 道路建设\r\n题意 : https://loj.ac/p/3491\r\n做完这题才意识到我两年前好像见过这题。\r\n欲求前  小，先求第  小。\r\n求第 \r\n小需要二分，即找到有多少对点之间的距离 。\r\n此时曼哈顿距离就不大好做了，考虑将坐标系旋转  （即 \r\n），此时原图的曼哈顿距离是新图的切比雪夫距离，即 。\r\n那么  就等价于 。\r\n那么把点按  坐标排序后，用一个\r\nset 维护所有跟当前点 \r\n坐标相差不超过  的点集即可。\r\n在找有多少对点的距离 \r\n的时候，我们顺便把所有 \r\n的点对都扔到一个答案数组里，这样在二分得到第  小的时候，也顺便把前  小都找出来了。\r\n时间复杂度 。\r\n代码：https://loj.ac/s/1777222\r\nDay3T2 保镖\r\n题意：https://loj.ac/p/3494\r\n神仙题，主要是第一步难以想到。\r\n考虑保镖和人相遇需要时间和位置都重合，在一维的数轴上不好做，不妨以坐标和时间为两维建立坐标系，将问题变为二维。\r\n此时每个人相当于一条斜率为  或\r\n\r\n的线段，保镖的行走路径则是摇摆着向上的折线。\r\n图还是不大美观，考虑将坐标系旋转 ，此时每个人变为一条横线或一条竖线，保镖则是只能向右或向上走，想要最大化小费。\r\n注意到在两次变换之后，新图中两点之间的距离被拉长至原图的  倍，所以  要除以 （这就是为什么  是偶整数）。\r\n此时所有人的轨迹可以交织成一张网格图。如果保镖从一开始就在网格图的格点上，那么答案其实是容易算的。设\r\n 表示从网格图中的点 \r\n出发能得到的最大小费，转移是简单的。\r\n问题在于保镖一开始可能落在某个小网格的中间。\r\n考虑此时保镖的决策，一定是先向上走一段，走到某条格线，然后向右拐走到一个格点。也可能先向右再向上，这是对称的。\r\n此时，保镖走的第一段路是没有贡献的。设其走的第二段路权值为 ，长度为 ，走到了格点 ，那么贡献是 。\r\n对于一个 ， 和 \r\n都是确定的，这个式子就是一个关于长度的一次函数。我们回答询问，就是对于一个一次函数序列的前缀，查询某个横坐标对应的最值。\r\n显然，使用李超线段树即可做到 。\r\n其实还可以做得更好。\r\n注意到  值是具有单调性的，即\r\n。而 \r\n值就是一次函数的截距，而如果一个函数的斜率和截距都不超过另一个函数，说明该函数已经没有用了。据此我们可以维护一个斜率递减的单调栈，因为我们可以保证每次插入的直线的截距都是当前最大的。维护单调栈时再把不符合凸性的直线弹出\r\n，我们就可以均摊 \r\n的维护一个凸壳。查询时在凸壳上二分即可。\r\n实现的时候可能要把图像按 \r\n轴对称，因为斜率递减的话，我们相当于是从右往左的维护了一个凸壳，不大方便。对称过后即使正常的从左往右维护凸壳。其实不这么做问题应该也不大。\r\n时间复杂度 。\r\n代码：https://loj.ac/s/1778383\r\nDay3T3 聚会 2\r\n题意：https://loj.ac/p/3495\r\n比较单薄的题，看出来就做完了。\r\n考虑两个相邻的点 \r\n均为重心是什么情况。\r\n那一定是  对应的子树有  个关键点， 对应的子树也有  个关键点。这样把重心从\r\n 调整到  ，总边数才不会变。\r\n\r\n为奇数时肯定没有这种情况，所以答案为 。\r\n\r\n为偶数时，也可以用上述的调整过程说明，那些重心一定形如一条链（因为如果调整到这条链以外，代价肯定会变多），而链两端对应的子树都有\r\n 个关键点。\r\n考虑选出一条链 ，它能贡献不超过  的 。我们可以直接将贡献记在 \r\n上，最后对答案数组做一遍后缀 \r\n即可。（ 和  分别是有多少点位于链的两端）。\r\n这个问题使用点分治+树状数组即可做到 ，实现细节可参阅代码。\r\n代码：https://loj.ac/s/1777442\r\nDay4T1 聚会 2\r\n题意： https://loj.ac/p/3496\r\n还是差了一步，说明大脑没有完全恢复。\r\n看到字典序最小考虑贪心，显然我们的策略是从  到  考虑每个区间能不能放，能放就放。\r\n设  表示只考虑  中的位置，最多能放多少个区间。\r\n那么假设我们选了个区间 \r\n，其将其所在的空段 \r\n变成了两个空段  和 （空段就是其中没有被选的区间或其一部分的段），那么我们能选当且仅当选完之后仍然可以选出不少于\r\n 个区间。设原来答案为 ，则能选当且仅当 。\r\n我们发现只要快速算出 ，就能快速判定一个区间的可选性。\r\n考虑 \r\n时，我们可以设计一个 ，设  表示 \r\n是所有选的区间中最靠左的那个时的最大区间数。考虑紧邻  的那个区间，一定是满足  且  最小的区间 。那么有 。\r\n我们发现，对于一个 \r\n只会有一个唯一确定的 \r\n（其实可能有多个，但它们的 \r\n相同，故都是等效的）。\r\n因此我们完全可以通过倍增来计算 DP 值，在 \r\n不确定时，我们找到最靠左的那个区间，然后倍增直到右端点  即可。\r\n时间复杂度 。\r\n代码：https://loj.ac/s/1777788\r\nDay4T3 最差记者 4\r\n题意： https://loj.ac/p/3498\r\n首先连边 ，形成一个拓扑图。显然这会形成一个根向基环森林，而环上的权值应当全部相等，且要么是\r\n 要么是环上的权值。\r\n考虑树的部分怎么做，一个暴力的想法是设出 DP 状态  表示处理  子树内的情况， 点本身权值为  的最小代价。那么有转移方程：  显然我们不可能暴力实现，只能采用数据结构维护。而  的限制很烦。注意到 \r\n是个定值，我们修改状态的定义，设其为最大可以节省多少费用。这样转移就变为：\r\n 这样我们在数据结构中就只需要单点修改，而非修改两段区间。\r\n说到这里，用什么数据结构也就基本呼之欲出：线段树！\r\n我们使用线段树合并维护每个点上的 DP 值。\r\n你会发现我们需要在线段树合并时处理后缀  的问题。\r\n这也好办，在合并时记录两个变量分别表示这两棵线段树在  上的 ，合并时先递归右边，再递归左边即可。\r\n在有一个当前节点为空时，需要将维护的后缀 \r\n加到另一个当前节点对应的所有位置，这需要一个加法标记来实现。\r\n牵扯到标记就会有一个问题：如果标记下传到一段没有节点的区间，我们要怎么处理？\r\n其实在这道题中是不需要处理的。因为实际上 ，DP\r\n的第二维取到的只能是子树内的点权。而子树内的点权对应的位置在单点修改的时候就已经为其新建了一些节点，所以这种情况实际上不会存在。\r\n这也解释了为什么之前要将 DP\r\n状态进行一个小变化。变化之前我们并不能保证子树内的点权对应的位置均被新建了节点。\r\n做完树的部分之后，环的部分只需要枚举环上点的取值即可求得答案。\r\n时间复杂度 。\r\n代码 : https://loj.ac/s/1777827\r\n","tags":["板刷记录"]},{"title":"JOISC2022 Day2 题解","url":"/posts/401156015/","content":"事实上没有通信题题解。\r\n这两题都没想出完整做法，不知道是不是睡眠质量的问题。按道理来说都应是\r\n“刚好会做” 的题。\r\n按体感难度排序。\r\n\r\nloj3690 团队竞技\r\n题意： https://loj.ac/p/3690\r\n老老实实地想了除最后一个包的所有点。\r\n无语住了。\r\n按  从小到大排序，扫描 \r\n最大的那个人，剩下两人都要在他前面。设剩下两人为 ，那么有 。\r\n我们加入一个 \r\n的时候，其实就可以找到与其配对的另一个人 (满足  的  中  最大的，以及满足  的  中  最大的)。\r\n将  与和其配对的点合成一对\r\n，扔到一个二维数据结构里面。扫描到\r\n 时，查询  的  最大值即可。\r\n时间复杂度 。\r\nloj3688 复制粘贴 3\r\n题意 : https://loj.ac/p/3688\r\n想到了区间\r\nDP，但脑子不在状态，只是描绘了一个复制粘贴的形态，没有在纸上细推，导致转移没有编出来。\r\n至于如何想到，其实可以考虑观察样例 \r\n的构造过程。其没有明显的顺序或倒序构造的特征，不过仍然是从小串构造出包含它的大串，即\r\n，这反映到区间上就是\r\n。一条区间 DP 的转移路径。\r\n那么我们可设 \r\n表示不管当前的剪贴板是什么，构造出  的最小步数。\r\n考虑我们剪切了一个串后，用其构造出来的串一定形如  （其中  都是我们手打的字符）。\r\n其中头尾两段不是很好处理，我们考虑编两个转移来包含这两段。\r\n显然有 \r\n(其中  表示 )。\r\n考虑  怎么办 ，我们设  表示构造出 \r\n，且最后一次操作是粘贴的最小步数。\r\n当我们从 \r\n向外转移时，可以先令 ，然后 。\r\n依据  的定义，我们可以转移\r\n。\r\n至此， 和  都处理完了。\r\n那么我们多次粘贴 \r\n时，可以默认我们构造出来的串开头是 ，结尾也是 。\r\n那么我们设  表示  最早的出现位置使得该位置不在  中。\r\n那么我们每次转移暴力跳 \r\n即可转移。\r\n因为我们至多跳 \r\n次，复杂度是  的\r\n( 是调和级数)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline void ckmin(T &amp;x,const T &amp;y) { if(x &gt; y) x = y;}const int N = 2.5e3 + 5;typedef unsigned long long ull;const ull base = 13331;int n;int A,B,C;char s[N];int nxt[N][N];long long f[N][N],g[N][N];ull hsh[N],Pow[N];ull h[N][N];map&lt;ull,int&gt; ton;int main(){\tcin &gt;&gt; n;\tcin &gt;&gt; (s + 1);\tcin &gt;&gt; A &gt;&gt; B &gt;&gt; C;\tPow[0] = 1;\tfor(int i = 1;i &lt;= n;i++) Pow[i] = Pow[i - 1] * base;\tfor(int i = 1;i &lt;= n;i++) hsh[i] = hsh[i - 1] * base + (s[i] - 'a' + 1);\tfor(int i = 1;i &lt;= n;i++)\t\tfor(int j = i;j &lt;= n;j++)\t\t\th[i][j] = hsh[j] - hsh[i - 1] * Pow[j - i + 1];\tfor(int l = 1;l &lt;= n;l++)\t{\t\tton.clear();\t\tfor(int i = n - l + 1;i + l - 1 &gt; n - l;i--)\t\tnxt[i][i + l - 1] = n + 1;\t\tfor(int i = n - l - l + 1;i &gt;= 1;i--)\t\t{\t\t\tton[h[i + l][i + l + l - 1]] = i + l;\t\t\tif(ton.find(h[i][i + l - 1]) == ton.end())\t\t\t\tnxt[i][i + l - 1] = n + 1;\t\t\telse nxt[i][i + l - 1] = ton[h[i][i + l - 1]];\t\t}\t}\tmemset(f,0x3f,sizeof f);\tmemset(g,0x3f,sizeof g);\tfor(int i = 1;i &lt;= n;i++)\t\tf[i][i] = A;\tfor(int len = 1;len &lt;= n;len++)\t{\t\tfor(int i = 1;i + len - 1 &lt;= n;i++)\t\t{\t\t\tint j = i + len - 1;\t\t\tckmin(f[i][j],g[i][j]);\t\t\tif(j &lt; n) ckmin(f[i][j + 1],f[i][j] + A);\t\t\tint now = nxt[i][j],cnt = 2;\t\t\twhile(now &lt;= n)\t\t\t\tckmin(f[i][now + len - 1],f[i][j] + B + 1ll * cnt * C + 1ll * A * (now + len - i - cnt * len)),\t\t\t\t++cnt,now = nxt[now][now + len - 1];\t\t}\t\tfor(int i = 2;i + len - 1 &lt;= n;i++)\t\t\tckmin(f[i - 1][i + len - 1],f[i][i + len - 1] + A);\t}\t\t\tcout &lt;&lt; f[1][n] &lt;&lt; endl;\treturn 0;}\r\n","tags":["板刷记录"]},{"title":"JOISC2022 Day1 题解","url":"/posts/2573606988/","content":"体感难度 : T3 &lt; T1 &lt; T2\r\nT3 成了最近板刷唯一做出来的题。\r\nT1 是“刚好会做”和“刚好不会做”的题。\r\nT2 非常强大，有些启发。\r\n\r\nloj3687 D1T3 错误拼写\r\n题意：计数满足如下要求的字符串 \r\n：\r\n\r\n\r\n设  表示将  中第 \r\n个字符删去后得到的字符串。给出两个长度为  的数组 ，要求  满足  （$$\r\n是字典序小于等于）。\r\n\r\n。\r\n考虑一个  代表什么。\r\n显然，这个大小关系等价于  与 \r\n的大小关系。\r\n对每一位进行比较，就相当于比较  和 。\r\n这启发我们根据 \r\n中的连续相等段进行 DP。\r\n设  表示  是  中某个极长相等段的右端点，， 是小于  还是大于 。枚举  的那个连续段 ，尝试从  转移，然后考虑  带来的限制。\r\n如果存在  满足 ，说明  必须小于  （因为状态中定义 ）。\r\n同理，如果存在  满足 ，那 。\r\n如果这两个条件满足则不能从 \r\n转移到 。\r\n否则，不满足和只满足一个的 \r\n肯定是一段区间，而这些区间的转移是相同的。进行一些前缀和优化即可做到\r\n。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;namespace FastIO{\t#define iL (1 &lt;&lt; 20)\tchar ibuf[iL],*iS = ibuf + iL,*iT = ibuf + iL;\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf,1,iL,stdin),iS == iT ? EOF : *iS++) : *iS++)\ttemplate&lt;typename T&gt;\tinline void read(T &amp;a)\t{\t\tchar ch;int sign = 0;\t\tfor(ch = gc();!isdigit(ch);ch = gc())\t\t\tif(ch == '-') sign = 1;\t\ta = ch &amp; 15;\t\tfor(ch = gc();isdigit(ch);ch = gc())\t\t\ta = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch &amp; 15);\t\tif(sign) a = -a;\t}\tchar Out[iL],*iter = Out;\t#define flush() fwrite(Out,1,iter - Out,stdout),iter = Out\ttemplate&lt;typename T&gt;\tinline void write(T x,char end = '\\n')\t{\t\tint c[40],l = 0;if(x &lt; 0) *iter++ = '-',x = -x;\t\tdo c[++l] = x % 10,x /= 10; while(x);\t\twhile(l) *iter++ = c[l--] + '0';\t\t*iter++ = end;flush();\t}\t#undef iL \t#undef gc\t#undef flush}using namespace FastIO;const int N = 5e5 + 5,P = 1e9 + 7,C = 26;inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}int n,m;int a[N],b[N];bool tp[N];int Mxr[2][N];int L[N],R[N]; // 有限制的转移区间，[Ri+1,i-1] 是没有限制的转移区间int f[N][C][2],sum[N][C][2];int ST[2][20][N],lg[N];inline int Qmax(int (*ST)[N],int l,int r){\tint k = lg[r - l + 1];\treturn max(ST[k][l],ST[k][r-(1&lt;&lt;k)+1]);}int main(){\tread(n);read(m);\tfor(int i = 1;i &lt;= m;i++) read(a[i]),read(b[i]);\tfor(int i = 1;i &lt;= m;i++)\t\tif(a[i] &lt; b[i]) Mxr[0][a[i]] = max(Mxr[0][a[i]],b[i] - 1);\t\telse Mxr[1][b[i]] = max(Mxr[1][b[i]],a[i] - 1);\t\tlg[0] = -1;\tfor(int i = 1;i &lt;= n;i++) lg[i] = lg[i &gt;&gt; 1] + 1;\tfor(int i = 1;i &lt;= n;i++) ST[0][0][i] = Mxr[0][i],ST[1][0][i] = Mxr[1][i];\tfor(int j = 1;j &lt; 20;j++)\t\tfor(int i = 1;i + (1 &lt;&lt; j) - 1 &lt;= n;i++)\t\t\tST[0][j][i] = max(ST[0][j - 1][i],ST[0][j - 1][i + (1 &lt;&lt; j - 1)]),\t\t\tST[1][j][i] = max(ST[1][j - 1][i],ST[1][j - 1][i + (1 &lt;&lt; j - 1)]);\tfor(int i = 1;i &lt;= n;i++)\t{\t\tint v1,v2;\t\tint lef = 0,righ = i;\t\twhile(lef &lt; righ)\t\t{\t\t\tint mid = lef + righ + 1 &gt;&gt; 1;\t\t\tif(Qmax(ST[0],mid,i) &gt;= i) lef = mid;\t\t\telse righ = mid - 1;\t\t}\t\tv1 = lef;\t\tlef = 0;righ = i;\t\twhile(lef &lt; righ)\t\t{\t\t\tint mid = lef + righ + 1 &gt;&gt; 1;\t\t\tif(Qmax(ST[1],mid,i) &gt;= i) lef = mid;\t\t\telse righ = mid - 1;\t\t}\t\tv2 = lef;\t\tL[i] = min(v1,v2);\t\tR[i] = max(v1,v2) - 1;\t\tif(v1 &lt; v2) tp[i] = 1; else tp[i] = 0;\t\t// printf(\"L,R,tp:%d,%d,%d,%d,%d\\n\",L[i],R[i],tp[i],v1,v2);\t}\tf[0][0][0] = f[0][1][1] = sum[0][0][0] = sum[0][1][1] = 1;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tif(R[i] &lt; i)\t\t{\t\t\tint ss[C];\t\t\tmemset(ss,0,sizeof ss);\t\t\tfor(int j = 0;j &lt; C;j++)\t\t\t{\t\t\t\tss[j] = sum[i - 1][j][0];\t\t\t\tif(R[i] &gt;= 0) Plus(ss[j],P - sum[R[i]][j][0]);\t\t\t\tj ? Plus(ss[j],ss[j - 1]) : void();\t\t\t}\t\t\t\t\t\t\tfor(int j = 1;j &lt; C;j++)\t\t\t\tPlus(f[i][j][0],ss[j - 1]),Plus(f[i][j][1],ss[j - 1]);\t\t\tmemset(ss,0,sizeof ss);\t\t\tfor(int j = C - 1;j &gt; 0;j--)\t\t\t{\t\t\t\tss[j] = sum[i - 1][j][1];\t\t\t\tif(R[i] &gt;= 0) Plus(ss[j],P - sum[R[i]][j][1]);\t\t\t\tj != C - 1 ? Plus(ss[j],ss[j + 1]) : void();\t\t\t}\t\t\tfor(int j = 0;j &lt; C - 1;j++)\t\t\t\tPlus(f[i][j][0],ss[j + 1]),Plus(f[i][j][1],ss[j + 1]);\t\t}\t\tif(R[i] &gt;= 0 &amp;&amp; L[i] &lt;= R[i])\t\t{\t\t\tint ss[C];\t\t\tmemset(ss,0,sizeof ss);\t\t\tfor(int j = 0;j &lt; C;j++)\t\t\t{\t\t\t\tPlus(ss[j],sum[R[i]][j][0]);\t\t\t\tif(L[i] &gt; 0) Plus(ss[j],P - sum[L[i] - 1][j][0]);\t\t\t\tif(j) Plus(ss[j],ss[j - 1]);\t\t\t}\t\t\tfor(int j = 1;j &lt; C;j++)\t\t\t\tPlus(f[i][j][tp[i]],ss[j - 1]);\t\t\tmemset(ss,0,sizeof ss);\t\t\tfor(int j = C - 1;j &gt; 0;j--)\t\t\t{\t\t\t\tPlus(ss[j],sum[R[i]][j][1]);\t\t\t\tif(L[i] &gt; 0) Plus(ss[j],P - sum[L[i] - 1][j][1]);\t\t\t\tif(j != C - 1) Plus(ss[j],ss[j + 1]);\t\t\t}\t\t\tfor(int j = 0;j &lt; C - 1;j++)\t\t\t\tPlus(f[i][j][tp[i]],ss[j + 1]);\t\t}\t\tfor(int j = 0;j &lt; C;j++)\t\t\tsum[i][j][0] = sum[i - 1][j][0],Plus(sum[i][j][0],f[i][j][0]),\t\t\tsum[i][j][1] = sum[i - 1][j][1],Plus(sum[i][j][1],f[i][j][1]);\t}\tint ans = 0;\tfor(int j = 0;j &lt; C;j++)\t\tPlus(ans,f[n][j][0]);\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\nloj3685 D1T1 监狱\r\n题意 : https://loj.ac/p/3685\r\n这种一眼难有多项式做法的题，一般是需要发掘一些性质的。\r\n我们断言一个囚犯如果开始走，就不会在中途停留，会一直从  走到 。\r\n感性理解一下，考虑路径 \r\n如果中途停留在了某个点 ，说明有些路径的  在  到  的路径上上（所以要走到  使得它们可以走过来），有些路径的  在  到  的路径上。但是此时，我们先走那些\r\n 在  到  的路径，再走当前这条，再走  在  到 \r\n上的路径，效果是一样的，且没有中间停留。\r\n这个结论出来了之后，我们就可以直接考虑两条路径的关系。对于  和 ，如果  在  到  的路径上，说明  比  要先走，如果  在  到  的路径上，说明  比  要后走。\r\n把这个二元关系建个图跑拓扑排序就能拿到  分。\r\n我都想到了这里，但没有想到，接下来的事情只需一个倍增优化建图即可。\r\n优化建图的具体细节可以看代码。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1.5e5 + 5,Sz = N * 44,M = 4e7 + 5;int n,m;vector&lt;int&gt; G[N];int s[N],t[N];int anc[20][N],up[20][N],down[20][N],dep[N];int deg[Sz];int fir[Sz],nxt[M],to[M],ect = 0;inline void addedge(int u1,int v1) { nxt[++ect] = fir[u1];fir[u1] = ect;to[ect] = v1;++deg[v1];}int idcnt;void dfs0(int x,int f){\tanc[0][x] = f;dep[x] = dep[f] + 1;\tfor(int i = 1;i &lt;= 19;i++) anc[i][x] = anc[i - 1][anc[i - 1][x]];\tfor(auto y : G[x])\t\tif(y != f) dfs0(y,x);}int jump(int x,int y){\tfor(int i = 19;i &gt;= 0;i--)\t\tif(dep[anc[i][x]] &gt; dep[y]) x = anc[i][x];\treturn x;}int lca(int x,int y){\tif(dep[x] &lt; dep[y]) swap(x,y);\tfor(int i = 19;i &gt;= 0;i--)\t\tif(dep[anc[i][x]] &gt;= dep[y]) x = anc[i][x];\tif(x == y) return x;\tfor(int i = 19;i &gt;= 0;i--)\t\tif(anc[i][x] != anc[i][y])\t\t\tx = anc[i][x],y = anc[i][y];\treturn anc[0][x];}void work(){\t\tect = 0;\tfor(int i = 1;i &lt;= idcnt;i++)\t\tfir[i] = deg[i] = 0;\tidcnt = 0;\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++) G[i].clear();\tfor(int i = 1;i &lt; n;i++)\t{\t\tint a,b;\t\tcin &gt;&gt; a &gt;&gt; b;\t\tG[a].push_back(b);\t\tG[b].push_back(a);\t}\tcin &gt;&gt; m;\tfor(int i = 1;i &lt;= m;i++)\t\tcin &gt;&gt; s[i] &gt;&gt; t[i];\tidcnt = m;\tfor(int i = 1;i &lt;= n;i++)\t\tfor(int j = 0;j &lt; 20;j++) anc[j][i] = 0;\tdfs0(1,0);\tfor(int i = 1;i &lt;= n;i++)\t\tup[0][i] = ++idcnt,down[0][i] = ++idcnt;\tfor(int j = 1;j &lt; 20;j++)\t\tfor(int i = 1;i &lt;= n;i++)\t\tif(dep[i] &gt;= (1 &lt;&lt; j))\t\t{\t\t\tup[j][i] = ++idcnt;down[j][i] = ++idcnt;\t\t\tif(j)\t\t\t{\t\t\t\taddedge(up[j - 1][i],up[j][i]);addedge(up[j - 1][anc[j - 1][i]],up[j][i]);\t\t\t\taddedge(down[j][i],down[j - 1][i]);addedge(down[j][i],down[j - 1][anc[j - 1][i]]);\t\t\t} \t\t}\tfor(int i = 1;i &lt;= m;i++)\t{\t\tint x = s[i],y = t[i];\t\taddedge(i,up[0][x]);addedge(down[0][y],i);\t\tx = lca(s[i],t[i]) == s[i] ? jump(t[i],s[i]) : anc[0][s[i]];\t\tif(dep[x] &lt; dep[y]) swap(x,y);\t\tfor(int j = 19;j &gt;= 0;j--)\t\t\tif(dep[anc[j][x]] &gt;= dep[y])\t\t\t\taddedge(up[j][x],i),x = anc[j][x];\t\tif(x == y) addedge(up[0][x],i);\t\telse\t\t{\t\t\tfor(int j = 19;j &gt;= 0;j--)\t\t\tif(anc[j][x] != anc[j][y])\t\t\t\taddedge(up[j][x],i),addedge(up[j][y],i),\t\t\t\tx = anc[j][x],y = anc[j][y];\t\t\taddedge(up[0][x],i);addedge(up[0][y],i);\t\t\taddedge(up[0][anc[0][x]],i);\t\t}\t\t\t\tx = s[i];y = lca(s[i],t[i]) == t[i] ? jump(s[i],t[i]) : anc[0][t[i]];\t\tif(dep[x] &lt; dep[y]) swap(x,y);\t\tfor(int j = 19;j &gt;= 0;j--)\t\t\tif(dep[anc[j][x]] &gt;= dep[y])\t\t\t\taddedge(i,down[j][x]),x = anc[j][x];\t\tif(x == y) addedge(i,down[0][x]);\t\telse\t\t{\t\t\tfor(int j = 19;j &gt;= 0;j--)\t\t\tif(anc[j][x] != anc[j][y])\t\t\t\taddedge(i,down[j][x]),addedge(i,down[j][y]),\t\t\t\tx = anc[j][x],y = anc[j][y];\t\t\taddedge(i,down[0][x]);addedge(i,down[0][y]);\t\t\taddedge(i,down[0][anc[0][x]]);\t\t}\t\t}\tqueue&lt;int&gt; Q;\tfor(int i = 1;i &lt;= idcnt;i++) if(!deg[i]) Q.push(i);\twhile(!Q.empty())\t{\t\tint x = Q.front();Q.pop();\t\t// printf(\"Q:%d\\n\",x);\t\tfor(int i = fir[x],y;y = to[i],i;i = nxt[i])\t\t\tif(!(--deg[y])) Q.push(y);\t}\tfor(int i = 1;i &lt;= idcnt;i++) if(deg[i]) return puts(\"No\"),void();\tputs(\"Yes\");}int main(){\tint T;\tcin &gt;&gt; T;\twhile(T--) work();\treturn 0;}\r\nloj3686 D1T2 京都观光\r\n题意： https://loj.ac/p/3686\r\n直接 DP 可以拿到 10 分的高分。我们仍然需要挖掘一些性质。\r\n考察两行 ，两列 ，假设我们不会中间拐弯。\r\n先横再竖的代价是 \r\n先竖再横的代价是 。\r\n那么我们选择先走横当且仅当 。\r\n这启示我们答案路径的选择和斜率有关。\r\n既然涉及到了斜率，就不能只考察二元关系了。\r\n考察三行 ，两列\r\n。\r\n\r\n蓝色路径减红色路径的代价是 \r\n蓝色路径减绿色路径的代价是 。\r\n如果这两个值不都小于 ，说明\r\n 这一列就没啥用了。\r\n上面的式子小于  当且仅当 。\r\n下面的式子小于  当且仅当 \r\n那么我们发现，当对于任意  ，都有  时， 才可能有用，说明有用的  一定形成一个凸包。 同理。\r\n把两个序列的凸包求出来之后，我们要根据这两个凸包求答案。\r\n这个时候可以直接做个闵可夫斯基和，也就是对凸包中的直线进行一个归并排序。再换句话说，就是每次根据最开始的那个\r\n 与 \r\n的大小关系，决定先走横还是先走竖。这个过程可以导出唯一解，且任意其他的解都可以通过不断调整得到这个解，所以这就是个最优解。\r\n具体细节可以看代码。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int n,m,a[N],b[N];inline double slopeA(int x,int y) { return 1.0*(a[y] - a[x]) / (y - x);}inline double slopeB(int x,int y) { return 1.0*(b[y] - b[x]) / (y - x);}int ha[N],cnta; int hb[N],cntb;// a,b 两边的凸包int main(){\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i];\tfor(int i = 1;i &lt;= m;i++) cin &gt;&gt; b[i];\tha[cnta = 1] = 1;\tfor(int i = 2;i &lt;= n;i++)\t{\t\twhile(cnta &gt; 1 &amp;&amp; slopeA(ha[cnta - 1],ha[cnta]) &gt; slopeA(ha[cnta],i))\t\t\t--cnta;\t\tha[++cnta] = i;\t}\thb[cntb = 1] = 1;\tfor(int i = 2;i &lt;= m;i++)\t{\t\twhile(cntb &gt; 1 &amp;&amp; slopeB(hb[cntb - 1],hb[cntb]) &gt; slopeB(hb[cntb],i))\t\t\t--cntb;\t\thb[++cntb] = i;\t}\tlong long ans = 0;\tint i = 1,j = 1;\twhile(i &lt; cnta &amp;&amp; j &lt; cntb)\t\tif(slopeA(ha[i],ha[i + 1]) &lt;= slopeB(hb[j],hb[j + 1]))\t\t\tans += 1ll * b[hb[j]] * (ha[i + 1] - ha[i]),++i;\t\telse ans += 1ll * a[ha[i]] * (hb[j + 1] - hb[j]),++j;\twhile(i &lt; cnta) ans += 1ll * b[hb[j]] * (ha[i + 1] - ha[i]),++i;\twhile(j &lt; cntb) ans += 1ll * a[ha[i]] * (hb[j + 1] - hb[j]),++j;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\t\r\n","tags":["板刷记录"]},{"title":"「USACO 2022.2 Platinum」 题解","url":"/posts/2649489914/","content":"没有一道题想出完整做法。真是让人自闭。\r\n按体感难度排序。\r\n\r\nloj3668 Sleeping in Class\r\n题意：给出一个序列 ，一次操作可以将两个相邻的数\r\n 合并为 ，也可以将数  分解为两个相邻的数 ，问最后使得序列中的所有数都等于\r\n 的最少操作次数。可能无解。 次询问，每次给出不同的 。\r\n。\r\n设  表示  的前缀和。\r\n那么  则无解。\r\n否则最优策略一定如下：\r\n维护当前准备参与操作的数 \r\n，初始 。从左到右扫描到 ，把  与  合并，如果此时 ，就不停地从  中分出  来。\r\n观察这个过程，发现  （特例，如果 ，）\r\n我们发现，如果没有  的位置，那么分裂要进行  次，合并要进行 \r\n次，而每出现一个这样的位置，可以少一次分裂，少一次合并。故答案为 。\r\n我当时转化出来的东西没有这么简洁明了，所以寄了。\r\n考虑如何求出 ，注意到 ，所以我们只关心所有的  。考察  和  的质因子分解。设其分别为  ，那么\r\n 对  有贡献当且仅当 。我们发现这是一个高维后缀和的形式，而这事实上也是可以做的，因为\r\n 在  时大约只有  级别，而维数也是 \r\n，很小。这里高维后缀和的时间复杂度为  （这里的  是使用 map\r\n进行离散化的复杂度）。\r\n现在的问题在于如何求出 \r\n的质因子分解了。做过 AGC003D 的同学应该熟悉这样一个方法：设值域为 ，先将不超过  的质因子试除掉。如果剩下的数小于\r\n，那么其一定是一个质数\r\n，否则其质因子就被试除掉了。如果大于 ，那么先前试除掉的部分总共就不超过\r\n，而剩余部分一定是至多两个质数相乘的形式。此时\r\n。\r\n此题中 。对于最后的那种情况，可能的  只有几千个，直接暴力即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;typedef long long ll;int n,Q;ll a[N];map&lt;long long,long long&gt; mp;int pri[N],cnt[N],tot;ll pw[N];map&lt;long long,int&gt; f;inline ll calc(int *p) // 把幂次数组压成long long 整数{\tll res = 0;\tfor(int i = 1;i &lt;= tot;i++)\t\tres += 1ll * p[i] * pw[i];\treturn res;}inline ll rev(ll x) // 把状压后的整数变为质因数分解前的数{\tll res = 1;\tfor(int i = 1;i &lt;= tot;i++)\t{\t\tll pp = (x / pw[i]) % (cnt[i] + 1);\t\twhile(pp--) res = res * pri[i];\t}\treturn res;}void dfs(int x,ll now,int fix){\tif(x &gt; tot)\t\treturn f[now - pw[fix]] += f[now],void();\tll np = cnt[x] * pw[x];\tfor(int i = cnt[x];i &gt;= (x == fix);i--)\t\tdfs(x + 1,now + np,fix),np -= pw[x];}int tp[N];inline void Divide(){\tll tmp = a[n];\tfor(int i = 2;i &lt;= 1e6;i++)\t\tif(tmp % i == 0)\t\t{\t\t\tpri[++tot] = i;\t\t\twhile(tmp % i == 0) tmp /= i,++cnt[tot];\t\t}\tif(tmp &gt; 1e12) return;\tif(tmp &gt; 1) pri[++tot] = tmp,cnt[tot] = 1;\tpw[tot] = 1;\tfor(int i = tot - 1;i &gt;= 0;i--)\t\tpw[i] = pw[i + 1] * (cnt[i + 1] + 1);\tfor(int i = 1;i &lt; n;i++)\t{\t\ttmp = a[i];\t\tfor(int j = 1;j &lt;= tot;j++)\t\t{\t\t\ttp[j] = 0;\t\t\twhile(tmp % pri[j] == 0) ++tp[j],tmp /= pri[j];\t\t\ttp[j] = min(tp[j],cnt[j]);\t\t}\t\tf[calc(tp)]++;\t}\tfor(int i = 1;i &lt;= tot;i++)\t\tdfs(1,0,i);\tfor(int i = 0;i &lt; pw[0];i++)\t\tmp[rev(i)] = (a[n] / rev(i) - 1) + (n - 1) - 2 * f[i];}int main(){\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i],a[i] += a[i - 1];\tDivide();\tcin &gt;&gt; Q;\tfor(int i = 1;i &lt;= Q;i++)\t{\t\tll x;\t\tcin &gt;&gt; x;\t\tif(a[n] % x) {puts(\"-1\");continue;}\t\tif(!mp[x])\t\t{\t\t\tint res = 0;\t\t\tfor(int j = 1;j &lt; n;j++) res += (a[j] % x == 0);\t\t\tmp[x] = (a[n] / x - 1) + (n - 1) - 2 * res;\t\t}\t\tcout &lt;&lt; mp[x] &lt;&lt; endl;\t}\treturn 0;}\r\nloj3669 Phone Number\r\n题意：https://loj.ac/p/3669\r\n我当时先思考的前两个包，因为只有两键的状态转移较为简单，只需记录一个\r\n 便可通过。后来想直接从  转移到 \r\n。发现难以配出简单系数，转移跟你填的那些数关联性较强，然后就不会了。\r\n事实上大力 DP，设状态  。 分别表示第  位你填的是什么字符， 表示前缀 \r\n能否根据题目规则匹配得上。转移枚举下一个字符填什么，比较简单。\r\n但是直接做会有 \r\n个状态，过不去的。\r\n发现当  时， 已经没有用了（因为  只会用来帮我们判断  能否匹配，从而接上 ，但如果 \r\n本身就无法匹配，我们也不用做这个判断了），同理，当  时， 无用，当  时， 也无用了。全为  就是不合法状态了。\r\n根据这个进行裁剪，状态数好像只减少了不到一半。\r\n还有一个优化，即若 ，那么对于 ，如果它们中有一个数不在 \r\n中，或者它们再加一个数也拼不出正方形，那么  就没用了，我们可以将其设为 。对于  也可以类似处理。\r\n考虑分析状态数的上界。如果 ，那么  的方案就是在\r\n\r\n种选三个数的方案数，只有 \r\n种选法， 不确定，一共\r\n 状态。如果 ， 就只有  有用，且在  中选，一共  种，乘上  的选法，一共  种。如果 ，就是  种状态。 就 \r\n种状态。总状态数有个上界  。\r\n据说实际状态大约只有 \r\n多个。可以用 unordered_map 存状态来进行转移。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5,P = 1e9 + 7;inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}int n;char s[N];int a[N];bool Can[5][4096];// Can[2] : 相邻// Can[3] : 能否加一个数变成方// Can[4] : 能否方struct State{\tint t0,t1,t2;\tbool v0,v1,v2,v3;\tState(){}\tState(const int _t0,const int _t1,const int _t2 \t\t,const int _v0,const int _v1,const int _v2,const int _v3):\t\tt0(_t0),t1(_t1),t2(_t2),v0(_v0),v1(_v1),v2(_v2),v3(_v3){}\tbool operator == (const State &amp;rhs) const {\t\treturn t0 == rhs.t0 and t1 == rhs.t1 and t2 == rhs.t2\t\tand v0 == rhs.v0 and v1 == rhs.v1 and v2 == rhs.v2 and v3 == rhs.v3;\t}};struct Hash{\tstatic const int base = 131;\ttypedef unsigned int uint;\tuint operator ()(const State &amp;x) const \t{\t\tuint res = 0;\t\tres = res * base + x.t0;res = res * base + x.t1;\t\tres = res * base + x.t2;res = res * base + x.v0;\t\tres = res * base + x.v1;res = res * base + x.v2;\t\tres = res * base + x.v3;return res;\t}};inline State Reduce(int id,const State &amp;x){\tState res = x;\tif(res.v3 == 0) res.t2 = 10;\tif(res.v3 == 0 &amp;&amp; res.v2 == 0) res.t1 = 10;\tif(res.v3 == 0 &amp;&amp; res.v2 == 0 &amp;&amp; res.v1 == 0) res.t0 = 10;\tint bk[10];memset(bk,0,sizeof bk);\tif(res.v3 == 1)\t{\t\tif(id &gt; 2) bk[a[id - 2]] = 1;\t\tif(id &gt; 1) bk[a[id - 1]] = 1;\t\tbk[a[id]] = 1;\t\tif(id &lt; n) bk[a[id + 1]] = 1;\t\tif(!Can[3][(1 &lt;&lt; res.t0) | (1 &lt;&lt; res.t1) | (1 &lt;&lt; res.t2)])\t\t\tres.v3 = 0;\t\tif(!bk[res.t0] || !bk[res.t1] || !bk[res.t2]) res.v3 = 0;\t}\tif(res.v2 == 1)\t{\t\tmemset(bk,0,sizeof bk);\t\tif(id &gt; 1) bk[a[id - 1]] = 1;\t\tbk[a[id]] = 1;\t\tif(id &lt; n) bk[a[id + 1]] = 1;\t\tif(id &lt; n - 1) bk[a[id + 2]] = 1;\t\tif(!bk[res.t0] || !bk[res.t1]) res.v2 = 0;\t}\tif(res.v1 == 1)\t{\t\tmemset(bk,0,sizeof bk);\t\tbk[a[id]] = 1;\t\tif(id &lt; n) bk[a[id + 1]] = 1;\t\tif(id + 1 &lt; n) bk[a[id + 2]] = 1;\t\tif(id + 2 &lt; n) bk[a[id + 3]] = 1;\t\tif(!bk[res.t0]) res.v1 = 0;\t}\treturn res;}inline State Next(int id,State x,int c){\tState res;\tres.t2 = x.t1;res.t1 = x.t0;res.t0 = c;\tres.v3 = x.v2;res.v2 = x.v1;res.v1 = x.v0;\tres.v0 = 0;\tif(x.v0 &amp;&amp; res.t0 == a[id + 1]) res.v0 = 1;\tif(x.v1) { \t\tint tv = (1 &lt;&lt; a[id]) | (1 &lt;&lt; a[id + 1]);\t\tif(tv == (1 &lt;&lt; res.t0) + (1 &lt;&lt; res.t1) &amp;&amp; Can[2][tv])\t\t\tres.v0 = 1;\t}\tif(x.v3)\t{\t\tint tv = (1 &lt;&lt; a[id - 2]) | (1 &lt;&lt; a[id - 1]) | (1 &lt;&lt; a[id]) | (1 &lt;&lt; a[id + 1]);\t\tif(tv == (1 &lt;&lt; res.t0) + (1 &lt;&lt; res.t1) + (1 &lt;&lt; res.t2) + (1 &lt;&lt; x.t2) &amp;&amp; Can[4][tv])\t\t\tres.v0 = 1;\t}\treturn res;}unordered_map&lt;State,int,Hash&gt; mp1,mp2;inline void Work(){\tcin &gt;&gt; (s + 1);\tn = strlen(s + 1);\tfor(int i = 1;i &lt;= n;i++) a[i] = s[i] - '0';\tmp1.clear();\tmp1[State(10,10,10,1,0,0,0)] = 1;\tfor(int i = 0;i &lt; n;i++)\t{\t\tmp2.clear();\t\tfor(auto it : mp1)\t\t{\t\t\tState t = it.first;\t\t\tfor(int c = 1;c &lt;= 9;c++)\t\t\t{\t\t\t\tState nxt = Next(i,t,c);\t\t\t\tnxt = Reduce(i + 1,nxt);\t\t\t\tif(nxt.v3 + nxt.v2 + nxt.v1 + nxt.v0 == 0) continue;\t\t\t\tPlus(mp2[nxt],it.second);\t\t\t}\t\t}\t\tmp1 = mp2;\t}\tint ans = 0;\tfor(auto it : mp1)\t\tif(it.first.v0 == 1)\t\t\tPlus(ans,it.second);\tcout &lt;&lt; ans &lt;&lt; endl;}\tint main(){\tfor(int i = 1;i &lt;= 9;i++)\t\tfor(int j = i + 1;j &lt;= 9;j++)\t\t\tif(abs(i - j) == 3 || (abs(i - j) == 1 &amp;&amp; i != 3 &amp;&amp; i != 6))\t\t\t\tCan[2][(1 &lt;&lt; i) | (1 &lt;&lt; j)] = 1;\tCan[4][32 + 16 + 4 + 2] = 1;\tCan[4][64 + 32 + 8 + 4] = 1;\tCan[4][256 + 128 + 32 + 16] = 1;\tCan[4][512 + 256 + 64 + 32] = 1;\tfor(int i = 1;i &lt;= 9;i++)\t\tfor(int j = i + 1;j &lt;= 9;j++)\t\t\tfor(int k = j + 1;k &lt;= 9;k++)\t\t\t\tfor(int p = 1;p &lt;= 9;p++)\t\t\t\t\tCan[3][(1 &lt;&lt; i) | (1 &lt;&lt; j) | (1 &lt;&lt; k)] |= Can[4][(1 &lt;&lt; i) + (1 &lt;&lt; j) + (1 &lt;&lt; k) + (1 &lt;&lt; p)];\tint T;\tcin &gt;&gt; T;\twhile(T--) Work();\treturn 0;}\r\n","tags":["板刷记录"]},{"title":"CF1368E 题解","url":"/posts/3690709470/","content":"比起题解区的神奇构造，我更喜欢@约瑟夫用脑玩\r\n的思维模式，能够推广到更加普适的问题，为图论解题提供启发，我们接下来讲述一下这种做法。\r\n\r\n考虑到这是个 DAG，我们不妨对每个点设一个深度 ，然后强制在删完后的图中，边  等价于 ，那么原限制等价于，不存在\r\n 的点。\r\n考察特殊对象是 OI 中的常见手段，我们在这道题中，首先考察入度为  的点，那么其深度为 。\r\n深度为 \r\n的点指出去的点，要么深度为 ，要么就被删掉。\r\n而深度为 \r\n的点指出去的点，一定要被删掉。\r\n因为我们要删掉的尽量少，一个点肯定不能随便成为深度为  的点。\r\n如果一个点，比它拓扑序小的都确定了，且有深度为  的点指向它，那么它就只能是深度为  的点。\r\n因为深度为 \r\n的点等价于被删掉，所以，如果一个点的入边都是深度为  的点，它和深度为  的点是等效的。\r\n按照上面的规则，按拓扑序更新  即可。\r\n设  的点的个数为 。\r\n因为出度 ，所以 \r\n容易发现 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n,m;vector&lt;int&gt; G[N];int dep[N],deg[N];queue&lt;int&gt; Q;inline void Work(){\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1;i &lt;= n;i++) dep[i] = deg[i] = 0,G[i].clear();\tfor(int i = 1;i &lt;= m;i++)\t{\t\tint x,y;\t\tcin &gt;&gt; x &gt;&gt; y;\t\tG[x].push_back(y);++deg[y];\t}\tfor(int i = 1;i &lt;= n;i++)\t\tif(!deg[i]) Q.push(i),dep[i] = 1;\t//\telse dep[i] = 1e9;\twhile(!Q.empty()) // dp = -1 表示已经被删除;dp = 0 表示所有入边都是被删的点，我们在入队时会把这种情况置为 1\t{\t\tint x = Q.front();Q.pop();\t\t// printf(\"dep[%d]=%d\\n\",x,dep[x]);\t\tfor(auto y : G[x])\t\t{\t\t\t--deg[y];\t\t\tif(dep[x] != -1)\t\t\t{\t\t\t\tif(dep[x] == 1 &amp;&amp; dep[y] != -1) dep[y] = 2;\t\t\t\telse dep[y] = -1;\t\t\t}\t\t\tif(!deg[y]) {Q.push(y); if(dep[y] == 0) dep[y] = 1;}\t\t}\t}\tvector&lt;int&gt; Ans;\tfor(int i = 1;i &lt;= n;i++)\t\tif(dep[i] == -1) Ans.push_back(i);\tprintf(\"%lu\\n\",Ans.size());\tfor(auto i : Ans) printf(\"%d \",i);\tprintf(\"\\n\");}int main(){\tint T;\tcin &gt;&gt; T;\twhile(T--) Work();\treturn 0;}\r\n","tags":["graph theory"]},{"title":"Backward Induction 相关总结","url":"/posts/384412733/","content":"Backward Induction ，译为逆向归纳法，常用于在有向图上做带环的 DP\r\n与博弈，是一个很有用的技巧。 \r\n这种方法常用于，你要对每个点维护一个状态 ，而  由后继  推得的时候。\r\n直接考虑环并不好做，我们先从简单的情况开始归纳，即  没有出边的情况，这一般很简单。\r\n然后对反图做类似拓扑排序 / dijkstra 的 DP，让  一步一步更新 ，在队列/堆中存储已经确定的 。\r\n有向图博弈\r\n有向图博弈，有环，那么就肯定存在平局。\r\n要让博弈进行下去，肯定是有一方希望平局，另一方不希望平局。\r\n先 DP 出每个状态是否为平局，再导出每个点的胜负状态即可。\r\nDP\r\n平局较为容易，没有出边肯定不是平局，对于希望平局的一方，后继有平则平，对于不希望平局的一方，后继有不平则不平，记录每个点在原图上的出度\r\n，在原图上做拓扑排序式的 DP\r\n即可。\r\n怎么导出胜负状态呢？\r\n我们一般会记录 ，表示\r\n 为起点，\r\n先手，能到达多少个非平局后继。这样我们就可以在 DP 过程中判别，  的非平局后继是否都已经被确定。\r\n如果 \r\n的非平局后继都已经被确定，将其加入队列 /\r\n堆等数据结构，更新其它点即可。\r\n第一道例题\r\n洛谷 P6970\r\nAlice : 先平再赢后输\r\nBob : 先赢再输后平\r\n我们先 DP 出  表示以\r\n 为起点， 先手，是否为平局。\r\n讲一下 DP 过程中的细节：\r\n我们一开始将无出度节点的 \r\n置为 ，其余点的  均置为 。\r\n维护一个队列 ，里面只会存放非平局的状态。\r\n取出队头 ，取出\r\n 的前驱 。\r\n如果 ，那么对应的， 那里是 Bob 先手，既然 Bob\r\n不喜欢平局， 肯定为 ，更新并入队即可。\r\n如果 ，那么对应的， 那里是 Alice 先手，那得  的所有后继均为非平局， 才是非平局，所以碰到 ，就把 ，什么时候减到\r\n 了，就更新并入队。\r\nfor(int i = 1;i &lt;= n;i++){\tdeg[i] = out[i];\tif(!deg[i]) Q.emplace(i,0),Q.emplace(i,1);\telse drw[i][0] = drw[i][1] = 1;}while(!Q.empty()){\tint x = Q.front().FI,tp = Q.front().SE; // 队列里只放非平局状态\tQ.pop();\tfor(auto y : Gr[x])        if((tp == 0 &amp;&amp; drw[y][1]) || (tp == 1 &amp;&amp; !--deg[y]))\t \t\tdrw[y][tp ^ 1] = 0,Q.emplace(y,tp ^ 1);}\r\n然后对非平局状态 DP 出胜负即可，这个比较容易。\r\n这题还有一个特殊情况，就是对于一些非平局状态，其在上一轮的 DP\r\n中并没有确定胜负态。\r\n对于 Bob 来说，这体现为该点在某个环上，后继有 Alice\r\n的必胜与平局，在所有已经确定的状态都转移完之后，这些状态没有被转移到（因为在环上有相邻的点是非平局，导致无法进入这个环，因为相邻点的状态始终无法确定）。\r\n那么这些点在环上，但为什么不是平局呢？\r\n只有可能是 Bob 没法赢，但由不想平局，所以选择了输，特判这些点为 Alice\r\n胜 Bob 败即可。\r\nfor(int i = 1;i &lt;= n;i++)\t{\t\tdeg[i] = out[i];\t\tif(!deg[i]) Q.emplace(i,0),Q.emplace(i,1);\t\telse F[i][0] = F[i][1] = -1;\t\tfor(auto v : G[i])\t\t\tD[i][0] += !drw[v][1],D[i][1] += !drw[v][0];\t}\twhile(!Q.empty())\t{\t\tint x = Q.front().FI,tp = Q.front().SE;Q.pop(); // 做出非平局状态的输赢\t\tfor(auto y : Gr[x]) \t\t\tif(!drw[y][tp ^ 1]) // 目标状态非平局\t\t\t{\t\t\t\tif(F[x][tp]) { if(!--D[y][tp ^ 1]) Q.emplace(y,tp ^ 1),F[y][tp ^ 1] = 0;}\t\t\t\telse {if(F[y][tp ^ 1] == -1) Q.emplace(y,tp ^ 1),F[y][tp ^ 1] = 1;}\t\t\t} \t}\tfor(int i = 1;i &lt;= n;i++) // 特判上述情况\t{\t\tif(F[i][0] == -1) F[i][0] = 1;\t\tif(F[i][1] == -1) F[i][1] = 0;\t}\r\n有向图 DP\r\n与有向图博弈的流程大同小异，先考虑没有出度的点，再使用类似 Dijkstra\r\n的方式维护转移即可。\r\n第一道例题\r\nAtCoder\r\nBeginning Contest 261 H\r\n这道题是个博弈与 DP 结合的题，放在这里比较合适。\r\n容易发现，Aoki 当然会尽量促成 \"INFINITY\"。\r\n设  表示以  为起点，Takahashi/Aoki\r\n先手的最终得分，初始时 。\r\n对于没有出度的点，，将其加入堆。\r\n有转移：  事实上，我们可以直接把平局的情况并入上述的转移。\r\n如果有一个  有值，那么\r\n 就肯定有值。\r\n如果所有的  有值，那么\r\n 才会有值。\r\n上述的有值就是不为 \r\n的情况。\r\n以上述规则转移即可。\r\n在这里，我们维护可用状态用的是小根堆，这与 dijkstra\r\n是本质相同的，我们只会从小的 DP 值转移到大的 DP\r\n值，什么时候一个状态从堆中被弹出了，那它就已经确定了，因为比它小的 DP\r\n值已经都被弹出，所有能更新它的转移都已经做完了。\r\n如果还使用队列的话，那么这就与 SPFA\r\n本质相同，你就无法在每个状态第一次出队时确定它，而是需要若干次松弛，直到状态收敛，这样就无法保证复杂度了。\r\n#include &lt;bits/stdc++.h&gt;#define FI first#define SE secondusing namespace std;typedef long long ll;const int N = 2e5 + 5;int n,m,s;vector&lt;pair&lt;int,int&gt; &gt; G[N],Gr[N];ll f[N][2];int out[N][2];struct node{\tint x,tp;\tll val;\tnode(){}\tnode(const int _x,const int _tp,const ll _val):\t\tx(_x),tp(_tp),val(_val){}\tbool operator &lt; (const node &amp;rhs) const { return val &gt; rhs.val;}};priority_queue&lt;node&gt; Q;int deg[N][2];int vst[N][2];inline void Dijk(){\twhile(!Q.empty())\t{\t\tint x = Q.top().x,tp = Q.top().tp;\t\t// if(Q.top().val != f[x][tp]) { Q.pop();continue;}\t\tQ.pop();\t\tif(vst[x][tp]) continue;\t\tvst[x][tp] = true;\t\tfor(auto it : Gr[x])\t\t{\t\t\tint y = it.FI,w = it.SE;\t\t\tif(tp == 0) f[y][1] = max(f[y][1],f[x][0] + w);\t\t\tif(tp == 1) f[y][0] = min(f[y][0],f[x][1] + w);\t\t\tdeg[y][tp ^ 1]--;\t\t\tif(!deg[y][tp ^ 1]) Q.push(node(y,tp ^ 1,f[y][tp ^ 1]));\t\t\telse if(tp == 1) Q.push(node(y,0,f[y][0])); // 对于先手而言，只要一个转移边有值就可以更新\t\t}\t}}int main(){\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\tfor(int i = 1;i &lt;= m;i++)\t{\t\tint a,b,c;\t\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\t\tGr[b].emplace_back(a,c);\t\t++deg[a][0];++deg[a][1];\t}\tfor(int i = 1;i &lt;= n;i++)\t\tf[i][0] = 9e18;\tfor(int i = 1;i &lt;= n;i++)\t\tif(!deg[i][0])\t\t{\t\t\tQ.push(node(i,0,f[i][0] = 0));\t\t\tQ.push(node(i,1,f[i][1] = 0));\t\t}\tDijk();\tif(!vst[s][0]) puts(\"INFINITY\");\telse cout &lt;&lt; f[s][0] &lt;&lt; endl;\treturn 0;}\r\n当然，也是可以先按照上文的方法 DP\r\n出每个状态是否平局，然后用优先队列转移非平局状态。\r\n第二道例题\r\n洛谷 P4042\r\n这题，令  表示消灭  号怪兽的最小代价，那么有 \r\n因为这题每个状态都最终会有个确定的值，并不需要像上一题一样加入特殊的转移规则，转移比较普通。\r\n也是因此，我们可以等到每个点的后继均被确定，再将其入队，事实上，这样每个点只会被入队一次。\r\n因为不确定要让哪些点的 DP 值取到 ，我们一开始将所有  入队即可。\r\n每个点算上最开始的一次入堆，最多被入堆两次，时间复杂度为 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5,M = 1e6 + 5;typedef long long ll;int n,R[N];ll S[N],K[N];vector&lt;int&gt; G[N];ll dp[N];struct node{\tint id;ll val;\tnode(){}\tnode(const int _id,const ll _val):id(_id),val(_val){}\tbool operator &lt; (const node &amp;rhs) const { return val &gt; rhs.val;}};priority_queue&lt;node&gt; Q;int vst[N];ll ans[N];int main(){\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tcin &gt;&gt; S[i] &gt;&gt; K[i];\t\tint k;\t\tcin &gt;&gt; k;R[i] = k;\t\tfor(int j = 1,x;j &lt;= k;j++)\t\t\tcin &gt;&gt; x,G[x].push_back(i);\t}\tfor(int i = 1;i &lt;= n;i++)\t{\t\tdp[i] = S[i]; // 维护 S[i] + \\sum dp_j\t\tQ.push(node(i,K[i]));\t}\twhile(!Q.empty())\t{\t\tint x = Q.top().id;\t\tll val = Q.top().val;\t\tQ.pop();\t\tif(vst[x]) continue;\t\tvst[x] = true;ans[x] = val;\t\tfor(auto y : G[x])\t\t{\t\t\tif(vst[y] || dp[y] &gt; K[y]) continue;\t\t\tR[y]--;dp[y] += val;\t\t\tif(!R[y]) Q.push(node(y,dp[y]));\t\t}\t}\tcout &lt;&lt; ans[1] &lt;&lt; endl;\treturn 0;}\r\n这种在有向图上的 DP 有一个共性：由小的 DP 值转移到大的 DP\r\n值，所以用小根堆维护当前可用的状态即可。\r\n这与 dijkstra\r\n的正确性是本质相同的，事实上，最短路问题也可以看作在有环图上的最优化\r\nDP。\r\n第三道例题\r\n[CCO2021] Travelling\r\nMerchant\r\n设  表示从 \r\n出发，至少需要多少资产可以一直走下去，可以写一个转移： 。\r\n还是考虑没有出度的点，显然 \r\n为 ，答案为 。\r\n如果不断删去出度为 \r\n的点，最后剩下的点一定是有答案的（即在环上的点）\r\n读者从前面的题可以发现，对于这种有环的\r\nDP,我们可以考察答案的界，来看看答案会收敛成什么样子。\r\n我们考虑这些点的答案上界。\r\n显然，取出当前最大的 ，那么如果你初始有 \r\n的资产，那就可以通行全图，因为资产不会减少。\r\n取出这条边的起点 ，并将  对  取 ，再删掉这条边。\r\n如果删完之后这条边已经没有出边了，说明 \r\n已经确定，可以拿来更新其它的点，将其放入一个队列。\r\n跑类似上文的 DP\r\n即可，一边松弛答案，一边观察目标点的后继是否全被删空，要注意，给每条边打个标记，使得每条边只被删一次。\r\n在寻常的 Backward DP\r\n中，打标记并不是必要的，一来每个状态入队不一定只有一次（比如上一道题），二来不打标记也只会对常数造成影响。\r\n但是这道题中，我们要一边找当前 \r\n最大的边，一边去做 Backward DP 来更新 \r\n数组，为了让这两个过程不重复统计，我们对每条边打了个删除标记。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n,m;struct Edge{\tint a,b,r,p;\tEdge(){}\tEdge(const int _a,const int _b,const int _r,const int _p):\t\ta(_a),b(_b),r(_r),p(_p){}\tbool operator &lt; (const Edge &amp;rhs) const { return r &gt; rhs.r;}};Edge p[N];vector&lt;int&gt; G[N];queue&lt;int&gt; Q;bool vst[N];int out[N];int ans[N];int main(){\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1;i &lt;= m;i++)\t\tcin &gt;&gt; p[i].a &gt;&gt; p[i].b &gt;&gt; p[i].r &gt;&gt; p[i].p;\tsort(p + 1,p + m + 1);\tfor(int i = 1;i &lt;= m;i++)\t\tG[p[i].b].push_back(i);\tfor(int i = 1;i &lt;= m;i++)\t\t++out[p[i].a];\tfor(int i = 1;i &lt;= n;i++)\t\tans[i] = 2e9;\tfor(int i = 1;i &lt;= n;i++)\t\tif(!out[i]) Q.push(i);\tfor(int i = 1;i &lt;= m;i++)\t{\t\twhile(!Q.empty())\t\t{\t\t\tint x = Q.front();Q.pop();\t\t\tfor(auto id : G[x])\t\t\t{\t\t\t\tif(vst[id]) continue;\t\t\t\tint y = p[id].a;\t\t\t\tvst[id] = true;\t\t\t\t--out[y];\t\t\t\tif(ans[x] &lt; 2e9) ans[y] = min(ans[y],max(p[id].r,ans[x] - p[id].p));\t\t\t\tif(!out[y])\t\t\t\t\t\tQ.push(y);\t\t\t\t\t\t\t}\t\t}\t\tif(vst[i]) continue;\t\tans[p[i].a] = min(ans[p[i].a],p[i].r);\t\tvst[i] = true;\t\t--out[p[i].a];\t\tif(!out[p[i].a]) Q.push(p[i].a);\t}\tfor(int i = 1;i &lt;= n;i++)\t\tif(ans[i] &gt;= 2e9) printf(\"-1 \");\t\telse printf(\"%d \",ans[i]);\tprintf(\"\\n\");\treturn 0;}\r\n","tags":["graph theory"]},{"title":"ARC118E 题解","url":"/posts/1021998316/","content":"这题，我和王队一共看了一个小时，王队一句话让我突然想到了状态和相关的转移，然后花了半天把它写完。事实上我们都想到了这题的大部分解法。\r\n\r\n如果排列确定了，很容易有个  的 DP,设  表示当前走到点  的方案数，转移不再赘述。\r\n现在排列不确定了，我们枚举排列去计数路径是十分困难的，那反过来考虑，考察一条路径能贡献多少个排列。\r\n那现在假设路径确定了，我们要绕开这条路径来填充排列。\r\n“所有点都不经过”是十分困难的，我们可以钦定 有  个点被经过，容斥系数为 。\r\n需要注意的是，对于已经确定的 ，其带来的限制是 \"第  行和第  列不能再有障碍被钦定\" 且 ” 不能被经过“，换言之，我们所“钦定”\r\n的，都是那些 \r\n的位置，对于已经确定的 ，我们只是把它当成一个确定的障碍，不将其纳入容斥的部分。\r\n设一共有  个位置满足 。\r\n那么就容易设出状态  表示当前走到了\r\n ，一共钦定了  个障碍的方案数之和。（后面两个  表示第  行与第  列是否已经被钦定过了障碍。\r\n那么分类讨论 \r\n处钦定障碍或不钦定障碍转移即可。\r\n最后的答案是 。\r\n上文中  的容斥系数在 DP\r\n转移中顺带处理了。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e2 + 5,P = 998244353;inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}int f[N][N][N][4];int n,p[N],fac[N],num = 0,vst[N];int main(){\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++) \t\tcin &gt;&gt; p[i],num += p[i] == -1;\tfor(int i = 1;i &lt;= n;i++)\t\tif(p[i] != -1) vst[p[i]] = true;\tp[n + 1] = -1;\tfor(int i = 0;i &lt;= n + 1;i++)\t\tf[0][i][0][0] = f[i][0][0][0] = 1;\tfor(int i = 1;i &lt;= n + 1;i++)\t\tfor(int j = 1;j &lt;= n + 1;j++)\t\t\tfor(int k = 0;k &lt;= min(i,j);k++)\t\t\t{\t\t\t\tif(p[i] != j) // (i,j) 不放障碍\t\t\t\t{\t\t\t\t\tPlus(f[i][j][k][1],f[i - 1][j][k][1]);\t\t\t\t\tPlus(f[i][j][k][1],f[i - 1][j][k][3]);\t\t\t\t\tPlus(f[i][j][k][2],f[i][j - 1][k][2]);\t\t\t\t\tPlus(f[i][j][k][2],f[i][j - 1][k][3]);\t\t\t\t\tPlus(f[i][j][k][0],f[i - 1][j][k][0]);\t\t\t\t\tPlus(f[i][j][k][0],f[i - 1][j][k][2]);\t\t\t\t\tPlus(f[i][j][k][0],f[i][j - 1][k][0]);\t\t\t\t\tPlus(f[i][j][k][0],f[i][j - 1][k][1]);\t\t\t\t}\t\t\t\t\tif((p[i] == -1) &amp;&amp; !vst[j] &amp;&amp; k) //(i,j) 放障碍\t\t\t\t{\t\t\t\t\tPlus(f[i][j][k][3],P - f[i - 1][j][k - 1][0]);\t\t\t\t\tPlus(f[i][j][k][3],P - f[i - 1][j][k - 1][2]);\t\t\t\t\tPlus(f[i][j][k][3],P - f[i][j - 1][k - 1][0]);\t\t\t\t\tPlus(f[i][j][k][3],P - f[i][j - 1][k - 1][1]);\t\t\t\t}\t\t\t}\tfac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tint ans = 0;\tfor(int k = 0;k &lt;= num;k++)\t{\t\tint res = f[n + 1][n + 1][k][0];\t\tPlus(ans,1ll * res * fac[num - k] % P);\t}\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n总的来说，这是道计数练手好题。\r\n","tags":["counting","inclusion-exclusion"]},{"title":"CF704B 题解","url":"/posts/606539281/","content":"这是道充分体现了水淹笛卡尔树这个模型的应用的好题。\r\n类似题目：洛谷 P5999，ARC117E\r\n\r\n观察这题的权值函数，与排列的相邻元素有关，与元素的大小关系有关。\r\n而笛卡尔树，它的中序遍历记录了位置相关信息，它的拓扑序记录了权值相关信息。\r\n而水淹笛卡尔树，就是一类在笛卡尔树上按层/权值 DP 的思路。\r\n往往我们并不需要显式地说明笛卡尔树的构型，也有些时候，这类题目可以不用笛卡尔树来理解。\r\n既然是按权值 DP ，我们考虑从小到大插入每个数 。\r\n在 \r\n之前，已经插入的数会形成若干个连续段，这些数的贡献是已经计算了的，我们只需知道\r\n 与两侧数的大小关系，即可计算\r\n 的贡献。\r\n在写方程之前，重写一下题目所给的量：。\r\n那么 \r\n考察  的转移：\r\n先考虑  的情况：\r\n\r\n 把已有的两段接起来，在\r\n 时转移，显然  两侧的数小于 ，那么  的贡献就是 ，则有转移 。\r\n\r\n新开一段，那么它周围的两个数都大于它，在  且 \r\n时无法转移：\r\n。\r\n 接在某一段的左边，在  且  时无法转移：\r\n。\r\n 接在某一段的右边，在  且  时无法转移：\r\n。\r\n\r\n在  或 \r\n时，新开一段或接在某一段边上即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e3 + 5;typedef long long ll;template&lt;typename T&gt; inline void ckmin(T &amp;x,const T &amp;y) { if(x &gt; y) x = y;}ll f[2][N];int n,s,t;int X[N],a[N],b[N],c[N],d[N];int main(){\tcin &gt;&gt; n &gt;&gt; s &gt;&gt; t;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; X[i];\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i],a[i] += X[i];\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; b[i],b[i] -= X[i];\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; c[i],c[i] += X[i];\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; d[i],d[i] -= X[i];\tmemset(f,0x3f,sizeof f);\tf[0][0] = 0;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tmemset(f[i&amp;1],0x3f,sizeof f[i&amp;1]);\t\tif(i != s &amp;&amp; i != t)\t\t\tfor(int j = 0;j &lt; i;j++)\t\t\t{\t\t\t\tll val = f[(i-1)&amp;1][j];\t\t\t\tif((i &lt; max(s,t)) || j &gt; 1) ckmin(f[i&amp;1][j + 1],val + b[i] + d[i]); // 新开一段\t\t\t\tif(j &gt; 1) ckmin(f[i&amp;1][j - 1],val + a[i] + c[i]);\t\t\t\tif(j &gt; 0 &amp;&amp; (j &gt; 1 || i &lt; s)) ckmin(f[i&amp;1][j],val + c[i] + b[i]);\t\t\t\tif(j &gt; 0 &amp;&amp; (j &gt; 1 || i &lt; t)) ckmin(f[i&amp;1][j],val + a[i] + d[i]);\t\t\t}\t\tif(i == s)\t\t\tfor(int j = 0;j &lt; i;j++)\t\t\t{\t\t\t\tll val = f[(i-1)&amp;1][j];\t\t\t\t// 新开一段或贴在左边\t\t\t\tckmin(f[i&amp;1][j+1],val + d[i]);\t\t\t\tif(j &gt; 0) ckmin(f[i&amp;1][j],val + c[i]);\t\t\t}\t\tif(i == t)\t\t\tfor(int j = 0;j &lt; i;j++)\t\t\t{\t\t\t\tll val = f[(i-1)&amp;1][j];\t\t\t\tckmin(f[i&amp;1][j+1],val + b[i]);\t\t\t\tif(j &gt; 0) ckmin(f[i&amp;1][j],val + a[i]);\t\t\t}\t}\tcout &lt;&lt; f[n&amp;1][1] &lt;&lt; endl;\treturn 0;}\r\n","tags":["DP"]},{"title":"一种最长反链的构造方法","url":"/posts/4267914291/","content":"下文简述在偏序集上构造最长反链的一种方法。\r\n\r\n（实际上就是从 [CTSC2008] 祭祀 的题解区抄来的）。\r\n首先，根据 Dilworth 定理，最长反链等于最小不可重链覆盖。\r\n求最小链覆盖有个经典的拆点二分图做法，就是把每个点拆成两个点 。然后对于原图的边 ，连边 。然后跑二分图最大匹配，一个关于\r\n\r\n点的匹配相当于给一个点找前驱，一个关于  点的匹配相当于给一个点找后继。\r\n那么最小链覆盖就是  -\r\n拆点二分图的最大匹配。\r\n接下来，我们尝试从这个匹配中，构造出最长反链。\r\n我们先构造二分图最大独立集。\r\n首先引入最小点覆盖：选出一个最小的点集，使得每条边的两端都有至少一个点被选中。\r\n因为二分图最大独立集等于最小点覆盖的补（因为最小点覆盖不会出现一条边两端都没有点，等价于最大独立集中不会出现一条边两端都有点），这等价于构造最小点覆盖。\r\n而最小点覆盖等于最大匹配。\r\n因为最小点覆盖肯定大于等于最大匹配（匹配边的两端必须至少选一个点），我们接下来给出一种点覆盖使得其大小等于最大匹配。\r\n考虑从右侧的每个非匹配点开始\r\nDFS，右部点只能走非匹配边向左访问，左部点只能走匹配边向右访问。\r\n我们取出左侧被 DFS 到的点和右侧没被 DFS\r\n到的点，就构成了一个点覆盖。\r\n下文证明这是一个合法点覆盖，且大小等于最大匹配：\r\n\r\n合法性\r\n对于右侧被 DFS 到的所有点，与其相邻的左侧点肯定也被 DFS\r\n到了，这个可以根据这个右部点是否有匹配来讨论证明。\r\n我们取出的是左侧被搜到的和右侧没被搜到的，基于上述事实，每条边都会被覆盖。\r\n大小等于最大匹配\r\n因为右侧的非匹配点肯定都被搜到了，在右侧选取的一定是匹配点。\r\n如果一个右侧的匹配点被搜到了，那与其匹配的左部点肯定也被搜到了，那么它的匹配点就会被选上。\r\n上述两个事实表明：每条匹配边的端点恰好选一个。\r\n而左侧的非匹配点肯定不会被搜到，因为如果被搜到了，在 DFS\r\n的过程中就会形成一条增广路，与最大匹配矛盾。\r\n\r\n我们取最小点覆盖的补就得到了最大独立集。也就是左侧没被 DFS\r\n到的点和右侧被 DFS 到的点。\r\n然后考虑怎么求出最长反链。\r\n我们对于原图所有点 ，取出  与 \r\n都在二分图独立集的点，就得到了最长反链。\r\n显然这是一个合法的反链，大小也与 Dilworth 指出的结果相符。\r\n先记下来，以后应该用得上。\r\n","tags":["graph matching"]},{"title":"CF1782F Bracket Insertion 题解","url":"/posts/2615667224/","content":"打的时候在错误的思路上卡了半个小时，以至于最后 10\r\n分钟想到了正解，但已经没时间写了。\r\n赛后把这题改过了，比改错了还难受。\r\n\r\n考虑最终形成的序列满足什么条件。\r\n我们不妨把第 \r\n次插入的两个字符编号为 。\r\n那么会形成 \r\n之类的结构，但一定不会有 （交错），也不会有  (大包小）\r\n这其实是一个类似树的结构，跟括号树其实长得差不多，我们如果按包含关系建树（在上述例子中， 就是  的儿子，如果有  那  就是 \r\n的儿子），那么问题实际上被分成两部分：\r\n\r\ndp 这棵树以及节点上的状态，使得最终的括号串合法。\r\n处理插入顺序，使得父亲比儿子先插入。\r\n\r\n第二部分就是一个树的拓扑序，处理是容易的，下文再讲。\r\n考虑第一部分。\r\n这种对有包含关系区间 的\r\nDP（或者说对类似这种“括号树”的 DP),其实就是区间  ，如果区间  是一个节点，我们枚举断点 \r\n相当于枚举这个节点最靠左的儿子。而在本题中，我们其实只要记录区间长度（或者说区间内有几对括号）即可。\r\n有个经典结论是，把 ( 看作 1,把 ) 看作\r\n-1,那么一个括号串能够匹配，当且仅当这个串的所有前缀和都非负且左右括号数目相等。\r\n那我们不妨把这个前缀和的最小值记录进  状态，容易发现这个值 。\r\n设  表示序列长度为 ，最小前缀和为  的方案数（另一种解释是在序列两边添加\r\n 对括号才能使其合法）\r\n，那么会有转移。\r\n$$\r\n\r\n$$\r\n上文的  是题目中的 ，\r\n相当于枚举跟 \r\n一起被插入的是哪个位置，相当于枚举树上最靠左的儿子，而组合数是为了安排插入的顺序。\r\n直接实现上述转移是 \r\n的，注意到问题可以被转化成  这种形式，使用前缀和优化，分类讨论  和  转移即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e2 + 5,P = 998244353;inline int qpow(int a,int b) { int res = 1;while(b) {if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;} return res;}inline void Plus(int &amp;a,const int &amp;b) { a += b;if(a &gt;= P) a -= P;}int n,pro;int f[N][N];int fac[N],ifac[N];inline void init(int n){\tfac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tifac[1] = 1;\tfor(int i = 2;i &lt;= n;i++) ifac[i] = 1ll * (P - P / i) * ifac[P % i] % P;\tifac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) ifac[i] = 1ll * ifac[i - 1] * ifac[i] % P;}inline int C(int n,int m) { return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;}int g[N],h[N];int main(){\tcin &gt;&gt; n &gt;&gt; pro;\tinit(n);\tpro = 1ll * pro * qpow(10000,P - 2) % P;\tf[0][0] = 1;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tfor(int k = 0;k &lt; i;k++)\t\t{\t\t\tint r = i - k - 1;\t\t\tmemset(g,0,sizeof g);\t\t\tmemset(h,0,sizeof h);\t\t\tfor(int s1 = 0;s1 &lt;= k;s1++)\t\t\t\tPlus(g[max(s1 - 1,0)],1ll * f[k][s1] * C(i,k + 1) % P * pro % P),\t\t\t\tPlus(g[s1 + 1],1ll * f[k][s1] * C(i,k + 1) % P * (P + 1 - pro) % P);\t\t\tfor(int s2 = 0;s2 &lt;= r;s2++)\t\t\t\th[s2] = f[r][s2];\t\t\tfor(int s1 = 1;s1 &lt;= i;s1++)\t\t\t\tPlus(g[s1],g[s1 - 1]);\t\t\tfor(int s2 = 1;s2 &lt;= i;s2++)\t\t\t\tPlus(h[s2],h[s2 - 1]);\t\t\tfor(int v = 0;v &lt;= i;v++)\t\t\t{\t\t\t\tint res = 1ll * g[v] * f[r][v] % P;\t\t\t\tif(v &gt; 0) Plus(res,1ll * (g[v] - g[v - 1] + P) % P * h[v - 1] % P);\t\t\t\tPlus(f[i][v],res);\t\t\t}\t\t}\t}\tint ans = f[n][0];\tfor(int i = 3;i &lt; 2 * n;i += 2)\t\tans = 1ll * ans * qpow(i,P - 2) % P;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n其实不是很难的一道题。可以用来练习计数，提升竞技状态。\r\n但这场 E 好垃圾啊（\r\n","tags":["counting"]},{"title":"CF1792F2 题解（以及一种分治 FFT）","url":"/posts/1707382016/","content":"这题推出平方的转移式不难，但是进一步优化需要技巧。\r\n\r\n首先把 ”不全红“ 和”不全蓝“的限制去掉。\r\n其次，对于一个完全图，它如果不 红边连通，蓝边连通。\r\n这个证明是容易的，假设一个完全图有两个点集 ， 与  之间没有红边，那么对于任意 ，，\r\n之间都会有一条蓝边，那么这个图显然会被蓝边连通。\r\n那我们只需要保证红蓝不同时连通即可。\r\n设  表示一个  个点的完全图由红边连通的方案数，那么\r\n。\r\n考虑转移，既然这张图蓝边不连通，那么我们枚举  号点所在的蓝边连通块大小，设为 ，那么会有 \r\n种方案选出这个连通块，块内的方案数是 ，块外的方案数是 \r\n，块内与块外之间的边必须都是红边，故系数为 。另外，如果 ，方案数还要乘 ，因为块外的图既可以红连通，也可以蓝连通。\r\n直接转移即可通过 F1。\r\n考虑优化转移的复杂度，把转移式写出来。  写得好看一些：  令  那么 。\r\n把组合数拆开：  设 。\r\n那么 \r\n这看上去就像分治 FFT 的式子，但我们发现  和  都需要由卷积的结果推出，而一般的分治\r\nFFT 中，\r\n这个位置放的是个已知序列。\r\n考虑一般的分治 FFT,我们是用  与 \r\n进行卷积，并将结果加到右区间对应的位置。\r\n考虑这个方法什么时候会出问题，这种情况会出现当且仅当  ，即 ，即 。\r\n这种情况只会在 \r\n时出现，因为在分治树上第一次往右走时，就有 ，此后 \r\n不降，\r\n不增，自然也不会出问题。\r\n考虑把分治 FFT 的贡献拆成三部分：  第一部分的贡献可以在 \r\n那里就算完了，第二部分和第三部分的贡献形式是相同的，可以在  的区间里一起计算这两类贡献。\r\n具体的可以看代码，时间复杂度 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5,P = 998244353,GG = 3;inline int Add(const int &amp;a,const int &amp;b) { return (a + b &gt;= P) ? (a + b - P) : (a + b);}inline int Sub(const int &amp;a,const int &amp;b) { return (a &lt; b) ? (a - b + P) : (a - b);}inline int qpow(int a,int b) { int res = 1;while(b) {if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;} return res;}const int Gi = qpow(GG,P - 2);int n;int Gs[N],Gs2[N],rev[N];inline int GetLen(int x){\tint len = 1;\twhile(len &lt;= x) len &lt;&lt;= 1;\treturn len;}inline void calc_rev(int len){\tfor(int i = 0;i &lt; len;i++)\t{\t\trev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1;\t\tif(i &amp; 1) rev[i] |= len &gt;&gt; 1;\t}}int fac[N],ifac[N];inline void init(int len){\tfor(int i = 1;i &lt; len;i &lt;&lt;= 1)\t{\t\tGs[i] = Gs2[i] = 1;\t\tGs[i + 1] = qpow(GG,(P - 1) / (i &lt;&lt; 1));\t\tGs2[i + 1] = qpow(Gi,(P - 1) / (i &lt;&lt; 1));\t\tfor(int j = 2;j &lt; i;j++)\t\t\tGs[i + j] = 1ll * Gs[i + j - 1] * Gs[i + 1] % P,\t\t\tGs2[i + j] = 1ll * Gs2[i + j - 1] * Gs2[i + 1] % P;\t}\tfac[0] = 1;\tfor(int i = 1;i &lt;= len;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tifac[1] = 1;\tfor(int i = 2;i &lt;= len;i++) ifac[i] = 1ll * ifac[P % i] * (P - P / i) % P;\tifac[0] = 1;\tfor(int i = 1;i &lt;= len;i++) ifac[i] = 1ll * ifac[i - 1] * ifac[i] % P;}inline void NTT(int *F,int len,int type){\tfor(int i = 0;i &lt; len;i++)\t\tif(i &lt; rev[i]) swap(F[i],F[rev[i]]);\tfor(int k = 1;k &lt; len;k &lt;&lt;= 1)\t\tfor(int j = 0;j &lt; len;j += k + k)\t\t\tfor(int i = 0;i &lt; k;i++)\t\t\t{\t\t\t\tint cur = type == 1 ? Gs[k | i] : Gs2[k | i];\t\t\t\tint u = F[i | j],v = 1ll * cur * F[i | j | k] % P;\t\t\t\tF[i | j] = Add(u,v);\t\t\t\tF[i | j | k] = Sub(u,v);\t\t\t}\tif(type == -1)\t\tfor(int i = 0,Inv = qpow(len,P - 2);i &lt; len;i++)\t\t\tF[i] = 1ll * F[i] * Inv % P;}int A[N],B[N];int f[N],F[N],G[N];void cdq(int l,int r){\tif(l == r)\t{\t\tif(l &gt; 1)\t\t{\t\t\tf[l] = 2ll * f[l] * fac[l - 1] % P;\t\t\tf[l] = Sub(f[l],1ll * (l - 1) * f[l - 1] % P);\t\t\tF[l] = 1ll * f[l] * ifac[l - 1] % P;\t\t\tG[l] = 1ll * f[l] * ifac[l] % P;\t\t}\t\treturn;\t}\tint mid = l + r &gt;&gt; 1;\tcdq(l,mid);\tif(l == 1)\t{\t\tint len = GetLen((mid - l + 1) + (mid - l + 1)); // 第一部分\t\tfor(int i = 0;i &lt; len;i++) A[i] = B[i] = 0;\t\tfor(int i = 0;i &lt;= mid - l;i++)\t\t\tA[i] = F[i + 1],B[i] = G[i + 1];\t\tcalc_rev(len);\t\tNTT(A,len,1);NTT(B,len,1);\t\tfor(int i = 0;i &lt; len;i++) A[i] = 1ll * A[i] * B[i] % P;\t\tNTT(A,len,-1);\t\tfor(int i = mid + 1;i &lt;= r;i++)\t\t\tf[i] = Add(f[i],A[i - 2]);\t}\telse // 第二部分和第三部分\t{\t\tint len = GetLen((r - l + 1) + (mid - l + 1));\t\tfor(int i = 0;i &lt; len;i++) A[i] = B[i] = 0;\t\tfor(int i = 0;i &lt; r - l;i++)\t\t\tA[i] = F[i + 1];\t\tfor(int i = 0;i &lt;= mid - l;i++)\t\t\tB[i] = G[i + l];\t\tcalc_rev(len);\t\tNTT(A,len,1);NTT(B,len,1);\t\tfor(int i = 0;i &lt; len;i++) A[i] = 1ll * A[i] * B[i] % P;\t\tNTT(A,len,-1);\t\tfor(int i = mid + 1;i &lt;= r;i++)\t\t\tf[i] = Add(f[i],A[i - l - 1]);\t\tfor(int i = 0;i &lt; len;i++) A[i] = B[i] = 0;\t\tfor(int i = 0;i &lt; r - l;i++)\t\t\tA[i] = G[i + 1];\t\tfor(int i = 0;i &lt;= mid - l;i++)\t\t\tB[i] = F[i + l];\t\tcalc_rev(len);\t\tNTT(A,len,1);NTT(B,len,1);\t\tfor(int i = 0;i &lt; len;i++) A[i] = 1ll * A[i] * B[i] % P;\t\tNTT(A,len,-1);\t\tfor(int i = mid + 1;i &lt;= r;i++)\t\t\tf[i] = Add(f[i],A[i - l - 1]);\t}\tcdq(mid + 1,r);}int main(){\tcin &gt;&gt; n;\tf[1] = F[1] = G[1] = 1;\tint len = GetLen(n * 2);\tinit(len);\tcdq(1,n);\tcout &lt;&lt; ((f[n] - 1) * 2ll) % P &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting","poly"]},{"title":"ARC136E 题解","url":"/posts/4041047875/","content":"一开始把图想错了，想了 40 分钟。后来图画对了，但还是没想出来。\r\n正解的思想值得借鉴学习，不会挺正常的。\r\n对于稠密图的分析，可以先从特殊点、特殊边、特殊限制入手，从而掌握一类与这种点有关的性质。\r\n\r\n题意：给出一张有向图 ，每个点有点权 ， 中有边  当且仅当  ，求 \r\n权值和最大的反链的权值和。\r\n。\r\n这张图看着十分鬼畜，边非常多。\r\n正解是从  这个特殊数入手。\r\n我们发现所有的偶数都能够互相到达，即最多选一个偶数。\r\n接下来考虑那些奇数怎么选。\r\n那么我们就要研究 \r\n奇偶性确定的时候， 如何到达 。\r\n假设  是奇数， 是偶数。\r\n那么 \r\n可以先尝试一步变成偶数，然后直达 。\r\n设  为  的最小质因子，那么  显然是 \r\n能往前走到的最小的数，同时它显然是一个偶数！\r\n那么我们就可以得到此时  能到达\r\n 的充要条件：。\r\n类似的，如果  都是奇数，那\r\n 可达  当且仅当 。\r\n如果  为偶数， 为奇数，则条件为 。\r\n有了以上性质，就可以解决原问题了。\r\n假如我们选一个偶数 ，那么剩下的奇数  要满足下列两个条件中的一个：\r\n\r\n 且 \r\n 且 \r\n\r\n对于每个 ，我们都能用树状数组维护出满足条件的\r\n 之和。\r\n考虑全是奇数的情况，此时需要 ，可以枚举中间的一个分界点统计答案。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;namespace FastIO {\t#define iL (1 &lt;&lt; 20)\tchar ibuf[iL],*iS = ibuf + iL,*iT = ibuf + iL;\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf,1,iL,stdin),iS == iT ? EOF : *iS++) : *iS++)\ttemplate&lt;typename T&gt;\tinline void read(T &amp;a)\t{\t\tchar ch;int sign = 0;\t\tfor(ch = gc();!isdigit(ch);ch = gc())\t\t\tif(ch == '-') sign = 1;\t\ta = ch &amp; 15;\t\tfor(ch = gc();isdigit(ch);ch = gc())\t\t\ta = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch &amp; 15);\t\tif(sign) a = -a;\t}\tchar Out[iL],*iter = Out;\t#define flush() fwrite(Out,1,iter - Out,stdout),iter = Out\ttemplate&lt;typename T&gt;\tinline void write(T x,char end = '\\n')\t{\t\tint c[35],l = 0;if(x &lt; 0) *iter++ = '-',x = -x;\t\tdo c[++l] = x % 10,x /= 10; while(x);\t\twhile(l) *iter++ = c[l--] + '0';\t\t*iter++ = end;flush();\t}\t#undef iL \t#undef gc \t#undef flush}using namespace FastIO;const int N = 1e6 + 5;typedef long long ll;int n,a[N],p[N];struct BIT{\tll tr[N &lt;&lt; 1];\t#define lowbit(x) (x&amp;(-x))\tinline void upd(int x,int v) { for(int i = x;i &lt;= n + n;i += lowbit(i)) tr[i] += v;}\tinline ll Sum(int x) { ll res = 0;for(int i = x;i;i ^= lowbit(i)) res += tr[i];return res;}};BIT T1,T2;ll dif[N &lt;&lt; 1];int main(){\tread(n);\tfor(int i = 1;i &lt;= n;i++) read(a[i]);\tfor(int i = 2;i &lt;= n;i++)\t{\t\tif(p[i]) continue;\t\tfor(int j = i;j &lt;= n;j += i)\t\t\tif(!p[j]) p[j] = i;\t}\tfor(int i = 3;i &lt;= n;i += 2)\t\tT1.upd(i - p[i] + 1,a[i]);\tll ans = 0;\tfor(int i = 2;i &lt;= n;i++)\t\tif(i &amp; 1) T1.upd(i - p[i] + 1,-a[i]),T2.upd(i + p[i],a[i]);\t\telse ans = max(ans,a[i] + T2.Sum(n + n) - T2.Sum(i) + T1.Sum(i));\tfor(int i = 3;i &lt;= n;i += 2) dif[i - p[i] + 1] += a[i],dif[i + p[i]] -= a[i];\tfor(int i = 1;i &lt;= n + n;i++) dif[i] += dif[i - 1],ans = max(ans,dif[i]);\twrite(ans + a[1]);\treturn 0;}\r\n","tags":["thinking"]},{"title":"AGC038E 题解","url":"/posts/1354329816/","content":"这完全是能力范围内的题。日常做题时还是要多想一想，多尝试尝试，多用几种不同的解法，因为考场上没有看题解的机会。\r\n\r\n首先这题看上去就很 \r\n容斥，先套上去试一下。\r\n。\r\n考虑一个 \r\n该怎么算。\r\n首先， 内的问题无法完全与 \r\n外的独立开来，因为每次操作是在所有数之间进行的，这会涉及到一个条件概率的问题。\r\n这里有一个比较巧妙的转化，即 第一次到达停止状态的时间是\r\n所有到达停止状态之前的状态的概率乘上停留在该状态的期望时间\r\n之和（我们熟知的等式  就是在所有状态的期望停留时间均为  时的特例）。\r\n证明并不难，也与 \r\n的证明基本一致。（不过这一点倒是增进了我对这个式子的理解）。\r\n那么每个状态的期望停留时间怎么算？\r\n考虑什么时候会“停留”，即我们一次操作选到了集合  之外的点。\r\n显然这个量只与  有关。\r\n更具体地，设  表示集合  中某个状态的期望停留时间，设 ，那么会有  ，即 。\r\n考察另外一个部分，即到达某个状态的概率，设  表示  在该状态中的出现次数。\r\n那么概率就是  设 。\r\n那么将上式化简可得 。\r\n代入 \r\n的式子，那么原式可化为 \r\n中间两个分式只与  和  有关，而后面的  显然可以 DP。\r\n设  表示考察前  个数， 且  的  之和，转移如下：\r\n。\r\n因为第二维是个背包状物，故直接枚举  就可以做到  了。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4e2 + 5,P = 998244353;int n;int a[N],b[N];int fac[N],ifac[N];int f[N][N][N];inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}inline void Minus(int &amp;x,const int &amp;y) { x -= y;if(x &lt; 0) x += P;}inline int qpow(int a,int b) { int res = 1;while(b) {if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;} return res;}inline void init(int n){\tfac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tifac[1] = 1;\tfor(int i = 2;i &lt;= n;i++) ifac[i] = 1ll * (P - P / i) * ifac[P % i] % P;\tifac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) ifac[i] = 1ll * ifac[i - 1] * ifac[i] % P;}int sumA = 0,sumB = 0;int main(){\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i] &gt;&gt; b[i],sumA += a[i],sumB += b[i];\tinit(sumB);\tint sum = 0;\tf[0][0][0] = P - 1;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tfor(int j = a[i];j &lt;= sumA;j++)\t\t{\t\t\tfor(int k = 0;k &lt;= sum;k++)\t\t\t\tfor(int c = 0,now = 1;c &lt; b[i];++c)\t\t\t\t{\t\t\t\t\tMinus(f[i][j][k + c],1ll * f[i - 1][j - a[i]][k] * now % P * ifac[c] % P);\t\t\t\t\tnow = 1ll * now * a[i] % P;\t\t\t\t\t}\t\t}\t\tsum += b[i];\t\tfor(int j = 0;j &lt;= sumA;j++)\t\t\tfor(int k = 0;k &lt;= sum;k++)\t\t\t\tPlus(f[i][j][k],f[i - 1][j][k]);\t}\tint ans = 0;\tfor(int sa = 0;sa &lt;= sumA;sa++)\t\tfor(int sc = 0;sc &lt;= sumB;sc++)\t\t\tPlus(ans,1ll * fac[sc] * sumA % P * qpow(qpow(sa,P - 2),sc+1) % P * f[n][sa][sc] % P);\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting","min-max 容斥"]},{"title":"一类带负圈的最小费用流","url":"/posts/3143109410/","content":"之前复习网络流的时候好像没有复习扎实，把这玩意漏掉了。\r\n事实证明，“就看看而不写代码”确实挺容易忘的。\r\n\r\n注意：下文所讨论的流都允许一个与  不相连的环出现。\r\n下文的四元组 \r\n表示一条从  到 ，流量为 ，费用为  的边。\r\n一般不带负圈的最小费用流，大家使用自己喜欢的方式就跑过去了。\r\n但是带负圈的最小费用流，会给最短路算法带来极大的困难，导致增广出现问题。\r\n我们就需要一个办法，把图里的负权边都去掉。\r\n注意到我们在建网络流图的时候，会对称地建一条反着的边，费用为原边权的相反数，表示退流。\r\n那么我们在这里，能不能先把负权边都流满，然后借助反向的正权边来完成”退流“工作呢？\r\n显然是可以的。\r\n对于一条负权边 \r\n，我们先把该边流满，将答案预先加上 ，然后建出反向边 ，用以退流。\r\n但这种做法还有一个问题，即所有负权边满流的网络，不一定满足流量平衡的限制。\r\n设原图源汇为 ，我们新建虚拟源点、虚拟汇点 ，用 \r\n跑遍网络流，来满足流量平衡的限制。\r\n具体地，假设我们处理了一条负权边 ，那么  点就应该多流入  的流量， 点应该多流出  的流量，我们通过连边 \r\n来表达这两个限制，因为最后基于 \r\n跑出来的网络流是流量平衡的，我们把这里连的虚拟边删掉，就正好满足  点多流入 ，\r\n点多流出 。\r\n所以，对于一条负权边，我们会将其拆为三条边 。然后我们先以\r\n 为源点，\r\n为汇点，跑一遍网络流。在残量网络上，忽略与  和  相邻的边，再以  和 \r\n为源汇，跑一遍网络流，将两遍网络流得到的答案相加即可。\r\n需要注意的是，就算原图中没有源汇，这个方法也是可行的，此时这个问题被叫做最小费用循环流（或者说最小费用可行流）。\r\n此时，在原问题中，我们一次会增广一个环，假设这个环除了某条负权边\r\n 外，剩下的边费用为 。\r\n如果 ，那么这个负环需要增广，在新图上，有 \r\n那么我们会倾向与走剩下的那条路径，也就是不退流。反之，因为是正环，所以我们会倾向于不增广，在新图上就是走这条\r\n ，把流退掉。\r\n这样可以从另一个方面理解其正确性。\r\n需要注意的是，在求解循环流的时候，需要注意原题面有没有限制流量上界。有的话，在通过\r\n\r\n增广时就要加以限制。\r\n事实上，如果读者对上下界网络流较为熟悉，应该能看出来，这就是对上下界网络流的一种应用。\r\n附上模板题代码：\r\n洛谷 P7173\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e2 + 5;typedef long long ll;const ll llinf = 0x3f3f3f3f3f3f3f3f;int n,m,S,T;int num[N];namespace Flow{\tconst int N = 2e3 + 5,M = 2e6 + 5;\tint fir[N],nxt[M],to[M],w[M],cost[M],ect = 1;\tinline void addedge(int u1,int v1,int w1,int c1)\t { nxt[++ect] = fir[u1];fir[u1] = ect;to[ect] = v1;w[ect] = w1;cost[ect] = c1;}\tinline void ins(int u1,int v1,int w1,int c1) { addedge(u1,v1,w1,c1);addedge(v1,u1,0,-c1);}\tll dis[N],h[N];\tbool vst[N];\tint tot;\tinline void Clr(int _n)\t{\t\ttot = _n;ect = 1;\t\tfor(int i = 1;i &lt;= tot;i++) fir[i] = 0;\t}\tvoid spfa(int S,int T)\t{\t\tfor(int i = 1;i &lt;= tot;i++) dis[i] = llinf,vst[i] = 0;\t\tqueue&lt;int&gt; Q;\t\tQ.push(S);dis[S] = 0;vst[S] = 1;\t\twhile(!Q.empty())\t\t{\t\t\tint x = Q.front();Q.pop();vst[x] = 0;\t\t\tfor(int i = fir[x],y;y = to[i],i;i = nxt[i])\t\t\t\tif(w[i] &amp;&amp; dis[y] &gt; dis[x] + cost[i])\t\t\t\t{\t\t\t\t\tdis[y] = dis[x] + cost[i];\t\t\t\t\tif(!vst[y]) Q.push(y),vst[y] = true;\t\t\t\t} \t\t}\t\tfor(int i = 1;i &lt;= tot;i++) h[i] = dis[i];\t}\tint pn[N],pe[N],flow[N];\tstruct node{\t\tint id;ll dis;\t\tnode(){}\t\tnode(const int _id,const ll _dis):id(_id),dis(_dis){}\t\tbool operator &lt; (const node &amp;rhs) const { return dis &gt; rhs.dis;}\t};\tbool Dijkstra(int S,int T,int F = 1e9)\t{\t\tfor(int i = 1;i &lt;= tot;i++)\t\t\tpe[i] = pn[i] = vst[i] = 0,dis[i] = llinf;\t\tpriority_queue&lt;node&gt; Q;\t\tflow[S] = F;Q.emplace(S,dis[S] = 0);\t\twhile(!Q.empty())\t\t{\t\t\tint x = Q.top().id;Q.pop();\t\t\tif(vst[x]) continue;\t\t\tvst[x] = true;\t\t\tfor(int i = fir[x],y,ww;y = to[i],ww = cost[i] + h[x] - h[y],i;i = nxt[i])\t\t\t\tif(w[i] &amp;&amp; dis[y] &gt; dis[x] + ww)\t\t\t\t{\t\t\t\t\tdis[y] = dis[x] + ww;\t\t\t\t\tpn[y] = x;pe[y] = i;flow[y] = min(flow[x],w[i]);\t\t\t\t\tQ.emplace(y,dis[y]);\t\t\t\t}\t\t}\t\treturn dis[T] &lt; llinf;\t}\tpair&lt;ll,ll&gt; MCMF(int S,int T)\t{\t\tll F = 0,res = 0;\t\tspfa(S,T);\t\twhile(Dijkstra(S,T))\t\t{\t\t\tfor(int i = 1;i &lt;= tot;i++) if(vst[i]) h[i] += dis[i];\t\t\tint now = T;\t\t\tres += flow[T] * h[T];\t\t\twhile(now != S)\t\t\t\tw[pe[now]] -= flow[T],w[pe[now] ^ 1] += flow[T],now = pn[now];\t\t\tF += flow[T];\t\t}\t\treturn make_pair(F,res);\t}}ll ans = 0;int main(){\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;\tFlow::Clr(n + 2);\tfor(int i = 1;i &lt;= m;i++)\t{\t\tint x,y,f,c;\t\tcin &gt;&gt; x &gt;&gt; y &gt;&gt; f &gt;&gt; c;\t\tif(c &gt;= 0)\t\t\tFlow::ins(x,y,f,c);\t\telse\t\t{\t\t\tnum[x] -= f;num[y] += f;\t\t\tFlow::ins(y,x,f,-c);\t\t\tans += 1ll * c * f;\t\t}\t}\tint SS = n + 1,TT = n + 2;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tif(num[i] &gt; 0) Flow::ins(SS,i,num[i],0);\t\tif(num[i] &lt; 0) Flow::ins(i,TT,-num[i],0);\t}\tans += Flow::MCMF(SS,TT).second;\tpair&lt;ll,ll&gt; res = Flow::MCMF(S,T);\tcout &lt;&lt; res.first &lt;&lt; ' ' &lt;&lt; res.second + ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["graph theory","flow"]},{"title":"CF1575C 题解","url":"/posts/3953954419/","content":"赛时想着用卷积处理散块，但不知道如何避免重复统计的问题，赛后看到题解做法大受震撼，故记录一下。有时一个观察能帮你省掉很多东西。\r\n\r\n我们先考虑固定右端点 \r\n，计算所有左端点的答案。\r\n一个关键但显然的观察是， 和\r\n\r\n的答案是相同的，这意味着我们只需计算  的答案，最后把答案乘  即可。\r\n设 \r\n，即  序列的前缀和。如果  不大的话，我们大可以预处理出  表示满足  的  的个数。然后扫描  ，每次先让  减 ，再提取出  作为  的答案，再将  加  。容易发现，上述过程正确地统计了所有\r\n 和  的子段，可以手算验证。\r\n我们发现，上述做法的瓶颈在于，如何快速地预处理 。\r\n如果 ，处理起来比较容易。\r\n否则，我们希望对于每个 ，我们能把  的贡献一起加入到  中，即需要对于  ，令 \r\n自增 。事实上，考虑一张图，对于每个点 ，连边  ，最后会形成一个长度为  的环（因为 \r\n是质数），那么我们的操作相当于对环上连续的一段进行区间加。维护差分数组即可做到\r\n。\r\n事实上，对于 \r\n不是质数的情况，上述做法也是可行的，只不过可能会形成若干个环，我们要对每个环分开考虑。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5,P = 1e9 + 7;int n,m,k,sum[N];int cnt[N];int Id[N]; // 环上各点的编号int dif[N]; // 差分数组int main(){\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\tfor(int i = 1;i &lt;= n;i++)\t\tcin &gt;&gt; sum[i],(sum[i] += sum[i - 1]) %= k;\tint sall = 1ll * sum[n] * m % k;\tint sn = sum[n];\tif(!sn)\t{\t\tint res = 0;\t\tfor(int i = 1;i &lt;= n;i++) (res += cnt[sum[i]]++) %= P;\t\tint ans = (1ll * ((res &lt;&lt; 1ll) + n) % P * m % P * m % P - (1ll * n * m % P) + P + 1) % P;\t\tcout &lt;&lt; ans &lt;&lt; endl;\t\treturn 0;\t}\tId[0] = 1;\tfor(int i = sn,j = 2;i;i = (i + sn) % k,++j)\t\tId[i] = j;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tint vl = sum[i],vr = (sum[i] + 1ll * m * sn % k) % k; // [vl,vr)\t\tvl = Id[vl];vr = Id[vr];\t\t(dif[1] += m / k) %= P;\t\tif(vl &lt;= vr) dif[vl]++,dif[vr]--;\t\telse dif[vl]++,dif[1]++,dif[vr]--;\t}\tfor(int i = 1;i &lt;= k;i++)\t\t(dif[i] += dif[i - 1]) %= P;\t// for(int i = 1;i &lt;= n;i++) printf(\"%d \",sum[i]);printf(\"\\n\");\t// for(int i = 0;i &lt; k;i++) printf(\"%d \",Id[i]);printf(\"\\n\");\t// for(int i = 1;i &lt;= k;i++) if(dif[i]) printf(\"%d,%d \",i,dif[i]);printf(\"\\n\");\tint ans = 0;\t//(dif[Id[sall]] += 1) %= P;\tfor(int r = 1;r &lt;= n;r++)\t{\t\t\t(dif[Id[sum[r]]] += P - 1) %= P;\t\t(ans += dif[Id[(sum[r] + sall) % k]]) %= P;\t\t(dif[Id[(sum[r] + sall) % k]] += 1) %= P;\t}\tans = 1ll * ans * m % P;\tif(!sall) ans = (ans + 1) % P;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting"]},{"title":"CF1770G 题解（分治 NTT 在格路计数中的应用）","url":"/posts/2722203261/","content":"之前没有接触过这方面的应用（没想到分治 NTT\r\n这么强大），故记录一下。\r\n\r\n首先我们考虑一个格路计数模型，即从  出发，向右或向上走，要走到  ，但第  列只存在行数不大于  的点， 单调不降，且  ，求路径条数。\r\n上述的网格是个阶梯状的图形，用分治 NTT\r\n解决阶梯网格的格路计数是很经典的应用（虽然此前我从来没听说过）。\r\n首先考虑  DP，这是简单的，即\r\n。\r\n但是直接这么做很难优化，本质上是因为这个 DP\r\n没有明显的阶段性，即同一个 \r\n内的所有  都会互相转移。\r\n我们修改 DP 状态，第一维记录 ，第二维记录 \r\n，那么就会有 。\r\n为了避免在  的时候还会有\r\n 的限制，考虑从 \r\n开始沿左上-右下方向把阶梯网格劈成两半，计算从  和  走到这条斜对角上的点 （）\r\n的方案数，容易发现这两个问题是对称的。\r\n综合上述分析，我们将问题转化为，从 \r\n出发，每次可以向右或向右上走一步，且在第  列只存在行数不大于 \r\n的点，走到最后一列每一个点的方案数。容易证明转化完后的 \r\n仍然是不降的，且满足一个优秀的性质：。\r\n事实上，转化后的  就是 \r\n的点的个数，就算这个阶梯形网格是个  的矩形，\r\n也不超过 。\r\n经过上述的转化之后，问题终于有了明显的分层，可以考虑优化转移了。\r\n考虑一个  对  的贡献，设 ，我们发现，对于 ， 转移到  时不会受到  的限制（因为 ）。\r\n\r\n（图源自 @Alex_Wei，对于 \r\n的部分，它就算一路往上冲，也不会超过上图的红线。）\r\n那么从 \r\n转移到 \r\n的系数算起来就很容易了，就是 。\r\n这是一个很明显的卷积形式，我们设 ，那么我们将\r\n 与  进行卷积，\r\n将这一部分贡献加到 \r\n上。\r\n对于  的 ，我们尝试将区间分为  和  递归处理，即先将左区间的贡献加到\r\n 上，再用  的一部分去更新 。\r\n把这两部分的贡献加起来，所有  的  对  的贡献就计算完毕了。\r\n考虑实现这么一个算法流程：\r\n设 \r\n表示当前还没确定  值的区间为\r\n，传入多项式的第  项表示 ，返回多项式的第  项表示  。这也可以看作是让所有\r\n 的  全部减去 ，传入的 ，返回的 。下文将采用这种视角进行叙述。\r\n设 ，对于 ，将  与  卷积，将得到的结果加到\r\n 上面。\r\n对于 ，分治下放，设\r\n，那么顺次执行 。\r\n将最后得到的  也加到  上面。然后返回  即可。\r\n对于边界，\r\n的处理是平凡的。\r\n分析复杂度。对于下传的 ，其长度显然不超过 ，也就是说，对于 ，\r\n的长度不会超过当前分治区间的父区间的长度，即 。设  同阶，则该算法复杂度与一般的分治 NTT\r\n相同，为 。\r\n\r\n终于可以说回原题了。\r\n题意：给出一个括号串  ，设\r\n\r\n为最少需要删去的字符数使得原串是个合法括号串，求删去  个字符后原串合法的方案数，对  取模。\r\n。\r\n首先，我们要删去的字符一定形如 ))))((\r\n，即一段右括号再加上一段左括号。\r\n我们考虑找到这个分界点。\r\n把左括号看成 ,右括号看成 。考察这个序列的前缀和。\r\n我们一定一个位置为 \r\n的，当且仅当它对应的数是前缀最小值。因为 \r\n位置的数一定是在它之前的位置的数的最小值减 ，所以每遇上一个 \r\n位置，我们就需要在这个位置或其之前删掉一个右括号。\r\n那我们就将最后一个 \r\n位置，当作上述的分界线，在这个位置左边，我们只删右括号；在这个位置右边，我们只删左括号。\r\n这两个部分是本质相同的，下文以删右括号的部分为例。\r\n那么我们对于每个前缀，选中的右括号数一定不小于  位置的数量。\r\n那么我们可以设  表示前 \r\n个右括号 ，选中的右括号数减去  位置的数量为  的方案数。\r\n如果  是个  位置，转移到 ，否则转移到 。\r\n这看上去就挺格路计数的，可以套用上面的做法。因为限制只有 ，我们甚至不需要记录 。\r\n当然，还是稍有变形。具体地，记录  中  位置的个数 。那么对于 ， 转移到  就不受  限制的影响，转移系数为  。\r\n对于 \r\n的部分，递归下放去做即可，下放的多项式长度不会超过 ，故复杂度为 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1 &lt;&lt; 20,P = 998244353,G = 3;inline int Add(int a,int b) { return (a + b &gt;= P) ? (a + b - P) : (a + b);}inline int Sub(int a,int b) { return (a &lt; b) ? (a - b + P) : (a - b);}  inline int qpow(int a,int b) { int res = 1;while(b) {if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;} return res;}const int Gi = qpow(G,P - 2);int n;char s[N];int Gs[N],Gs2[N];int rev[N];inline int GetLen(int x){\tint len = 1;\twhile(len &lt;= x) len &lt;&lt;= 1;\treturn len;}inline void calc_rev(int len){\tfor(int i = 0;i &lt; len;i++)\t{\t\trev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1;\t\tif(i &amp; 1) rev[i] |= len &gt;&gt; 1;\t}}int fac[N],ifac[N];inline void init(int len){\tfor(int i = 1;i &lt; len;i &lt;&lt;= 1)\t{\t\tGs[i] = Gs2[i] = 1;\t\tGs[i + 1] = qpow(G,(P - 1) / (i &lt;&lt; 1));\t\tGs2[i + 1] = qpow(Gi,(P - 1) / (i &lt;&lt; 1));\t\tfor(int j = 2;j &lt; i;j++)\t\t\tGs[i + j] = 1ll * Gs[i + j - 1] * Gs[i + 1] % P,\t\t\tGs2[i + j] = 1ll * Gs2[i + j - 1] * Gs2[i + 1] % P;\t}\tfac[0] = 1;\tfor(int i = 1;i &lt; len;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tifac[1] = 1;\tfor(int i = 2;i &lt; len;i++) ifac[i] = 1ll * ifac[P % i] * (P - P / i) % P;\tifac[0] = 1;\tfor(int i = 1;i &lt; len;i++) ifac[i] = 1ll * ifac[i - 1] * ifac[i] % P;}inline int Binom(int n,int m) { if(n &lt; 0 || m &lt; 0 || n &lt; m) return 0;return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;}inline void NTT(vector&lt;int&gt; &amp;F,int len,int type){\tassert(F.size() &lt;= len);\tF.resize(len);\tfor(int i = 0;i &lt; len;i++)\t\tif(i &lt; rev[i]) swap(F[i],F[rev[i]]);\tfor(int k = 1;k &lt; len;k &lt;&lt;= 1)\t\tfor(int j = 0;j &lt; len;j += k + k)\t\t\tfor(int i = 0;i &lt; k;i++)\t\t\t{\t\t\t\tint cur = type == 1 ? Gs[k | i] : Gs2[k | i];\t\t\t\tint u = F[i | j],v = 1ll * cur * F[i | j | k] % P;\t\t\t\tF[i | j] = Add(u,v);\t\t\t\tF[i | j | k] = Sub(u,v);\t\t\t}\tif(type == -1)\t\tfor(int i = 0,Inv = qpow(len,P - 2);i &lt; len;i++)\t\t\tF[i] = 1ll * F[i] * Inv % P;}vector&lt;int&gt; t; // 存储每个要删的括号的标记状态void Solve(int l,int r,vector&lt;int&gt; &amp;f){\tif(l == r)\t{\t\tif(!t[l])\t\t{\t\t\tf.push_back(0);\t\t\tfor(int i = f.size() - 1;i &gt;= 1;i--)\t\t\t\tf[i] = Add(f[i],f[i - 1]);\t\t}\t\telse for(int i = 0;i &lt; f.size() - 1;i++) f[i] = Add(f[i],f[i + 1]);\t\treturn;\t}\tint mid = l + r &gt;&gt; 1,len = r - l + 1,cnt = 0;\tfor(int i = l;i &lt;= r;i++)\t\tcnt += t[i];\tvector&lt;int&gt; res(f.size() + (len - cnt),0);\tif(f.size() &gt; cnt)\t{\t\tvector&lt;int&gt; A(f.size() - cnt,0),B(len + 1,0);\t\tfor(int i = 0;i &lt; f.size() - cnt;i++)\t\t\tA[i] = f[i + cnt];\t\tfor(int i = 0;i &lt;= len;i++)\t\t\tB[i] = Binom(len,i);\t\tint L = GetLen(f.size() + len - cnt);\t\tcalc_rev(L);\t\tNTT(A,L,1);NTT(B,L,1);\t\tfor(int i = 0;i &lt; L;i++) A[i] = 1ll * A[i] * B[i] % P;\t\tNTT(A,L,-1);\t\tfor(int i = 0;i &lt; res.size();i++) res[i] = A[i];\t}\tvector&lt;int&gt; ff0(min((int)f.size(),cnt),0);\tfor(int i = 0;i &lt; ff0.size();i++) ff0[i] = f[i];\tSolve(l,mid,ff0);Solve(mid + 1,r,ff0);\tfor(int i = 0;i &lt; ff0.size();i++) res[i] = Add(res[i],ff0[i]);\tf = res;}int DoIt(){\tif(t.empty()) return 1;\tvector&lt;int&gt; f(1,1);\tSolve(0,t.size() - 1,f);\treturn f[0];}int main(){\tscanf(\"%s\",s + 1);\tn = strlen(s + 1);\tint cur = 0,lst = 0;\tinit(GetLen(n * 2 + 2));\tfor(int i = 1;i &lt;= n;i++)\t\tif(s[i] == '(') ++cur;\t\telse { if(!cur) lst = i;else --cur;}\tcur = 0;\tfor(int i = 1;i &lt;= lst;i++)\t\tif(s[i] == '(') ++cur;\t\telse { if(!cur) t.push_back(1);else t.push_back(0),--cur;}\tint ans = DoIt();\tvector&lt;int&gt;().swap(t);cur = 0;\tfor(int i = n;i &gt; lst;i--)\t\tif(s[i] == ')') ++cur;\t\telse { if(!cur) t.push_back(1);else t.push_back(0),--cur;}\tans = 1ll * ans * DoIt() % P;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n这道题加深了我对分治 NTT 的理解。\r\n","tags":["counting","poly"]},{"title":"CF1172F 题解","url":"/posts/2012520028/","content":"这题还是想岔了一些，也有可能是图画错了，有些性质观察得并不是很彻底。和题解无限接近了属于是（\r\n\r\n对于一个区间 \r\n，显然，对于初始数 ，设  表示最终值那么  是一个关于  的分段函数，且最多  段，因为只会减  个 。\r\n对于一段数列，设 \r\n表示初始数最少是多少，使得做完这个数列之后减去了  个 。\r\n在序列上的问题，  又高达 ，当然首选线段树。\r\n考虑怎么合并  和  的  数组。\r\n当然是用左边的  和右边的\r\n 来更新 。\r\n下文设  的和为 。\r\n考虑更新的条件，我们要确保对于一个在 \r\n中的数，其在做完左边之后还大于等于 。\r\n那么就有条件 。\r\n那么更新的时候，从  反推回\r\n，就得到转移式 。\r\n直接这么做的话，合并两个区间的复杂度是平方的，不如暴力。\r\n事实上，对于这种 \r\n的转移，是可以考虑双指针优化的。（当然，要求  均单调）\r\n考察双指针的可行性，首先，\r\n肯定是单调递增的。\r\n我们再说明，对于 \r\n相同的转移，我们取 \r\n最小的一定不劣。\r\n即证明  不劣于 。\r\n首先有 ，即 。\r\n且有 。\r\n所以 。\r\n显然会有 。\r\n但有这点还是不够，为了能够用指针维护决策点，我们还需说明， 是关于  单调递增的，也就是 。\r\n由于  表示最小的初始值，所以\r\n 经过一段区间后，最大值必定是\r\n，否则我们可以将初始值调小一点，所以我们需要再增加至少\r\n 才可以再减掉一个 。\r\n那么，我们只需维护一个指针 ，表示当前最大的满足条件的 ，在  自增时， 对应移动，用走到的那些  转移即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5,Sz = N &lt;&lt; 2;typedef long long ll;const ll INF = 0x3f3f3f3f3f3f3f3f;template&lt;typename T&gt; inline void ckmin(T &amp;x,const T &amp;y) { if(x &gt; y) x = y;}template&lt;typename T&gt; inline void ckmax(T &amp;x,const T &amp;y) { if(x &lt; y) x = y;}int n,m,p,a[N];struct node{\tint l,r,len;\tll sum;\tvector&lt;ll&gt; c;};node tr[Sz];#define ls k &lt;&lt; 1#define rs k &lt;&lt; 1 | 1inline void pushup(int k){\ttr[k].sum = tr[ls].sum + tr[rs].sum;\tfor(int x = 0,y = 0;x &lt;= tr[ls].len;x++)\t{\t\tif(y &gt; tr[rs].len) --y;\t\tfor(;y &lt;= tr[rs].len;++y)\t\t{\t\t\tll val = tr[rs].c[y] + 1ll * x * p - tr[ls].sum;\t\t\tll lim = tr[ls].c[x + 1] - 1 - 1ll * x * p + tr[ls].sum;\t\t\tif(lim &lt; tr[rs].c[y]) {if(y) --y;break; /* 当前 y 不合法，要回退一个*/}\t\t\tckmin(tr[k].c[x + y],max(tr[ls].c[x],val));\t\t}\t}}void build(int k,int l,int r){\ttr[k].l = l;tr[k].r = r;\ttr[k].len = r - l + 1;\tfor(int i = 1;i &lt;= tr[k].len + 2;i++) tr[k].c.push_back(INF);\ttr[k].c[0] = -INF;\tif(l == r) { tr[k].sum = a[l];tr[k].c[1] = p - a[l];return;}\tint mid = l + r &gt;&gt; 1;\tbuild(k &lt;&lt; 1,l,mid);\tbuild(k &lt;&lt; 1 | 1,mid + 1,r);\tpushup(k);\t// printf(\"[%d,%d]: \",l,r);\t// for(auto i : tr[k].c) printf(\"%d \",i);\t// printf(\"\\n\");}ll Now; // 全局变量，初始时为 0,遇到一个区间，就让 now = f(l,r,now)，最后拼凑出询问区间的答案。void Query(int k,int l,int r,int x,int y){\tif(l &gt; y || r &lt; x) return;\tif(x &lt;= l &amp;&amp; r &lt;= y) \t{\t\tint pos = upper_bound(tr[k].c.begin(),tr[k].c.end(),Now) - tr[k].c.begin() - 1;\t\tNow = Now - 1ll * pos * p + tr[k].sum;\t\treturn;\t}\tint mid = l + r &gt;&gt; 1;\tQuery(k &lt;&lt; 1,l,mid,x,y);\tQuery(k &lt;&lt; 1 | 1,mid + 1,r,x,y);}int main(){\tios::sync_with_stdio(false);\tcin.tie(0);cout.tie(0);\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; p;\tfor(int i = 1;i &lt;= n;i++)\t\tcin &gt;&gt; a[i];\tbuild(1,1,n);\tfor(int i = 1;i &lt;= m;i++)\t{\t\tint l,r;\t\tcin &gt;&gt; l &gt;&gt; r;\t\tNow = 0;\t\tQuery(1,1,n,l,r);\t\tcout &lt;&lt; Now &lt;&lt; endl;\t}\treturn 0;}\r\n","tags":["DS"]},{"title":"ARC135E 题解","url":"/posts/3377480582/","content":"不知道如何评价题。\r\n\r\n题意：\r\n给出两个数 ，构造序列 ，使其满足下列限制：\r\n\r\n。\r\n。\r\n 是  的倍数。\r\n\r\n在此基础上，使得 \r\n最小，输出答案对 \r\n取模的值。\r\n 组数据。。\r\n显然，策略是让每个 \r\n都尽量小。\r\n那么设 ，就有 \r\n因为  约等于  ，设 ，那么会有 。\r\n那么可以说明，在  的时候，。\r\n也就是说， 只有  个本质不同的值！\r\n因为这玩意单调不增，所以最终会呈现若干个连续段。\r\n然后我想到这里不会算端点！\r\n考虑一个 ，设  ，我们想求出最大的\r\n 满足 \r\n化式子： \r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int P = 998244353,inv2 = (P + 1) / 2,inv6 = 166374059;typedef long long ll;ll n,nowb;inline ll cdiv(ll x,ll y) { return (x + y - 1) / y;}inline int S1(ll x) { x %= P;return 1ll * x * (x + 1) % P * inv2 % P;}inline int S2(ll x) { x %= P;return 1ll * x * (x + 1) % P * (2 * x + 1) % P * inv6 % P;}inline int calc(ll fr,ll d,ll l,ll r) // Bl = fr,Bi+1-Bi = d{\tint res1 = 1ll * (fr % P) * (S1(r) - S1(l - 1) + P) % P;\tint res2 = 1ll * (d % P) * (S2(r) - S2(l - 1) + P) % P;\tint res3 = 1ll * (l % P) * (d % P) % P * (S1(r) - S1(l - 1) + P) % P;\treturn (1ll * res1 + res2 - res3 + P) % P;}inline void Work(){\tcin &gt;&gt; n &gt;&gt; nowb;\tint ans = 0;\tfor(ll l = 1,r;l &lt;= n;l = r + 1)\t{\t\tll x = cdiv(nowb,l + 1);\t\tif(x == 1) r = n;\t\telse r = min(n,(nowb + (l + 1) * (x - 1) - 1) / (2 * x - 2) - 1);\t\t(ans += calc(nowb,1 - x,l,r)) %= P;\t\tnowb -= (r - l + 1) * (x - 1);\t}\tcout &lt;&lt; ans &lt;&lt; endl;}int main(){\tint T;\tcin &gt;&gt; T;\twhile(T--) Work();\treturn 0;}\r\n事实上，上文中的 \" 约等于\r\n \" 是可以严谨的给出一个\r\n上界的。\r\n因为 \r\n所以 。\r\n设 。\r\n由此可以算出  处于 \r\n级别，即在  的时候， 的取值也只有  个。\r\n于是总段数就是  的了。\r\n","tags":["greedy"]},{"title":"ARC117E 题解","url":"/posts/3813915453/","content":"这题让我没什么头绪。想到过使用前缀和来转换，但 \r\n的变化量看上去非常难以处理。最后发现是一个从未见过的 DP 模型，果然 ARC\r\n题还是有学习价值的（前提是找得到好题）。\r\n\r\n题意：计数满足下列条件的长度为  的序列 ：\r\n\r\n恰好包含  个  和  个 。\r\n恰好有  对  满足 \r\n\r\n。\r\n求出  的前缀和 ，设  表示有多少个  等于 ，那么上述条件等价于：。\r\n另一方面，。\r\n注意到这个 \r\n的约束是关于每种值独立的，我们尝试设计关于值的 DP。\r\n要把值的限制和相差 \r\n的限制统一起来，我们尝试 DP 这个序列 S 的笛卡尔树。\r\n如下图：\r\n\r\n我们在这个笛卡尔树上，从上到下，一层一层的\r\nDP,每次填完一层的所有数。\r\n设  表示一共填了\r\n 个数，已经填的数在  序列上形成  个连续段，一共填了  层，当前的  的方案数。\r\n考虑最后怎么求答案，因为最后强制 ，我们考虑把  和 \r\n的部分拼接起来。\r\n注意到这两种情况是对称的，我们都可以用这个 DP 状态来表示。\r\n设 。\r\n具体地，因为拼的时候肯定是一段  和一段 \r\n交错，那么我们枚举  的个数\r\n，段数 ，这一部分的 ，那么最后的答案就是  进一步地，我们发现 DP 中的  是没用的，可以去掉。\r\n我们考虑新一层加入了 \r\n个数的影响。\r\n会出现一下三种情况：\r\n\r\n某两段之间的间隙被连接，需要占用一个位置，并把两个段合并成一个\r\n某个段间隙没有被连接，因为 \r\n的变化连续，必须在这个间隙的两段贴两个数来拓展\r\n加入一个新的“山谷”\r\n\r\n重点在于考虑段数的变化。\r\n当前有  个连续段，就有 \r\n个空隙，每个空隙中都必须填数（因为我们是从上到下来填的数，每次填的是当前序列中的最小值，而我们限制了序列两端是\r\n，所以两端的空隙也必须填数；另一方面，因为\r\n\r\n的变化是连续的，所以中间的空隙不填数就不合法了）\r\n由上面三种情况整合可得，在单一个中间空隙中填入了  个数，会给总段数带来  的变化量。两端则是 。\r\n整理式子可得新的连续段数为 。\r\n考虑转移系数，相当于在 \r\n个盒子里放 \r\n个球，每个盒子都不为空，插板可得系数为 \r\n综上所述，有转移 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 65;typedef long long ll;int n,k;ll C[N][N];ll dp[N][N][N * N];int main(){\tcin &gt;&gt; n &gt;&gt; k;\tC[0][0] = 1;\tfor(int i = 1;i &lt;= n + 1;i++)\t{\t\tC[i][0] = C[i][i] = 1;\t\tfor(int j = 1;j &lt; i;j++)\t\t\tC[i][j] = C[i - 1][j - 1] + C[i - 1][j];\t}\tfor(int x = 0;x &lt;= n + 1;x++)\t\tif(x * (x - 1) / 2 &lt;= k)\t\t\tdp[x][x][x * (x - 1) / 2] = 1;\tfor(int i = 1;i &lt;= 2 * n + 1;i++)\t\tfor(int c = 0;c &lt;= k;c++)\t\t\tfor(int j = 1;j &lt;= min(n + 1,i);j++)\t\t\t{\t\t\t\tll val = dp[i][j][c];\t\t\t\tif(val)\t\t\t\t{\t\t\t\t\tfor(int x = j + 1;x &lt;= n + 1;x++)\t\t\t\t\t{\t\t\t\t\t\tint nxt_c = c + x * (x - 1) / 2;\t\t\t\t\t\tif(i + x &gt; 2 * n + 1 || nxt_c &gt; k) continue;\t\t\t\t\t\tdp[i + x][x - j][nxt_c] += C[x - 1][j] * val;\t\t\t\t\t}\t\t\t\t}\t\t\t}\tll ans = 0;\tfor(int i = 0;i &lt;= 2 * n + 1;i++)\t\tfor(int j = 1;j &lt;= n + 1;j++)\t\t\tfor(int c = 0;c &lt;= k;c++)\t\t\t\tans += dp[i][j][c] * dp[2 * n + 1 - i][j - 1][k - c];\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting"]},{"title":"杭州中超联赛战前培训（上）","url":"/posts/2844372658/","content":"2022.11.29\r\n今天前两题其实都不算难，但因为打着打着想下班了，就只写了 T1 和 T3\r\n的一点分，没有认真思考 T2。\r\n\r\nT1 是个简单题：\r\n给出  条限制 ，要求计数长度为  的排列  使得对于每个限制  均有  或 。\r\n放在置换环上考虑，一个限制相当于一条无向边。\r\n显然有点度数大于 \r\n就无解。有一个自环连接其他点也无解。\r\n否则每个联通块有四种情况：\r\n\r\n自环，舍去\r\n孤立点，需要被插入置换环\r\n一个整环，显然它不能对其他的点有影响，故将最后的答案  即可\r\n一条链，将其定向之后同孤立点没什么区别。\r\n\r\n唯一的例外是一个长度为 \r\n的链单独成环的时候，对这条链定向没有意义。\r\n设有  条长度  的链， 条长度为  的链， 个孤立点。\r\n则枚举恰好有  个长度为  的链单独成环，则剩下的  个都不能单独成环。\r\n内层相当于一个错排，一共有  个点，其中  到  不能单独成环。可以容斥。 d\r\n把式子写在一起推一推可以得出一个卷积做法，这里就不细讲了。（考场做法，但因为找环的\r\ndfs 写错了挂成 20)\r\n考虑先假设所有长度为  的链都有\r\n 的系数，那么一个长度为  的链单独成环就有  的系数。\r\n大家应该还记得，容斥是使用二项式定理证明的。\r\n我们容斥“一个东西不出现的方案数“，实际上是在说它的权值是\r\n0,此时容斥系数是 。\r\n现在出现一个东西的权是 ，那容斥系数就是 。\r\n所以直接钦定有 \r\n个二元链成自环，容斥系数就是 。\r\nT2 是个拆贡献线段树题，到时候补。\r\nT3 是个套路题。\r\n输入  个字符串 。\r\n有一个初始为空的字符串 ，每次在后面等概率加入一个小写字母，当所有\r\n 均在  中出现至少一次时，停止加入字符。\r\n问  的期望长度。\r\n\r\n设  表示  最早出现的时间。\r\n所求即为 。\r\n 容斥一下，所求即为\r\n。\r\n这就是 [SDOI2017] 硬币游戏，我们把它重新推一遍。\r\n我们使用暴力的  推导。\r\n设  表示  的 ，即  表示  的概率。\r\n设 \r\n表示一直没有出现任何一个串的 ，即  表示到了时间  还没有一个串出现的概率。\r\n首先 \r\n，即所有时间都没出现的概率之和，其实就是第一次有串出现的时间的期望，可以参考等式\r\n 进行理解。\r\n考虑列出  与  的关系式。\r\n首先有\r\n\r\n具体地，就是考虑 ，即当前没结束，下一步可能结束或没结束。\r\n再者，对于每个 ，不管当前的\r\n 是什么，只要往后拼一个 ，必然会结束。\r\n唯一的问题是，我们可能还没有把一个  拼完，事情就结束了。\r\n也就是说，我们可能拼了一个 \r\n的前缀，然后跟原来 \r\n的某个后缀形成了一个 ，就贡献到了“直接往后拼一个 \" 的方案当中去。\r\n设 ，则对于每个 ，有方程：\r\n\r\n其中  是字符集，这里。\r\n将  代入上面  个式子，即可得到关于  和  的  个方程，高斯消元解方程即可。\r\n注意第二个式子的系数需要在一开始就处理好，因为我们要解  遍方程。\r\n时间复杂度为  或  ，取决于预处理复杂度。 ## 2022.11.30\r\n得分：100+100+30=230,大众分。\r\n写一下第三题。\r\n给出一个  个点的无向环，第\r\n 个点同第  个点之间，有一条权值为\r\n 的无向边。（）。\r\n再给出  条无向边  。\r\n特殊条件：如果把这张图画在一个平面上，这 \r\n条无向边不会在端点以外的地方相交，即开区间  和   要么互相包含，要么无交。\r\n设  表示\r\n 到  的最短路。\r\n求 。\r\n。\r\n在平面图上的点对相关问题，考虑分治。\r\n取出一条不在环上的边 \r\n，整张图就被分成了两个部分，设两个部分的点集为 。\r\n考虑对于 \r\n统计贡献。\r\n因为  到  的最短路必定经过  中的至少一个，故 \r\n 和  可以用 Dijkstra 跑出来。\r\n我们要求 ，考虑把贡献分类，即考虑什么时候\r\n。\r\n移项变成 \r\n左边就只和  有关，右边就只和\r\n 有关。\r\n可以把  和  放入同一个数组中进行排序。然后从前往后扫描就可统计贡献。\r\n考虑如何向下递归。\r\n直接向下递归是不行的，因为对于 ， 到  的最短路仍然可能经过  中的点。\r\n但我们注意到，这仍然会经过  和\r\n。\r\n所以我们向下递归时，把  到\r\n 的权值赋为 ，就包含了这种情况。\r\n但是，直接这样递归的复杂度是错的。\r\n因为我们的分治基于题目给出的 \r\n条边，如果这 \r\n条边分出来的两半都不太均匀，那么复杂度就会上去。\r\n一个策略是把这 \r\n条边补成一个三角剖分（补上的边的边权设为 )，然后每次找到使  最小的 ，递归下去，复杂度就是对的。\r\n证明的话，把环上的点均匀地放到一个圆上，找到一个包含圆心的三角形\r\n，这个三角形会把原图的点分成三个部分 ，有 。\r\n显然会有 ，因为三角形包含圆心，也会有 。\r\n所以我们找 \r\n的时候，总能找到一对  满足 ，所以你能找到一对  满足 \r\n最坏的情况下，。可以分析出总复杂度为 。\r\n至于如何把现有的 \r\n条边补成一个三角剖分。考虑找出一个度数为  的点（即不与这  条边的任何一条相连)，设其为 ，然后考察其左边和右边的点 ，如果  与  之间没有连边，就连上。\r\n这样，\r\n就会形成一个三角形，且贴在环的边上，我们大可以把点  删掉，把  之间的的那条非环边变为新的环边（即将\r\n 的度数都减 ），然后重复上述过程。可以类似拓扑排序，用队列维护当前度数为\r\n\r\n的点。并用双向链表维护删点即可。\r\n代码如下：\r\nfor(int i = 0;i &lt; m;i++){\tE[e[i].x].insert(e[i].y),\tE[e[i].y].insert(e[i].x);\t++deg[e[i].x];++deg[e[i].y];}\tqueue&lt;int&gt; Q;\tfor(int i = 0;i &lt; n;i++)\t\tif(!deg[i]) Q.push(i);\tfor(int i = 0;i &lt; n;i++)\t\tL[i] = i - 1,R[i] = i + 1;\tL[0] = n - 1;R[n - 1] = 0;\twhile(!Q.empty())\t{\t\tint x = Q.front();Q.pop();\t\tint lef = L[x],righ = R[x];\t\tR[lef] = righ;L[righ] = lef;\t\tif(lef &gt; righ) swap(lef,righ);\t\tif(lef == righ || (lef == 0 &amp;&amp; righ == n - 1) || righ - lef == 1) continue;\t\tif(!E[lef].count(righ))\t\t{\t\t\tE[lef].insert(righ);E[righ].insert(lef);\t\t\te.push_back(Edge(lef,righ,inf));\t\t}\t\telse\t\t{\t\t\tif((--deg[lef]) == 0) Q.push(lef);\t\t\tif((--deg[righ]) == 0) Q.push(righ);\t\t}\t}\r\n2022.12.1\r\n得分：0+85+0，T2 因为有一个地方写挂痛失  分，差点就签到成功了。\r\n11.30 的 T3 是赛时写完 T2 之后改的。\r\n2022.12.2-2022.12.6\r\n模拟赛没有什么可改的题，但讲课的课件还是有很多不错的题的。\r\n会随缘更新一些学到的东西。\r\n1. 多项式点值平移\r\n对于一个  次多项式 ，给出  ，现在需要求出 。对  取模。\r\n。\r\n考察拉格朗日插值的式子：\r\n\r\n后半部分显然是个卷积的形式，唯一的不足是后面的求和上界是  而不是 。\r\n因为  可能小于 ,我们要化成卷积的形式，最方便的当然是取某个序列的第\r\n\r\n项作为答案，虽然我们还不知道这个序列是什么。\r\n进一步地，我们把 \r\n这个序列也类似地平移 \r\n位,具体地，我们设\r\n$$\r\n\r\n$$\r\n然后令 ，取  就是  的后面那个 。\r\n一遍卷积即可，时间复杂度 。\r\n2. P5469 机器人\r\n从初三的暑假到高一上学期，计数水平确乎是有提升的，也有可能是思路变得更加敏捷，总而言之，看懂机器人了。\r\n题意：\r\n从左到右有一排长度为 \r\n的柱子，设柱子  的高度为 。有两种机器人，P\r\n型机器人和 Q 型机器人。\r\nP\r\n型机器人从某个柱子出发，会一直向左走，直到走到尽头或者下一个柱子的高度大于起点柱子。\r\nQ\r\n型机器人从某个柱子出发，会一直向右走，直到走到尽头或者下一个柱子的高度大于等于起点柱子。\r\n如果 ，把两个机器人放在 \r\n处，让他们走，他们走过的格子数量之差的绝对值不超过 。那么这个  序列就被称作合法的。\r\n现在限定 （\r\n给定）计数有多少个合法的 。对\r\n 取模。\r\n。\r\n题目中的机器人在走到第一个大于/大于等于起点的位置就会停止，我们不妨考虑，如果把起点设在整个数列最靠右的最大值会发生什么。设这个位置为\r\n。\r\n显然，P 型机器人会一直向左，Q\r\n型机器人会一直向右，直到走到端点，而在 \r\n的左边或右边，机器人无论怎么走都无法跨过 。\r\n所以我们借助这个最大值，把一个区间拆成了两个子区间，和一个断点的决策。（这是十分重要的思想，通过特殊点的表现来拆分问题）\r\n于是考虑设计一个 \r\n表示区间 \r\n的答案，转移枚举最大值的位置，因为其与两边距离之差不超过 ，有效的转移不多，在  时只有  个有效区间。\r\n但枚举最大值本身还会带来限制，子区间的最大值必须小于或小于等于枚举的端点\r\n所以我们还要记录一维 \r\n表示当前转区间的最大值，状态就是 ，设其前缀和为 \r\n那么转移就是  但 \r\n有可能很大，如果直接实现这个东西，显然是无法满分的。\r\n我们思考 \r\n那档部分分，现在相当于 \r\n的取值不受限制。\r\n考虑一个  的区间，它满足\r\n，其前缀和满足 \r\n考虑一个 \r\n的区间，他就是如上的两个 \r\n点乘的结果，显然是个二次函数。\r\n归纳地，设  是一个关于 \r\n的函数，我们可以证明这是个次数不超过  次的多项式，对着 \r\n方程考虑即可得证。\r\n也就是说，我们只要算出了  在 \r\n的取值，就能通过插值算法得出 。\r\n我们转而考虑正解，此时 \r\n不一样，哪怕是  固定，每个  都有可能可以被取或者不能被取，这取决于\r\n 和  的限制。\r\n这意味着答案不再是个多项式。\r\n但我们考虑把 \r\n按照数轴上离散化的方法处理。\r\n那么对于两个特殊值  形成的区间  中的  ，在 \r\n一定时决策都是一样的，要么取，要么不取，这样答案就是一个多项式，能不能取的决策无非是多乘一项，少乘一项的区别。\r\n值得注意的是，我们在  的值域中考虑 \" 的前缀和\" 时，它仍然是从\r\n 开始求和的，而非 ，所以我们需要一个位置来保存在更小的值域区间内\r\n\r\n的前缀和，这在代码里体现为 。\r\n3.P4654 [CEOI2017] Mousetrap\r\n有题号就不放题意了。\r\n虽然看着是个博弈题，但跟博弈其实关系不大，我们只需通过一定的方法，刻画这两个人在不同局面下的决策即可。\r\n我们考虑把陷阱点作为根，那么老鼠就是要向上一直跳，然后跳到根。\r\n容易发现，如果老鼠跳着跳着，转头向下，进入了某棵子树，那他就只能在某个叶子处等待收编，因为管理员不清理他就上不去，而且老鼠能动就必须要动。\r\n所以，管理员大可以把他想堵的边都堵住了之后，再来把老鼠通往陷阱的路径清扫干净。\r\n而老鼠进入子树再出来的代价只同他在哪棵子树有关。\r\n故可以设  表示老鼠进入了\r\n\r\n子树后再把他赶出来的最小代价。\r\n老鼠在点  时，他显然会走  最大的儿子 。\r\n但管理员显然会堵上这个儿子，所以老鼠会走  次大的儿子。\r\n设  表示  的儿子个数，则  有 \r\n个儿子要堵上，有 \r\n个儿子在最后要疏通，所以代价是 。\r\n但是，对于一次博弈，老鼠可以先向上跳一点，再一头扎进一棵子树。\r\n但老鼠会钻进哪棵子树？\r\n这个影响因素其实很多，并不是简单的把所有代价取  就是最优解的。\r\n我们考虑二分答案，设当前有 \r\n个可用操作。\r\n那么假设你老鼠打算在 \r\n点，一头扎进某个子树 。\r\n设把 \r\n以上的路径的邻域全部堵住的代价是 。\r\n则对于 \r\n的子树，其实我们是不需要堵住他的，但大于则需要，这本身又会花费一个操作（从这个角度来看，答案确实需要二分，不能直接求，因为决策比想象中复杂）\r\n另一方面，假设点  一共有  个  的子树，那么在老鼠到达点  之前，这些树就要全部堵上。\r\n把这两个条件判断之后，就可以充要地判定  次操作是否可以收编老鼠。\r\n然后这题就做完了。\r\n4.P4202 [NOI2008] 奥运物流\r\n有题号就不放题意了。\r\n先考虑如何计算 \r\n如果原图是一个环，那么 有 \r\n手动消元可得 。\r\n另一方面，如果原图是个内向树，容易推出 \r\n综合以上两点可以得到 \r\n具体地，可以先把环外的内向树都递推上来，再放到环上考虑，即可证明这一点。\r\n显然，我们改一个点的后继，最优的方法是直接改到  号节点。\r\n考察原来的式子，我们可以决定的是  和环长 。\r\n我们不妨枚举环长，那么此时的环就是可以确定的，就是  号点后面若干个点。\r\n我们大可以把 \r\n号点的出边忽略，它对答案没有影响。\r\n接下来变成内向树上的问题。\r\n我们设  表示在  子树内，用了  次修改机会，点  的深度现在为  的最优答案。\r\n树上背包转移即可。\r\n5. CF1119F Niyaz and Small\r\nDegrees\r\n有题号就不放题意了。\r\n我们考虑单个答案怎么求。\r\n容易想到设  表示\r\n 与  之间的边割或不割。dp\r\n时，先把这些状态的值都设成 \r\n，但这个和式对应的方案不一定是合法的，也就是说，我们要把一些  的儿子  ，由不割  强行变为割掉 \r\n，并将答案加上对应的增量。我们可以开个堆，来取出增量前若干小的儿子  做这个事情，这样就可以  完成这次树形 dp。\r\n我们考虑，随着度数限制 \r\n的增大，问题的规模是在变小的，具体地，对于  已经不超过  的点 ，我们树形 \r\n时其实没必要经过它，我们只关心它和它某个邻居之间的那条边要不要被割，我们可以把它当成一个孤立点，并把它的信息放到邻域上。\r\n具体地，有如下代码：\r\ninline void Destroy(int x){\tfor(auto it : G[x])\t{\t\tint y = it.first,w = it.second;\t\tif(deg[y] &lt;= D) break;\t\tH[y].push(w);\t}}\r\n接下来我们对度数大于等于 \r\n的点，做如上的树形 dp 即可。\r\n事实上，这样的复杂度就是 。\r\n具体地，可以考虑等式 。\r\n在代码实现上，我们把所有邻居按度数从大到小排序，遍历到  的点就直接 break 而非 continue\r\n。\r\n在 dp\r\n的时候，我们维护大根堆，当堆的大小超过限制时就把堆顶删去，这样可以时刻保证堆的大小不超过\r\n，此时我们的堆中会删除一些值，但删完之后，我们也必须把它加回来，因为这里面包含了一些孤立点的信息。\r\n这些都是为了保证复杂度而需要注意的细节。\r\n","tags":["游记"]},{"title":"洛谷 P8340 山河重整 题解","url":"/posts/313682301/","content":"一道很有启发意义的数数题。\r\n\r\n看到这题之后，当然是首先从  开始想起。\r\n如果我们从小到大地决策某个数是否被加入，那么现在已经被加入的数字，在值域上能表示的一定是一段前缀，即一个形如\r\n 的区间，那么可以设计状态\r\n 表示加入了前  个数，当前能表示的区间为  的方案数。\r\n在加入数 \r\n之后，能表示的区间变为 ，转移合法当且仅当 ，也就是说，对于 \r\n的 ，其可以转移到 。\r\n分析上述的 \r\n过程，可以得到一个很重要的结论，即 。这个结论跟上述 dp\r\n的转移式是等价的。\r\n对每个 \r\n都要求其合法是比较困难的，我们不如计数不合法的方案数。\r\n因为不合法的位置可能有很多，一个计数的套路是考察第一个不合法的位置。\r\n设考虑位置  且位置  为第一个不合法位置的方案数为 。\r\n也就是说，满足 \r\n均可被拼出，但 \r\n无法被拼出。\r\n通过上面的结论，我们可以知道  中被选中的数的和恰好为 。\r\n为了保证 \r\n是第一个不合法的位置，我们可以用满足上述条件的所有方案，减去第一个不合法位置为\r\n 的方案数。\r\n形式化地说，，其中 \r\n是转移的系数，因为根据 \r\n的意义， 不能填数，且  中的数和为 ，那么  就是在  中选数，使这些数的和为  的方案数。\r\n先考虑  怎么求，显然，它是\r\n 的\r\n互异拆分数，也就是将  拆分为若干个不同的数的和的方案数。\r\n回顾互异拆分数的经典做法，我们知道， 只会被拆为最多  个数，我们可以据此设计 DP。\r\n将  拆成若干个数  的时候，我们会限制\r\n\r\n来保证计数不重复，但这个限制本身很麻烦，我们考虑差分数组 ，那我们就只需要保证  就可以了，而每个 \r\n对全局的贡献就是 。那么每个 \r\n就相当于一个大小为  的物品，这个\r\nDP 则相当于完全背包（因为 \r\n没有上界），因为 ，我们对这些  跑完全背包即可求出拆分数。\r\n代码如下：\r\nf[0] = 1;int lim = sqrt(2 * n);for(int i = lim;i &gt;= 1;i--) // 倒序枚举 i，方便滚动数组{\tfor(int j = n;j &gt; i;j--) f[j] = f[j - i];\tfor(int j = i;j &gt;= 1;j--) f[j] = 0;\tfor(int j = i;j &lt;= n;j++)        Plus(f[j],f[j - i]); // 完全背包}\r\n回到上面的式子，我们考虑  怎么处理，假设我们已经知道了 ，那么我们要解决的是 ，也就是在  中选数，使得它们的和为  的方案数。\r\n假设我们已经确定了 \r\n中选多少个数，设其为 ，那么我们可以把这其中的所有数全部减去\r\n，然后接着做互异拆分数的\r\nDP,事实上，我们只要把 \r\n贡献到数组中 \r\n的位置，那么最后提取背包数组中位置  的值就可以得到这个  的贡献。\r\n因为我们是倒序枚举的 （注意这里的  是完全背包中的 ），所以枚举到某个数的时候，我们不妨假设其就是\r\n\r\n，在后续的枚举中，我们会把其他的物品（也就是其他的  一步一步加入进去），DP\r\n完了之后，这个方案自然会被贡献到正确的位置。\r\n上述两段可以结合代码理解。\r\n另一个问题是，我们在求 \r\n的时候，假设 \r\n已经被算出来了，那我们怎么实现这个算法呢？\r\n事实上， 能贡献到  ，说明 ，即 。也就是说，如果要求  的 ，我们可以先递归求出  的 ，再用上述做法求出后半部分的  即可。\r\n代码如下：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;int n,P;inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}int f[N],t[N];void Solve(int n){\tif(n &lt;= 1) return;\tint lim = sqrt(2 * n);\tSolve(n &gt;&gt; 1);\tfor(int i = 0;i &lt;= n;i++) t[i] = 0;         \tfor(int i = lim;i &gt;= 1;i--)\t{\t\tfor(int j = n;j &gt;= i;j--) t[j] = t[j - i];\t\tfor(int j = i - 1;j &gt;= 0;j--) t[j] = 0;\t\tfor(int j = 0;j + (j + 2) * i &lt;= n;j++)\t\t\tPlus(t[j + (j + 2) * i],f[j]);\t\tfor(int j = i;j &lt;= n;j++) Plus(t[j],t[j - i]);\t}\tfor(int i = (n &gt;&gt; 1) + 1;i &lt;= n;i++)\t\tPlus(f[i],P - t[i]);}int Pow2[N];int main(){  \tPow2[0] = 1;\tfor(int i = 1;i &lt;= n;i++) Pow2[i] = (Pow2[i - 1] + Pow2[i - 1]) % P;\tf[0] = 1;int lim = sqrt(2 * n);\tfor(int i = lim;i &gt;= 1;i--)\t{\t\tfor(int j = n;j &gt; i;j--) f[j] = f[j - i];\t\tfor(int j = i;j &gt;= 1;j--) f[j] = 0;\t\tfor(int j = i;j &lt;= n;j++)\t\t\tPlus(f[j],f[j - i]);\t}\tSolve(n);\tint ans = 0;\tfor(int i = 0;i &lt; n;i++)\t\tans = (ans + 1ll * f[i] * Pow2[n - i - 1] % P) % P;\tans = (Pow2[n] + P - ans) % P;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting"]},{"title":"洛谷 P3642 烟火表演 题解","url":"/posts/2791595810/","content":"本题就当是对 Slope trick 的入门了。\r\n\r\n首先考虑  不大的情况。\r\n设  表示在  子树内，点燃时间为  的最小代价。\r\n那么考虑合并  和一个儿子\r\n ，则有  。（ 是\r\n 与  之间的边权）\r\n我们令 。\r\n可以证明， 是关于 \r\n的下凸函数，且每一段的斜率均为整数。\r\n设  表示  斜率为  的那一段的左右端点的横坐标，那么  变化如下：  具体分析如下：\r\n对于第一种情况：因为在 \r\n处 ， 的斜率小于等于\r\n，即修改  以下的边的代价 ，那肯定不如直接修改  （代价恰为 ），所以在这里直接把  修改到 ，然后取出在  点的函数值。\r\n对于第二种情况：函数在 \r\n处取到最小值，我们跟第一种情况的理由一样，能够修改  就别修改  中的  ，所以  中的  一定 ，而为了让 \r\n修改的代价尽量小，我们直接把  拉到\r\n 。这样就是最优的了。\r\n第三种情况较为简单，第四种情况与第一种类似，就不再赘述。\r\n对于这种斜率为整数的下凸壳，我们可以通过维护拐点和最右边的直线来表示这个凸壳。\r\n\r\n就像上图，我们只需维护所有的红点和红线即可。\r\n我们默认每三个相邻拐点所表示的两条直线的斜率差都是 ，如果不是，那我们就多次加入同一个拐点。\r\n如何求一个点  的函数值  呢？因为拐点的斜率差都是 ，我们用  减去在  之前的所有拐点的横坐标即可。\r\n如何执行 \r\n呢？还是因为拐点序列的性质，我们直接把二者的拐点序列按顺序拼接起来即可。\r\n现在我们有了这个凸壳模型，我们考虑上面的操作是如何把  变为  的。\r\n首先，把  左边的部分向上平移\r\n，然后把  这一部分整体向右平移 ，并在  处插入一条斜率为 \r\n的直线，把原函数 \r\n的部分的斜率都变为 。\r\n注意到函数的斜率最大值也只有 ，我们甚至不需要“维护那条红线”，处理所有的拐点即可。\r\n考虑这些操作怎么办：\r\n\r\n向上平移 ，这等价于 ，而 \r\n不论是从这里来看，还是从定义上看，都显然是所有边权的和，所以这个很简单。\r\n把大于  的部分的斜率都变为\r\n。这个可以在所有的  都并入  之后再行处理。注意到每个  有且仅有一个斜率为正的拐点\r\n，假设  的儿子有  个，那么合并完之后就有  个斜率为正的拐点，那么弹出  个最大的拐点即可。\r\n把  向右平移一个  ，这个只需要删除拐点 ，加入拐点  即可。\r\n插入一条斜率为 \r\n的直线，这个在第三项中其实就已经处理完了。\r\n\r\n以上操作都可以用一个可合并的大根堆维护，写个左偏树即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6e5 + 5;typedef long long ll;struct node{\tint lc,rc,dis;\tll val;}tr[N];int Merge(int x,int y){\tif(!x || !y) return x + y;\tif(tr[x].val &lt; tr[y].val) swap(x,y);\ttr[x].rc = Merge(tr[x].rc,y);\tif(tr[tr[x].lc].dis &lt; tr[tr[x].rc].dis) swap(tr[x].lc,tr[x].rc);\ttr[x].dis = tr[tr[x].rc].dis + 1;\treturn x;}inline int Pop(int x) { return Merge(tr[x].lc,tr[x].rc);}int rt[N];int n,m;int fa[N],C[N],sons[N];int main(){\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 2;i &lt;= n + m;i++)\t\tcin &gt;&gt; fa[i] &gt;&gt; C[i],++sons[fa[i]];\tll ans = 0;\tint tot = 0;\tfor(int i = n + m;i &gt; 1;i--)\t{\t\tll l = 0,r = 0; // 维护斜率为 0 的那些线段\t\tif(i &lt;= n) // 非叶\t\t{\t\t\twhile(--sons[i]) rt[i] = Pop(rt[i]);\t\t\tr = tr[rt[i]].val;rt[i] = Pop(rt[i]);\t\t\tl = tr[rt[i]].val;rt[i] = Pop(rt[i]);\t\t}\t\ttr[++tot].val = l + C[i];\t\ttr[++tot].val = r + C[i];\t\trt[i] = Merge(rt[i],Merge(tot,tot - 1));\t\trt[fa[i]] = Merge(rt[fa[i]],rt[i]);\t}\tfor(int i = 2;i &lt;= n + m;i++) ans += C[i]; // f(0)\twhile(sons[1]--) rt[1] = Pop(rt[1]);\twhile(rt[1]) ans -= tr[rt[1]].val,rt[1] = Pop(rt[1]);\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["DP","Slope trick"]},{"title":"CF1229F 题解","url":"/posts/2322247108/","content":"CF1229F 题解\r\n除了官方题解，我在百度上还没有搜到关于这题比较详细的描述，故写篇题解造福社会，希望对读者有益。\r\n题意：给出  个数 ，在一个环上均匀分布着  个点，每个点初始有 \r\n张牌。你一次操作可以选择一个点，将其上的一张牌移到与其相邻的位置，花费\r\n\r\n的代价。求最少的代价，使得调整完后，第  个点上的牌数在  之间。\r\n。\r\n\r\n\r\n首先考虑断环为链。\r\n具体地，设  表示由  向  运送的牌数（ 可以为负，这等价于由  向  运送  张牌），特别地， 为由  向  运送的牌数。\r\n那么断环为链，就是钦定 \r\n为一个特定的值 ，即把这条边的决策先做掉。\r\n那么向后做的时候，设 \r\n表示钦定 ，且第二张，第三张，...，第  张牌均已经满足条件的最小代价。\r\n考虑  如何从  转移过来。\r\n首先，会有限制：。\r\n即 。（特别地，）\r\n令 \r\n对应到  上就是 。\r\n用滑动窗口转移就可以把这个 DP 做到 。\r\n进一步优化的话，需要发现这个  的性质，这也是为什么，我把 DP\r\n数组写成函数的形式，而非二维数组。\r\n考虑到，我们每次对 \r\n的操作是：将每个点替换成包含它的一段区间的最小值，给  加上一个凸函数。\r\n容易归纳证明，对于任意 ， 都是凸函数。\r\n既然看出来了是凸的，我们不妨考察斜率，我们发现一次  的操作，会把一段的斜率减小\r\n，另一段的斜率增大 。总的来看，斜率总是会在  之间。\r\n那么可能的斜率数量也很有限。\r\n那么我们不妨从这一点入手来维护这个凸函数：维护这个函数的所有拐点。\r\n拐点是什么呢？就是你考虑到这个函数是凸的，且呈现明显的分段特征，每段内部是一条直线，且直线的斜率从左往右单调递增，我们维护的就是每一段的端点。\r\n我们接下来称这类凸函数为“折线”。\r\n类似下图：\r\n\r\n这是一个折线，其中红线代表拐点，即两段之间的分界点，数字代表每一段的斜率。\r\n我们发现，只要维护了拐点集合，那么两个拐点之间的斜率也可以推得，具体地，我们同时维护斜率\r\n 和斜率  的拐点集合 ，那么每相邻三个拐点所对应的两段函数，斜率就会相差\r\n，如果实际上这两段的斜率差 ，那么我们就重复加入一些拐点，使其满足上面的条件即可。（比如说， 中最大拐点与次大拐点之间的直线斜率就是\r\n，再往左是 ，以此类推）\r\n现在我们维护了拐点集合，考虑我们的操作对其产生的影响。\r\n再次整理我们的操作：\r\n\r\n令  为 ，将 \r\n替换为 。\r\n令  为 ，将  替换为 。\r\n取出  的区间最小值（因为\r\n 有个范围）\r\n\r\n设 中间那段斜率为  的段为 。\r\n考虑操作 。\r\n对于 ，\r\n对于 ，。\r\n否则，。\r\n画个图就可以知道，我们相当于把函数左半边向左平移 ，把函数右半边向右平移 。对于中间那段斜率为  的，我们相当于将其伸长了。\r\n反应在拐点上，就是 \r\n中的数同时减去 ， 中的数同时加上 。用两个数维护平移量即可。\r\n考虑操作 。\r\n我们把  拆成两个函数：。\r\n这两个函数分别对应 \r\n的左右半边，我们以 \r\n为例，来讲述怎么处理。\r\n这相当于我们将一个折线加上一条斜率为  的射线。\r\n分类讨论：\r\n\r\n如果 ，那么画图可得，\r\n中的直线没有任何变化，而对于 \r\n中的点，如果其在 \r\n的左边，那么它那里的直线斜率要 。因为一个拐点就表示了一次斜率的变化，我们直接将\r\n 这个点加入  即可。\r\n否则，我们会发现，\r\n中的一些直线的斜率会减 \r\n，比如说， 这一段的斜率就从\r\n 变成了 。我们发现，除开这一段以外，其它的在\r\n 左边的直线斜率都减小了 ，但正负号没变。那我们把  从  中弹出，加入  中，并将  加入  中即可。\r\n\r\n加上  是一样的。\r\n考虑操作 ：\r\n首先我们要知道 \r\n的全局最小值，即斜率为 \r\n的那一段的函数值，这个可以在操作 \r\n中顺带维护出来。\r\n那么考虑询问区间  和斜率为\r\n 的区间  的关系。\r\n如果它们有交，直接输出 \r\n即可。\r\n否则，假设  在  左边，容易发现 \r\n（因为这一段的斜率都小于 ）。\r\n考虑从  到 \r\n中间的那些折线，因为我们已经维护了拐点集合，可以方便地将其提取出来，斜率也是可以算的。\r\n那直接从  一路推到  即可。\r\n 和  都可以用两个堆维护，本人偷懒写了个\r\nset。\r\n具体可以看代码。\r\n\r\n好了，现在我们会了 \r\n确定的情况了，那环怎么做呢？\r\n结论：设  表示一个  所对应的最小代价，那么  关于  也是凸的。\r\n证明大概分为两部分：\r\n\r\n证明如果 \r\n的取值范围是实数，那么不改变最优解。\r\n证明：如果  和\r\n 都是  的一组最优解，那么\r\n\r\n也是一组最优解。这可以推出 \r\n\r\n所以，我们对 \r\n进行一个三分即可。\r\n本题总时间复杂度为 \r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3.5e4 + 5;typedef long long ll;int n,a[N],L[N],R[N];struct Heap{\tmultiset&lt;ll&gt; S;\tll tag;\tinline void clear() { S.clear();tag = 0;}\tinline void insert(ll x) { S.insert(x - tag);}\tinline void erase(ll x) { S.erase(S.find(x - tag));}\tinline void shift(ll x) { tag += x;}\tinline ll Greatest() { return tag + *S.rbegin();}\tinline ll Lowest() { return tag + *S.begin();}\tinline int size() { return S.size();}};Heap ql,qr;long long ans = 0;inline void addL(ll x) // x - t{\tif(x &lt;= qr.Lowest()) {ql.insert(x);return;}\tll tmp = qr.Lowest();\tqr.erase(tmp);ql.insert(tmp);qr.insert(x);\tans += x - ql.Greatest();}inline void addR(ll x){\tif(x &gt;= ql.Greatest()) { qr.insert(x);return;}\tll tmp = ql.Greatest();\tql.erase(tmp);qr.insert(tmp);ql.insert(x);\tans += qr.Lowest() - x;}inline ll GetVal(ll l,ll r) // 折线的区间最值{\tif(l &lt;= qr.Lowest() &amp;&amp; ql.Greatest() &lt;= r) return ans;\tif(l &gt; qr.Lowest())\t{\t\tlong long delta = 0;\t\tlong long lst = qr.Lowest();qr.erase(lst);qr.insert(l);\t\tint K = 1;\t\twhile(qr.size() &amp;&amp; qr.Lowest() &lt;= l)\t\t\tdelta += 1ll * K * (qr.Lowest() - lst),\t\t\tlst = qr.Lowest(),qr.erase(lst),++K;\t\treturn ans + delta;\t}\tif(r &lt; ql.Greatest())\t{\t\tlong long delta = 0;\t\tlong long lst = ql.Greatest();ql.erase(lst);ql.insert(r);\t\tint K = 1;\t\twhile(ql.size() &amp;&amp; ql.Greatest() &gt;= r)\t\t\tdelta += 1ll * K * (lst - ql.Greatest()),\t\t\tlst = ql.Greatest(),ql.erase(lst),++K;\t\treturn ans + delta;\t}}inline ll Solve(ll x1){\t// printf(\"x1:%lld\\n\",x1);\tql.clear();qr.clear();ans = abs(x1);\tfor(int i = 1;i &lt;= n + 1;i++)\t\tql.insert(x1),qr.insert(x1);\tfor(int i = 2;i &lt;= n;i++)\t{\t\tint dl = L[i] - a[i],dr = R[i] - a[i]; //[x - dl,x + dr]\t\tql.shift(-dr);qr.shift(-dl);\t\taddL(0);addR(0);\t}\t// puts(\"done\\n\");\t//  L_1 \\le a_1 - x_1 + x_n \\le R_1\tll nowl = L[1] - a[1] + x1,nowr = R[1] - a[1] + x1;\t// printf(\"%lld %lld %lld\\n\",nowl,nowr,ans);\t// printf(\"ql: \");\t// for(auto it : ql.S) printf(\"%lld \",it + ql.tag);printf(\"\\n\");\t// printf(\"qr: \");\t// for(auto it : qr.S) printf(\"%lld \",it + qr.tag);printf(\"\\n\");\tll res = GetVal(nowl,nowr);\t// printf(\"res:%lld\\n\",res);\treturn res; }int main(){\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++)\t\tcin &gt;&gt; a[i] &gt;&gt; L[i] &gt;&gt; R[i];\tll lef = -1e18,righ = 1e18;\twhile(righ - lef &gt; 5)\t{\t\t\tll lmid = (lef + righ) &gt;&gt; 1,rmid = lmid + 1;\t\tif(Solve(lmid) &lt; Solve(rmid)) righ = rmid;\t\telse lef = lmid;\t}\t\tll ans = 1e18;\tfor(ll i = lef;i &lt;= righ;i++)\t\tans = min(ans,Solve(i));\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n本题中，维护折线的技巧有一个好听的名字：Slope\r\ntrick，我们通过拐点集合，恰当地表示出了折线的信息，且让操作变得十分简单，虽然这个转化本身比较抽象。（\r\n类似的题目还有：CF713C，ABC217H，ARC123D\r\n","tags":["DP","Slope trick"]},{"title":"AGC006 DEF 题解","url":"/posts/2734878942/","content":"AGC006D\r\n题意：给出一个长度为 \r\n的排列。构造一个 \r\n层金字塔，最底层是该排列，其他层的数字按如下方式生成：方格  中填写的整数，是方格 \r\n正下方，左下方和右下方方格中所写整数的中位数。。\r\n\r\n现在请求出第一层的数字。\r\n\r\n看到题之后一眼二分答案，然后找性质失败。\r\n事实证明当时做的时候还是太浮躁了。如果二分答案完了之后，有两个连续的\r\n 或两个连续的 ，那么它们肯定不会被别的东西给抹掉，只有可能因为到达边界而自行消除。\r\n所以我们找到距离中点最近的相邻的一对  即可。\r\n事实上，不会出现最近的 \r\n和最近的 \r\n离中点距离相同的情况，读者可以自证。\r\n如果找不到，说明原序列一定是 \r\n相间，判断是容易的。\r\nAGC006E\r\n题意：给出  行  列的初始矩阵，第  行第  列的数为 。\r\n我们有一个这样的操作：选择一个  的子矩阵，将这个子矩阵旋转  （具体见下面的图）。\r\n现在给出一个  行 \r\n列的矩阵，问能否若干次操作使初始矩阵变成目标矩阵。\r\n\r\n没有找到什么基本性质。/kk\r\n首先，每一列的状态只可能是 \r\n或者 \r\n之类的，连续三个递增或递减的数。因为每次操作只会颠倒某些列，并移动某些列的位置。先把这个判掉。\r\n那么每一列的状态就可以编码成一个数 ，一次操作相当于让 \r\n变成它们的相反数，并交换 。目标是让 。\r\n我们发现奇数位置和偶数位置是相对独立的。如果交换了两个奇数位置，那么奇数位置的负号个数的奇偶性不会改变，而偶数位置的会改变\r\n。\r\n而为了让绝对值从小到大排序，我们对奇数位置的交换次数必须和奇数位置的逆序对数同奇偶。\r\n那么这就说明：奇数位置的逆序对数和偶数位置的负号个数，奇偶性应该是相同的。同理，偶数位置的逆序对数和奇数位置的负号个数的奇偶性应该是相同的。\r\n这是一个必要条件。充分性的话，因为我们能用若干次操作把  和 \r\n同时变成它们的相反数，并不改变其他数，所以先按绝对值进行排序，然后用这种操作把负号都做掉即可。\r\n这个“若干次操作”可以参看洛谷题解。\r\nAGC006F\r\n题意：给出一张有向图 。\r\n不断重复如下操作：取出三个点 ，如果  有边， 有边， 没有边，那么连边 。\r\n请计算没有边可以添加的时候的边数。\r\n做的时候在手玩树形图，看出来了跟层有关，但根本想不到如何推广。\r\n首先对每个连通块单独考虑，然后尝试三染色。\r\n这个三染色是怎么染色呢，我们希望对于边 ，都有 ，所以我们连边 ，，然后进行 dfs 即可。\r\n考虑三染色失败了怎么办，这个时候任意两点之间都会有连边，答案为点数的平方，证明就是考虑\r\ndfs 树上一条使其失败的返祖边。\r\n如果成功了，但三种颜色没有用满，那么不会出现 \r\n这种东西，故答案为原先的边数。\r\n否则可以猜出答案为 ，即异色点之间有单向边。接下来考虑证明。\r\n肯定存在一条链  满足\r\n。\r\n归纳构造，假设图 \r\n已经满足上述结论，考虑新加入一条边  的情况。\r\n接下来设  表示  的点的集合。\r\n由于 ，所以\r\n。\r\n由于 ，所以 。\r\n可以发现无法存在其他的边，得证。\r\n因为  是本质相同的， 和  也是本质相同的，故其他情况不再赘述。\r\n直接算答案即可。属于是想到了“染色”就能做大部分甚至做完的题。\r\n","tags":["AGC 板刷记录"]},{"title":"ARC064D 题解","url":"/posts/891700191/","content":"这题一眼望过去，用不了什么现成的科技，最朴素的思路就是，考虑每个串会被算几次。\r\n\r\n事实上，一个串会被算多次，也意味着有两个回文串互相循环同构。\r\n循环同构也会出现所谓“重复”的情况，这与一个串的最小整周期有关。\r\n如果一个回文串的最小整周期为 ，那么只有  个串是“可能有用的”\r\n故我们先考虑一个周期内的问题。\r\n回文串有两种： 和  ( 表示  的翻转， 表示一个字符)\r\n对于 \r\n，与其循环同构的回文串只有 \r\n对于 ，没有与其循环同构的回文串。（这就是我没有发现的地方）\r\n所以如果 \r\n是偶数，一个回文串会带来  的贡献，否则带来  的贡献。\r\n接下来考虑如何算周期为 \r\n的回文串个数。\r\n先可以算周期是 \r\n约数的回文串个数，为 ，再用其约数的答案来减即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6000,P = 1e9 + 7;inline int qpow(int a,int b) { int res = 1;while(b) {if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;} return res;}int factor[N],f[N],tot,n,k;int main(){\tscanf(\"%d%d\",&amp;n,&amp;k);\tfor(int i = 1;i * i &lt;= n;i++)\t{\t\tif(n % i) continue;\t\tfactor[++tot] = i;\t\tif(i * i != n) factor[++tot] = n / i;\t}\tsort(factor + 1,factor + tot + 1);\tint ans = 0;\tfor(int i = 1;i &lt;= tot;i++)\t{\t\tf[i] = qpow(k,(factor[i] + 1) &gt;&gt; 1);\t\tfor(int j = 1;j &lt; i;j++)\t\t\tif(factor[i] % factor[j] == 0) (f[i] += P - f[j]) %= P;\t\tans = (ans + 1ll * ((factor[i] &amp; 1) ? factor[i] : factor[i] / 2) * f[i] % P) % P;\t}\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting","string theory"]},{"title":"ARC146E 题解","url":"/posts/302081082/","content":"因为之前做过水淹笛卡尔树的题（ARC117E），一眼看出了 DP\r\n状态，后面就不会了，题解告诉我第二维有效状态不超过 \r\n个，人有点麻。也是没有仔细思考的缘故。\r\n\r\n按值域从小到大 DP，每次考虑插入  个 。\r\n假设已经插入的数形成了 \r\n个连续段，显然，除了最左和最右的连续段，剩下的段的两端都是 （不然就无法满足相邻位置差为 ）\r\n这提示我们最左边和最右边有一些特殊性。\r\n事实上，如果最左边是 ，那么当前的 \r\n还可以插到左边，否则不行。右边同理。\r\n那么我们设 \r\n表示当前做到 ，一共形成了  个连续段，最左边是不是 ，最右边是不是 。\r\n转移有两个方面，第一是 \r\n的变化，第二是转移系数。\r\n如果我们想在最左和最右都填上 \r\n的话，我们首先会把  个  填在每个连续段的两侧，然后剩余的  个  会贡献  个连续段，总段数就是 。\r\n如果想在某几侧不填上 \r\n的话，道理是一样的，将结果  或\r\n 即可。\r\n考察转移系数，还是以 \r\n为例，这时一共会有 \r\n个空隙，每个空隙都必须有数，这就是个插板法，方案数为 。\r\n直接这么做，看上去可以达到平方复杂度，但是，我们发现 \r\n的变化方法较为单一，它只有可能在每轮中由  变为 ，或在  或  变化时加上  或者 。\r\n我们处理出  表示如果前\r\n\r\n轮，每轮都在两边放数，会有几个连续段（显然有 ）。\r\n那么  的取值只会在  附近，取  即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5,P = 998244353;inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}int n,a[N],cur[N];int dp[N][7][2][2];int fac[N],ifac[N];inline void init(int n){\tfac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tifac[1] = 1;\tfor(int i = 2;i &lt;= n;i++) ifac[i] = 1ll * ifac[P % i] * (P - P / i) % P;\tifac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) ifac[i] = 1ll * ifac[i - 1] * ifac[i] % P;}inline int C(int n,int m) { if(n &lt; 0 || m &lt; 0 || n &lt; m) return 0;return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;}int main(){\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++)\t\tcin &gt;&gt; a[i];\tcur[1] = a[1];\tdp[1][2][1][1] = 1;\tinit(2e5);\tfor(int i = 2;i &lt;= n;i++)\t{\t\tcur[i] = a[i] - cur[i - 1]; // 如果两边都不放 i,会有多少对相邻的 i\t\tfor(int j = 0;j &lt;= 6;j++)\t\t\tfor(int u = 0;u &lt;= 1;u++)\t\t\tfor(int v = 0;v &lt;= 1;v++)\t\t\tif(dp[i - 1][j][u][v])\t\t\t{\t\t\t\tfor(int p = 0;p &lt;= u;p++)\t\t\t\tfor(int q = 0;q &lt;= v;q++)\t\t\t\t{\t\t\t\t\tint val = dp[i - 1][j][u][v],c = cur[i - 1] + j - 2; // c 表示实际有多少对相邻的 i\t\t\t\t\tif(p == 0 &amp;&amp; q == 0)\t\t\t\t\t\tPlus(dp[i][6 - j][p][q],1ll * val * C(a[i] - 1,c - 2) % P); // 4 - j : a - 原段数 + 2\t\t\t\t\tif(p == 1 &amp;&amp; q == 1 &amp;&amp; j &lt;= 4)\t\t\t\t\t\tPlus(dp[i][4 - j][p][q],1ll * val * C(a[i] - 1,c) % P); // 2 - j: a - 原段数\t\t\t\t\tif(p + q == 1 &amp;&amp; j &lt;= 5)\t\t\t\t\t\tPlus(dp[i][5 - j][p][q],1ll * val * C(a[i] - 1,c - 1) % P);\t\t\t\t}\t\t\t}\t\tfor(int j = 0;j &lt;= 6;j++)\t\t\tfor(int u = 0;u &lt;= 1;u++)\t\t\t\tfor(int v = 0;v &lt;= 1;v++)\t\t\t\t\tprintf(\"f[%d][%d][%d][%d]=%d\\n\",i,cur[i] + j - 2,u,v,dp[i][j][u][v]);\t}\tint ans = 0;\tfor(int i = 0;i &lt;= 6;i++)\t\tfor(int u = 0;u &lt;= 1;u++)\t\t\tfor(int v = 0;v &lt;= 1;v++)\t\t\t\tif(cur[n] + i - 2 == 1)\t\t\t\t\tPlus(ans,dp[n][i][u][v]);\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting"]},{"title":"AGC007 DEF 题解","url":"/posts/950516913/","content":"AGC007D\r\n简单题，虽然对数轴上游走的题还是不太会。\r\n\r\n一眼看出了状态，转移懒得编了（以后还是要编转移，现在编转移的能力有些弱）。\r\n容易发现，路径一定是先往前走一段，再折回一段，再往前走，走了一段再折，再走。\r\n说白了，一个点要么被经过一次，要么被经过三次。\r\n那么设  表示收到前  个糖果的最小时间，此时人一定在 。\r\n那么枚举位置 ，\r\n中的点被一次折返收完，那么有转移 \r\n写出这个转移式子之后，优化非常简单，分类讨论那个  取到谁即可。因为  和  均不降，转移容易。\r\nAGC007E\r\n好题。\r\n题意：给出一棵二叉树，每个节点只有  或  个儿子。\r\n要求你从  走回 ，每天你可以从二叉树的一个叶子走到另一个叶子，或从\r\n 走到某个叶子，或从某个叶子走到\r\n。要求你经过二叉树上的所有叶子，且每条边被经过恰好两次。\r\n你的花费是最大的，从叶子到叶子的那一天经过的边的权值和，求最小花费。\r\n。\r\n首先二分答案，然后设  状态\r\n 表示从  开始游走，能否在第一天走过不超过  的距离，在第二天走过不超过  的距离。\r\n那么有转移 \r\n交换 \r\n后再转移一遍即可。\r\n当时只是觉得，这个转移形式有点双指针，然后想着能不能只记录一维，觉得挺假就没往下想了。\r\n事实证明，确实需要双指针。\r\n首先，对于同为  的状态  和  ，如果 ，那么后者完全无用。\r\n所以你按  升序排序之后， 一定是降序的。\r\n显然，对于每一个 \r\n都只需要考虑一个令 \r\n最小且满足转移式的 。所以，每一个  中的状态都只需要与一个对应的  转移到 \r\n中的唯一一个状态。所以，设左右子树的状态数分别为 ，那么一次转移只会增加最多  个状态（因为要把\r\n 交换后再转移一遍，所以要乘个\r\n）。\r\n根据启发式合并的复杂度分析，总状态数是  的。\r\n找到每个状态对应的状态可以使用双指针，总时间复杂度是  的。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = (1 &lt;&lt; 17) | 5;typedef long long ll;typedef pair&lt;ll,ll&gt; pll;#define FI first#define SE secondint n;int son[N][2],w[N][2];vector&lt;pll&gt; st[N]; // 状态集合void DP(int x,ll mid){\tst[x].clear();\tif(!son[x][0]) {st[x].emplace_back(0,0);return;}\tDP(son[x][0],mid);DP(son[x][1],mid);\tll tmp = mid - w[x][0] - w[x][1];\tvector&lt;pll&gt; vec;\tint num = 0;\tfor(int d = 0;d &lt; 2;d++)\t{\t\tint lc = son[x][d],rc = son[x][d ^ 1];\t\tfor(int i = 0,j = 0;i &lt; st[lc].size();i++)\t\t{\t\t\twhile(j + 1 &lt; st[rc].size() &amp;&amp; st[rc][j + 1].FI + st[lc][i].SE &lt;= tmp) ++j; //双指针\t\t\tif(j &gt;= st[rc].size() || st[lc][i].SE + st[rc][j].FI &gt; tmp) continue;\t\t\tvec.emplace_back(w[x][d] + st[lc][i].FI,w[x][d ^ 1] + st[rc][j].SE);\t\t}\t\tif(d == 0) num = vec.size();\t}\tinplace_merge(vec.begin(),vec.begin() + num,vec.end()); // 用归并来合并两个状态序列。用 sort 是 3 log 的。\tfor(int i = 0;i &lt; vec.size();i++) // 删去无用状态\t{\t\tif(st[x].size() &amp;&amp; st[x].back().SE &lt;= vec[i].SE) continue;\t\tst[x].push_back(vec[i]);\t}}inline bool Check(ll mid){\tDP(1,mid);\treturn st[1].size() != 0;}int main(){\tcin &gt;&gt; n;\tll lef = 0,righ = 0;\tfor(int i = 2;i &lt;= n;i++)\t{\t\tint fa,v;\t\tcin &gt;&gt; fa &gt;&gt; v;righ += v;\t\tif(!son[fa][0]) son[fa][0] = i,w[fa][0] = v;\t\telse son[fa][1] = i,w[fa][1] = v;\t}\twhile(lef &lt; righ)\t{\t\tll mid = lef + righ &gt;&gt;1;\t\tif(Check(mid)) righ = mid;\t\telse lef = mid + 1;\t}\tcout &lt;&lt; lef &lt;&lt; endl;\treturn 0;}\r\nAGC007F\r\n题意：\r\nShik 需要抄写一个字符串，一开始，纸面上有一个字符串 ，每次她写下字符串  的时候， 有可能与  相同，也可能与  相同。\r\nShik 希望抄写尽量少的字符串，就能使最后再纸上的字符串与  相同，具体地，她希望找到最小的整数\r\n，使得存在一种方案让 。\r\n。\r\n首先把图画出来，\r\n中的一个字符肯定对应的是 \r\n中的一段区间。每个字符相当于在平面上向右或向下走。\r\n当时的直觉是从后往前做，每个字符的匹配段都往右靠一定不劣，然后根据每个字符对应的区间设计\r\nDP。\r\n事实上，这样设计 DP 反倒会丢失路径信息。\r\n考虑我们在不改变每个字符所对应区间的情况下，把中间走过的路径尽量往右靠，那么一定不劣。\r\n而具体的策略就是：一直尽量右移，直到走到要覆盖的左边界，然后一直向下，最后横向覆盖。\r\n有图如下（来自 @command_block）：\r\n\r\n考虑从右往左，从一条折线变到另一条折线时的变化。\r\n假设当前  要到达  （ 是区间左边界）\r\n那么那些横坐标大于等于 \r\n的拐点要弹出。\r\n然后，原来所有的拐点都会往左下方平移一格（因为新折线要尽量贴近原来的折线）。\r\n最后，如果 \r\n，那么在横坐标为 \r\n的地方会有一个拐点。\r\n（上述所有拐点均不包括最后一行）。\r\n我们可以用一个队列来维护拐点集合，队头是更加靠近目标串的，队尾是更加靠近\r\n 的。\r\n上述操作都可以用队列维护。\r\n核心代码如下：\r\nwhile(down){\twhile(down &gt; 1 &amp;&amp; t[down - 1] == t[down]) --down;\twhile(up &gt;= 1 &amp;&amp; (up &gt; down || s[up] != t[down])) --up;\tif(!up) { puts(\"-1\");return 0;}\twhile(!Q.empty() &amp;&amp; Q.front() - (int)Q.size() &gt;= down) // 这里减去 Q.size 是因为，每加入一个拐点，已有的拐点都会往左下方平移一格，这是本题所维护的折线的性质。\t\tQ.pop();\tif(up != down) Q.push(up);\tans = max(ans,(int)Q.size() + 1);\t--down;}\r\n答案是队列大小 +1 的历史最大值。\r\n因为可以归纳证明，每条折线的拐点的横坐标都是连续的（即都位于连续的前几行）。\r\n大致是说，这对于最右的折线显然成立，而其它的折线都会尽量往右靠。\r\n一道思路比较清奇的题。\r\n","tags":["AGC 板刷记录"]},{"title":"P7213 题解","url":"/posts/2642165753/","content":"最近对计数题的训练还是让我很有收获的。能想出这题的主状态，说明我有了一定的计数水平。但最后因为懒于编转移看了题解，其实这并没有必要。以后还是要自己把转移讨论出来，哪怕漏了几类也没有关系。毕竟考场上，状态和转移都需要自己推。\r\n\r\n首先，有一个基本的观察：\r\n​\r\n每一次地震，对于最大的有两个位置的高度，靠右的那个位置一定会被保留下来，再也不会变化。\r\n“最大的”，”靠右“，诸如此类的字眼，提示我们从后往前考虑问题，并从值域入手设计状态。\r\n但现在还没有直接的思路，需要进一步观察。\r\n从后往前推，对于第 \r\n个位置，它显然可以活着。\r\n对于第  个位置，如果它和第\r\n 个位置都是 ，它就会寄，否则一定能活下来。\r\n对于第  个位置，如果它是\r\n ，且后面有 ，或者它是 ，且后面也有 ，它就得寄，否则会活。\r\n（注意，上述的状态都是在某次地震后的状态，不一定是最初的）\r\n以此类推，我们发现：\r\n如果在某次地震后，高度为 \r\n的柱子后面，高度为 \r\n的柱子都至少出现了一次，那这根柱子一定活不下来。\r\n进一步地说，我们从后往前扫到一个位置 ，如果  没有在后面的位置出现过，那么  就是当前位置的最终值，否则  会一直减到后面没有出现 ，减到  为止。\r\n事实上，这个“在后面没有出现”，你只需要考虑在后面的最终值中，\r\n有没有出现，而不需要考虑“某次地震以后”，因为地震并不会缩小高度的集合，以前出现的高度，地震过后还是出现，这是显然的，而我们显然不会做多余的事情，因为基于最终值推导出的变化肯定需要执行。\r\n那么我们就只需要考察 这些柱子高度的最终值 以及\r\n形成这些最终值的方式\r\n（这看上去是句废话，但你会发现，通过上面的观察，考察后者变得简单了很多）。\r\n考察这些的柱子的最终值，它们会在值域上形成一些连续段，而与一个柱子的存亡有关的就是那个最低的连续段。\r\n那么我们就可以设出状态 \r\n表示考虑到了位置 ，在最终值上， 的柱子都出现过，但  未出现过的答案。\r\n有些读者可能会发现这个 \r\n长得很像 MEX，事实上，这题的转移与 CF1608F MEX Counting\r\n的思想是相同的。我们接下来细说。\r\n在下文，我们假设值相同的两个柱子是有区别的，最后将答案除以 。\r\n为方便描述，接下来设  表示\r\n\r\n中钦定倒塌的柱子数量， 表示\r\n\r\n中钦定存留的柱子数量。\r\n如果  位置钦定倒塌：\r\n那么该位置的取值只能是 ，一共有 \r\n个数可以选择，而我们之前选 \r\n的时候已经用掉了  个数，还有  个数用在了那  个倒掉的柱子上，故这一位的方案数是\r\n，故有转移式 。\r\n如果  位置钦定存活：\r\n那么需要分类讨论：\r\n\r\n 位置的最终值大于 ，此时我们不能确定什么，所以使用\r\nCF1608F 中的”延迟贡献“思想，将这一个数留到后面再来确定，即转移 。\r\n 位置的最终值等于 ，那么我们所需要做的工作会复杂一些，我们可能要把值域上最小和次小的连续段拼起来。\r\n考虑从  转移到 。\r\n那么我们首先要确定 \r\n位置初始值该填什么，显然，其只能从  里面选（因为这些数都出现过  次了，在这里只有  的贡献），同时还可以选两个  ，总计  种选法。\r\n然后考虑确定 \r\n的位置，我们当然只能在活着的柱子里选，目前只有 \r\n个活着的柱子等待决策的，故方案数为 。（这里就把情况\r\n\r\n中的“延迟决策”放到了这一步进行计算）\r\n对于这 \r\n个数，我们还要确定其初始值的填法，我们考虑计数这个东西需要解决什么限制。\r\n我们需要在  这  个数中选出  个数，使得其在地震完之后是一个长度为\r\n 的排列。\r\n这个条件还是很复杂，考虑必要条件：对于每个 ，值  的元素的个数 。\r\n必要性显然，因为如果存在一个 \r\n使得不超过  的元素个数 ，那必然有一个柱子可以滑到 。\r\n然后我们发现这个条件是充分的，因为这样的序列肯定不劣于一个排列（排列会把每个限制都取到等号），而排列一定合法。\r\n基于上述条件，可以设计一个  表示填了数 ，一共用了  个位置的方案数。枚举当前数填  个转移即可：\r\n\r\n汇总上述分析，得出转移式： \r\n\r\n跑上述的 DP 即可。时间复杂度 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6e2 + 5,P = 1e9 + 7;inline void Plus(int &amp;x,const int &amp;y) { x += y;if(x &gt;= P) x -= P;}inline int qpow(int a,int b) { int res = 1;while(b) {if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;} return res;}bool alive[N &lt;&lt; 1];int f[N &lt;&lt; 1][N],g[N][N];int n;int C[N][N];inline int Binom(int n,int m) { if(n &lt; 0 || m &lt; 0 || n &lt; m) return 0;return C[n][m];}int main(){\tcin &gt;&gt; n;\tfor(int i = 1,x;i &lt;= n;i++)\t\tcin &gt;&gt; x,alive[x] = true;\tC[0][0] = 1;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tC[i][0] = C[i][i] = 1;\t\tfor(int j = 1;j &lt; i;j++)\t\t\tC[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\t}\tg[0][0] = 1;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tg[i][0] = 1;\t\tfor(int j = 1;j &lt;= i;j++)\t\t{\t\t\tPlus(g[i][j],g[i - 1][j]);\t\t\tif(j) Plus(g[i][j],2ll * j * g[i - 1][j - 1] % P);\t\t\tif(j &gt; 1) Plus(g[i][j],1ll * j * (j - 1) * g[i - 1][j - 2] % P);\t\t}\t}\tint sum = 0;\tf[n * 2 + 1][0] = 1;\tfor(int i = n * 2;i &gt;= 1;i--)\t{\t\tif(alive[i])\t\t{\t\t\tfor(int j = 0;j &lt;= n;j++)\t\t\t{\t\t\t\tPlus(f[i][j],f[i + 1][j]);\t\t\t\tfor(int k = 1;k &lt;= j;k++)\t\t\t\t\tPlus(f[i][j],1ll * f[i + 1][j - k] * Binom(sum - (j - k),k - 1) % P * (k + 1) % P * g[k - 1][k - 1] % P);\t\t\t}\t\t\t++sum;\t\t}\t\telse\t\t{\t\t\t\tint ded = n * 2 - i - sum;\t\t\tfor(int j = 0;j &lt;= n;j++)\t\t\t\tif(j &gt;= ded)\t\t\t\tPlus(f[i][j],1ll * f[i + 1][j] * (j - ded) % P);\t\t}\t}\tint ans = 1ll * f[1][n] * qpow((P + 1) / 2,n) % P;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting"]},{"title":"AGC028D 题解","url":"/posts/1943078264/","content":"这题我和王队合力做，王队想到了第一个转化，我想到了第二个转化，但是并没有导出成型的做法，看来，关键时候的坚持确实十分重要。\r\n不要被难度标签所吓到。现在来看，我每次都能隐约想到正解的一些东西，但难出做法，很可能是对算法理解不够深入。\r\n但又该怎么提升呢？也许多做题是有用的。我也能感觉得出来，最近做的题质量有提升。希望这是好的开始。\r\n\r\n首先，这题在圆上和在序列上做是没有区别的，两条在圆上相交的线段在序列上也是相交的，反之亦然。\r\n那么，在序列上，线段相当于一段区间，而一堆有交的线段，看上去就像一个大区间。\r\n事实上，对于一个连通块，我们考察其最左边的点  和最右边的点 ，一个连通块显然对应一个区间。\r\n都观察到这里了，我居然想设计一个从前向后的 DP（\r\n看来思考的时候，在草稿纸上写清楚已有的结论至关重要。\r\n设  表示对应区间为  的连通块数，并附加限制：且  中没有点向 \r\n之外连边（包括我们所计数的连通块，也包括这个连通块以外，但在  中的点）。\r\n设  表示  个点任意匹配的方案数，在  为偶数时，其为 ，在  为奇数时其为 。\r\n设  表示区间 \r\n内还未确定匹配的点数（就是输入中未涉及到的点）。\r\n首先，如果 ，那么 。\r\n如果读者熟悉图计数的话，会知道一个计数连通块的套路：总方案减去 “ 号点所在连通块大小小于总数”\r\n的方案。\r\n这里也是要计数连通块，我们也还是先让 。\r\n然后枚举  号点所在连通块不是\r\n 的方案数，即 \r\n综上所述，有转移式： 。\r\n最后的答案就是 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6e3 + 5,P = 1e9 + 7;int n,K;int g[N],match[N];int dp[N][N],sum[N];inline int Cnt(int l,int r) { return sum[r] - sum[l - 1];}int main(){\tcin &gt;&gt; n &gt;&gt; K;n &lt;&lt;= 1;\tfor(int i = 1;i &lt;= K;i++)\t{\t\tint u,v;\t\tcin &gt;&gt; u &gt;&gt; v;\t\tmatch[u] = v;match[v] = u;\t}\tfor(int i = 1;i &lt;= n;i++)\t\tsum[i] = sum[i - 1] + (!match[i]);\tg[0] = 1;\tfor(int i = 2;i &lt;= n;i += 2)\t\tg[i] = 1ll * g[i - 2] * (i - 1) % P;\tint ans = 0;\tfor(int len = 2;len &lt;= n;len += 2)\t\tfor(int i = 1;i + len - 1 &lt;= n;i++)\t\t{\t\t\tint j = i + len - 1,flag = 1;\t\t\tfor(int x = i;x &lt;= j;x++)\t\t\t\tif(match[x] &amp;&amp; (match[x] &lt; i || match[x] &gt; j)) { flag = 0;break;}\t\t\tif(!flag) continue; \t\t\tdp[i][j] = g[Cnt(i,j)];\t\t\tfor(int k = i;k &lt; j;k++)\t\t\t\tdp[i][j] = (dp[i][j] + P - 1ll * dp[i][k] * g[Cnt(k + 1,j)] % P) % P;\t\t\tans = (ans + 1ll * dp[i][j] * g[n - 2 * K - Cnt(i,j)] % P) % P;\t\t}\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting"]},{"title":"ARC128E 题解","url":"/posts/3621638127/","content":"最近开的题都有些 atcoder,不过相比于看题解都看得一头雾水的\r\nARC127E,这题反而更加良心。\r\n已经想到了构造可行解的方法，但没有抽象出判断可行解的条件。看来卡在比较弱智的地方确实是个比较常见的事情。希望某天可以踢出这临门一脚。\r\n说到底还是在这方面没什么脑子（\r\n\r\n题意：请构造序列 ，满足元素\r\n () 在该序列中恰好出现\r\n 次，且任意连续 \r\n个元素都互不相同，或报告无解。有解则输出字典序最小的解。\r\n。\r\n首先考虑如何判断有无解，尝试设计一个贪心。\r\n既然是贪心，那就先满足最紧的限制，即先考虑  较大的元素，那么有一个方法就是隔\r\n 个位置放一个。\r\n然后容易想到对  序列每 \r\n个分一块，那么最先考虑的元素当然是放在每一块的起始位置。设块数为 ，最后一块长度为 （因为最后一块长度最小）。\r\n那么显然 ，且 。（就是这一步没有抽象出来）。\r\n构造的方法是简单的，按 \r\n从大到小考虑每个元素，然后每次选择空位最多的段插进去即可。\r\n然后基于此设计贪心使得字典序最小。\r\n然后可以猜出一个贪心，即每次找到前  个位置中未出现的最小的元素，如果此时 ，那就只能选  的元素，然后处理后面长度  的子问题。\r\n证明正确性，我们就是要证明，只要初始序列有解，每个时刻就都能选一个数出来。\r\n反证法，考察第一个不合法的时刻。\r\n\r\n如果 ，因为无数可选，所以  的所有数都在前面 \r\n个位置出现过，而如果将前面 \r\n个数加入进来重新分块，那么此时 ，但仍然有  个  的数，那么会有 ，但在合法条件下，这个策略肯定不会让这种事发生，故矛盾。\r\n如果 ，此时选数没有限制，无数可选只可能是因为  的数只有至多  个，设当前位置加上后面有  个空位，如果 ，那么显然后面无解，而 \r\n保证了后面有解，故矛盾。所以 ，那么此时 ，所有的  都会等于\r\n，所以 ，矛盾。\r\n\r\n综上所述，上述贪心一定可以构造出解，时间复杂度 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e2 + 5,M = 2e5 + 5;inline int Knum(int n,int k) { return (n + k - 1) / k;}inline int Klst(int n,int k) { return n % k == 0 ? k : n % k;}int n,k,len;int a[N];int ans[M];int ton[N];int main(){\tcin &gt;&gt; n &gt;&gt; k;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i],len += a[i];\tint num = 0;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tif(a[i] &gt; Knum(len,k)) return puts(\"-1\"),0;\t\tnum += (a[i] == Knum(len,k));\t}\tif(num &gt; Klst(len,k)) return puts(\"-1\"),0;\tfor(int i = 1;i &lt;= len;i++)\t{\t\tmemset(ton,0,sizeof ton);\t\tfor(int j = max(1,i - k + 1);j &lt; i;j++) ton[ans[j]] = true;\t\tnum = 0;\t\tfor(int j = 1;j &lt;= n;j++) num += (a[j] == Knum(len - i + 1,k));\t\tfor(int j = 1;j &lt;= n;j++)\t\t\tif(!ton[j] &amp;&amp; ((num &lt; Klst(len - i + 1,k) &amp;&amp; a[j])|| (num == Klst(len - i + 1,k) &amp;&amp; a[j] == Knum(len - i + 1,k))))\t\t\t{\t\t\t\tans[i] = j;\t\t\t\t--a[j];\t\t\t\tbreak;\t\t\t}\t}\tfor(int i = 1;i &lt;= len;i++)\t\tcout &lt;&lt; ans[i] &lt;&lt; ' ';\treturn 0;}\r\n","tags":["constructive algorithm","ARC 试题乱做"]},{"title":"P5161 题解","url":"/posts/140728207/","content":"这题属于是对字符串的复习，也是对“撒关键点” 的复习。\r\n\r\n提前计算长度为  的答案，即\r\n。\r\n把原数组变为差分数组，原问题变为间隔至少为  的子串对个数。\r\n那么答案就是 。\r\n这个间隔至少为 \r\n不好处理，我们不妨用  ，减去相邻或相交的子串对数。\r\n这个  是好做的，用 SA 跑出 height\r\n之后用单调栈解决即可。\r\n考虑这个 \"相邻或相交的子串对数\" 实际上就是对于  的 ，求  的和。\r\n不妨枚举 ，考察 \r\n的贡献。\r\n可以仿照 [NOI2016]\r\n优秀的拆分 的做法，在串上每隔  个位置撒一个关键点。\r\n那么对于这个 ，它就至少会经过一个关键点。\r\n不妨画图如下：\r\n\r\n图中  是一个关键点，红色的是\r\n 所代表的串。我们计算  的答案。\r\n容易发现，在  与  之后的红串，实际上就是 。\r\n我们令 。\r\n设 ，也就是红串的前半段的长度。\r\n那么一个  带来的贡献就是 。\r\n考虑  的范围。\r\n显然会有 （要不然前半段就不等了）\r\n然后还会有  （否则红串长度就小于  了）\r\n确定范围之后，上面要算的就是等差数列求和，直接计算即可。\r\n 和  都可以用 SA 求。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3e5 + 5;map&lt;int,int&gt; mp;int n;int a[N];struct SA{\tint sa[N],ton[N];\tint t1[N],t2[N];\tint s[N];\tinline bool Equ(int *r,int i,int j,int l) { return r[i] == r[j] &amp;&amp; r[min(n + 1,i + l)] == r[min(n + 1,j + l)];}\t#define For(i,a,b) for(int i = (a);i &lt;= (b);i++)\t#define Rof(i,a,b) for(int i = (a);i &gt;= (b);i--)\tinline void get_sa(int n,int m)\t{\t\tint *x = t1,*y = t2,*t;\t\tFor(i,1,m) ton[i] = 0;\t\tFor(i,1,n) ton[x[i] = s[i]]++;\t\tFor(i,1,m) ton[i] += ton[i - 1];\t\tRof(i,n,1) sa[ton[x[i]]--] = i;\t\tfor(int j = 1,p;j &lt;= n;j *= 2,m = p)\t\t{\t\t\tp = 0;\t\t\tFor(i,n - j + 1,n) y[++p] = i;\t\t\tFor(i,1,n) if(sa[i] &gt; j) y[++p] = sa[i] - j;\t\t\tFor(i,1,m) ton[i] = 0;\t\t\tFor(i,1,n) ton[x[i]]++;\t\t\tFor(i,1,m) ton[i] += ton[i - 1];\t\t\tRof(i,n,1) sa[ton[x[y[i]]]--] = y[i],y[i] = 0;\t\t\tt = x;x = y;y = t;p = 1;x[sa[1]] = 1;\t\t\tFor(i,2,n)\t\t\t\tx[sa[i]] = Equ(y,sa[i - 1],sa[i],j) ? p : (++p);\t\t\tif(p &gt;= n) break;\t\t}\t}\tint rk[N],height[N];\tint ST[19][N],lg[N];\tinline void Get_Hi()\t{\t\tFor(i,1,n) rk[sa[i]] = i;\t\tint j = 0;\t\tFor(i,1,n)\t\t{\t\t\tif(j) --j;\t\t\tif(rk[i] != 1)\t\t\twhile(s[i + j] == s[sa[rk[i] - 1] + j]) ++j;\t\t\theight[rk[i]] = j;\t\t}\t\t\tlg[0] = -1;\t\tFor(i,1,n) lg[i] = lg[i &gt;&gt; 1] + 1;\t\tFor(i,1,n) ST[0][i] = height[i];\t\tFor(j,1,18)\t\tFor(i,1,n - (1 &lt;&lt; j) + 1)\t\t\tST[j][i] = min(ST[j - 1][i],ST[j - 1][i + (1 &lt;&lt; j - 1)]);\t}\tinline int lcp(int x,int y)\t{\t\tx = rk[x];y = rk[y];\t\tif(x &gt; y) swap(x,y);++x;\t\tint k = lg[y - x + 1];\t\treturn min(ST[k][x],ST[k][y-(1&lt;&lt;k)+1]);\t}\t#undef For\t#undef Rof}A,B;inline long long Sum(int l,int r) { return 1ll * (l + r) * (r - l + 1) / 2;} inline long long Calc(int s,int p,int len){\tint l = len - min(len,s);\tint r = min(len,p) - 1;\tif(l &lt;= r)\t\treturn Sum(l,r) + 1ll * (s - len + 1) * (r - l + 1);\telse return 0;}long long f[N];int stk[N],top;int main(){\tcin &gt;&gt; n;\tlong long ans = 1ll * n * (n - 1) / 2;\tfor(int i = 1;i &lt;= n;i++)\t\tcin &gt;&gt; a[i];\tfor(int i = 1;i &lt; n;i++) a[i] = a[i + 1] - a[i];\t--n;\tfor(int i = 1,tot = 0;i &lt;= n;i++)\t\tif(mp.find(a[i]) == mp.end()) a[i] = mp[a[i]] = ++tot;\t\telse a[i] = mp[a[i]];\tfor(int i = 1;i &lt;= n;i++)\t\tA.s[i] = a[i],B.s[i] = a[n - i + 1];\tA.get_sa(n,n);\tB.get_sa(n,n);\tA.s[n + 1] = B.s[n + 1] = 0;\tA.Get_Hi();\tB.Get_Hi();\tfor(int i = 1;i &lt;= n;i++)\t{\t\twhile(top &amp;&amp; A.height[stk[top]] &gt;= A.height[i]) --top;\t\tif(top) f[i] = f[stk[top]] + 1ll * (i - stk[top]) * A.height[i];\t\telse f[i] = 1ll * i * A.height[i];\t\tans += f[i];\t\tstk[++top] = i;\t}\tfor(int len = 1;len &lt;= n;len++)\t\tfor(int i = len;i + len &lt;= n;i += len)\t\t{\t\t\tint j = i + len;\t\t\tans -= Calc(B.lcp(n - i + 1,n - j + 1),A.lcp(i,j),len);\t\t}\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["string theory","suffix array"]},{"title":"AGC037E 题解","url":"/posts/2399183113/","content":"人类智慧题，对于这种题确实不太会。接受现实，多加练习（\r\n\r\n这题一眼看过去没有什么思路或性质。需要字典序最小，我们只能从最小的字符开始考察，设其为\r\n。\r\n我们的首要目标是在最后最大化最开头那段  的长度。\r\n如果在翻转之前，有一段  处在\r\n\r\n的末尾，那么翻转过后，其会变成原来的两倍长，如果处在其它地方，你只能多得到一段长度相等的\r\n。\r\n所以，对于  ，只需输出  个  即可。\r\n对于剩下的情况，我们可以用开头的一次操作把最长的 \r\n放到串的末尾，然后不断倍长，在最后一次操作时把这段  放在结果串的开头。\r\n接下来我们要让 \r\n后面的那一段的字典序最小。\r\n设那段最长的  为 ，它前面的串为 。我们先用一次操作把  提到  的最后，再一次操作后变为 ，容易发现，新的串必然是  的一段后缀，如此下去，最后的串必然是\r\n\r\n的一段前缀，我们只需找出字典序最小的 。\r\n有意思的地方是，由于 \r\n为回文串，只要  在  中出现， 一定会在  中出现，那么我们找字典序最小的  ，只需在  中找到字典序最小的长度为  的子串即可。这个可以  完成。\r\n上面的做法也统一了 \r\n的情况，最终的时间复杂度为 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e3 + 5;int n,k;char s[N &lt;&lt; 1];char ans[N];inline void Useans(int p){\tfor(int i = 1;i &lt;= n;i++)\t\tans[i] = s[p + i - 1];}int fir;inline void Check(int p){\tif(!fir) Useans(p),fir = true;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tif(ans[i] &lt; s[i + p - 1]) return;\t\tif(ans[i] &gt; s[i + p - 1]) return Useans(p);\t}}int main(){\tcin &gt;&gt; n &gt;&gt; k;\tcin &gt;&gt; (s + 1);\tif(k &gt;= 15)\t{\t\tchar c = 'z';\t\tfor(int i = 1;i &lt;= n;i++) c = min(c,s[i]);\t\tfor(int i = 1;i &lt;= n;i++) putchar('c');\t\tputchar('\\n');\t\treturn 0;\t}\tfor(int i = 1;i &lt;= n;i++) s[n * 2 + 1 - i] = s[i];\tfor(int i = 1;i &lt;= n + 1;i++) Check(i);\tint mx = 0;\tfor(int i = 1;i &lt;= n + 1;i++)\t\tif(ans[i] == ans[1]) ++mx;\t\telse break;\tint len = mx &lt;&lt; (k - 1);\tfor(int i = 1;i &lt;= len;i++) putchar(ans[1]);\tfor(int i = len + 1;i &lt;= n;i++) putchar(ans[i - len + mx]);\tputchar('\\n');\treturn 0;}\r\n","tags":["string theory"]},{"title":"CF1063F 题解","url":"/posts/1321418465/","content":"这题我观察出了一些显然的性质，但还是没有做法。（\r\n做完之后，对 SAM 的运用倒是更加熟练了。那个 DP\r\n状态，虽然见过很多回这样的形式了，但还是没想到。\r\n\r\n为方便叙述，我们将原串翻转，限制变为  是  的真子串。\r\n性质 1\r\n，即每加一个串，顶多在开头或结尾加一个字符，这是显然的，因为加得越多，后面的串越难合法。\r\n性质 2\r\n设  表示求解  中的问题，且强制让  的右端点为  时最大的 。（实际上就是  最大的长度）\r\n那么  （这里比较的是两个 \r\n的左端点的位置，事实上，\r\n所代表的方案，每个串都删一个字符，就能变为  的方案，即 ，故上述性质显然成立。）\r\n这里的  实际上就是 DP\r\n状态，我们考虑维护  所代表的区间\r\n，由性质  可得  是不降的，这启示我们可以双指针。\r\n如何判断一个串 \r\n是否合法（即成为某个方案中的 \r\n）呢？\r\n根据意义，我们要找到一个串  满足  且  为  去掉开头或结尾且  合法。\r\n此外，若  合法，则  合法 。\r\n考虑使用一个 SAM 维护右端点  的合法串的贡献。设在 SAM 上  所在的结点为 。\r\n那么在双指针的过程中，执行如下算法：\r\n\r\n设  表示节点  所包含的最长合法子串的长度。\r\n当  时，检查当前的\r\n 是否合法，即  和  在 SAM 上的点的  的较大值是否 。\r\n如果  合法，那么令 ，令  为该串在 SAM 上的节点 。并回到第二步。\r\n如果 \r\n不合法，那么我们需要在 SAM 上更新 \r\n的信息，这个时候 \r\n就有用了，因为我们已经将 \r\n开头的合法串信息存在了 \r\n里。我们先让  与  取 ，再跳  的父亲 ，这个时候  应该变为 。如果当前的  不为 ，就将其置为 ，否则可以直接 break，因为如果 ， 的祖先  也必然满足  了。做完上述过程后，令 ，回到第三步。\r\n\r\n另外提一嘴，维护  的节点\r\n，只需要在  增大时让  沿着 DAWG 向下走一步，在  增大时，如果 ，就令  即可。\r\n#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5e5 + 5,Sz = N &lt;&lt; 1;int n;int ch[Sz][26],len[Sz],link[Sz],tot = 1,las = 1;int f[Sz];char s[N];int Nd[N],Ans[N];inline void extend(int c){\tint cur = ++tot,p = las;\tlen[cur] = len[p] + 1;\twhile(p &amp;&amp; !ch[p][c]) ch[p][c] = cur,p = link[p];\tif(!p) link[cur] = 1;\telse\t{\t\tint q = ch[p][c];\t\tif(len[p] + 1 == len[q]) link[cur] = q;\t\telse\t\t{\t\t\tint clone = ++tot;\t\t\tfor(int i = 0;i &lt; 26;i++)\t\t\t\tch[clone][i] = ch[q][i];\t\t\tlink[clone] = link[q];\t\t\tlen[clone] = len[p] + 1;\t\t\twhile(p &amp;&amp; ch[p][c] == q) ch[p][c] = clone,p = link[p];\t\t\tlink[cur] = link[q] = clone;\t\t}\t}\tlas = cur;}inline void Upd(int p,int v){\tif(v &lt;= f[p]) return;\tf[p] = v;p = link[p];\twhile(p &amp;&amp; f[p] != len[p]) f[p] = len[p],p = link[p];}int main(){\tcin &gt;&gt; n;\tcin &gt;&gt; (s + 1);\tstd::reverse(s + 1,s + n + 1);\tfor(int i = 1;i &lt;= n;i++)\t\textend(s[i] - 'a');\tint l = 1,p = 1,ans = 0;\tfor(int r = 1;r &lt;= n;r++)\t{\t\tint q = p;\t\tp = ch[p][s[r] - 'a'];\t\twhile(l &lt; r)\t\t{\t\t\tif(max(max(f[p],f[q]),f[link[p]]) &gt;= r - l) break;\t\t\tUpd(Nd[l],Ans[l]);++l;\t\t\tif(len[link[p]] &gt;= r - l + 1) p = link[p];\t\t\tif(len[link[q]] &gt;= r - l) q = link[q];\t\t}\t\tNd[r] = p;Ans[r] = r - l + 1;\t\tans = max(ans,r - l + 1);\t}\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n关键在于这个 DP\r\n状态，非常巧妙地把题目中各类性质和对象统一了起来。\r\n","tags":["DP","string theory"]},{"title":"ARC121F 题解","url":"/posts/4126244439/","content":"本题一开始读错题了，把题目加强了好多。（\r\n本题有经典的去叶子归纳法，值得学习。\r\n\r\n考虑知道了标号之后怎么判断合法。\r\n考虑一个叶子和其连向父亲的边。\r\n如果边是 OR，点是 ，原问题一定有解。\r\n如果边是 OR，点是 ，或者边是\r\nAND，点是 ，那这个叶子对答案没有影响，可以直接舍弃。\r\n如果边是 AND，点是 ，要尽量早的把这个叶子缩掉，这样对后面的危害最小。\r\n把这个步骤由深往浅的归纳，就会发现，我们对一棵子树只需要记录两个信息：最终的权值，以及有没有一个连通块向外恰好连了一条\r\nOR 边 且最终权值为  。\r\n说白了就是记录在整个过程中，有没有出现 \"OR 1\" 型的叶子。\r\n设出状态  表示  子树的最终权值为  / 为  且没有 \"OR 1\" 型叶子 / 有 \"OR 1\"\r\n型叶子。\r\n那么状态转移如下：  第一行： and ，\r\nor ， and ，\r\nand 。\r\n第二行： 因为没有 \"OR 1\" 型叶子， 子树必须是 \"AND 1\" 或者 \"OR 0\"，那么\r\n 所属连通块权值必然为 。\r\n第三行：前面是任意一侧有 \"OR 1\" 型叶子的情况，后面是  子树是 \"OR 1\" 型叶子的情况。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5,P = 998244353;inline int Add(int a,int b) { return (a + b &gt;= P) ? (a + b - P) : (a + b);}int n;vector&lt;int&gt; G[N];int f[N][3];void dp(int x,int fa){\tf[x][0] = f[x][1] = 1;\tfor(auto y : G[x])\t{\t\tif(y == fa) continue;\t\tdp(y,x);\t\tint v0 = f[x][0],v1 = f[x][1],v2 = f[x][2];\t\tf[x][2] = Add(2ll * v2 * Add(f[y][2],Add(f[y][0],f[y][1])) % P,Add(2ll * f[y][2] * (v0 + v1) % P,1ll * f[y][1] * (v0 + v1) % P));\t\tf[x][0] = Add(Add(2ll * v0 * f[y][0] % P , 1ll * v0 * f[y][1] % P),1ll * v1 * f[y][0] % P);\t\tf[x][1] = 1ll * v1 * (f[y][1] + f[y][0]) % P;\t}\t}int main(){\tcin &gt;&gt; n;\tfor(int i = 1;i &lt; n;i++)\t{\t\tint x,y;\t\tcin &gt;&gt; x &gt;&gt; y;\t\tG[x].push_back(y);\t\tG[y].push_back(x);\t}\tdp(1,0);\tcout &lt;&lt; Add(f[1][1],f[1][2]) &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting","tree"]},{"title":"ARC110E 题解","url":"/posts/2268255988/","content":"本题我是想到了个做法的，成功的过了第一个样例，后来与题解比对，发现我的做法考察的条件还是太弱了（\r\n\r\n容易发现，最后的每个字符都是由原串的一段区间操作得来的。\r\n把 A,B,C 的权值分别看成 ，那么一次操作相当于替换为异或和。\r\n考虑选出一段区间能干嘛：\r\n\r\n如果这段区间的异或和为 ，显然不能操作为单个字符。\r\n如果这段区间只有一种字符，显然啥都干不了。\r\n除开上述两种情况，归纳可得这段区间肯定能被操作成单个字符。我们称这类区间为\r\n“好段”\r\n\r\n（我之前的做法默认区间长度 ，理所当然的寄了）\r\n然后就是利用常规的思维模式，考虑如何让原串  唯一映射到能被构造出来的串 。\r\n首先  的异或和要等于  的异或和。\r\n其次，我们在找方案的时候，只考虑每个“好段”右端点最靠前的方案。\r\n有一个转移方法是，每次选一个最短的可行的段向后转移，如果 \r\n的最后一个字符取完了但还有剩余，就把剩下的字符全部补在后面（显然这些字符异或和肯定为\r\n）。\r\n为了说明正确性，我们要说明对于可以被构造的串 ，上述方法一定能够构造一个方案。\r\n我们取出串 \r\n的任意一个方案，去掉第一个“好段”的最长的异或和 \r\n的后缀，且保证去掉后第一段仍是“好段”，把这段后缀接在第二个”好段“的前方，以此类推，这样得到的方案就能被上面的转移方法所表示。\r\n那么我们设  表示处理了前\r\n 个字符的方案数，预处理  表示  位置往后最短的异或和为  的“好段”，据此转移即可。\r\n最后取出  的异或和为\r\n 的位置 ，将答案加上  即可。\r\n注意整个串清一色要特判，这个时候补  操作是错的，但答案为 。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5,P = 1e9 + 7;int n;char s[N];int f[N];int ton[4],nxt[N][4];int sum[N];int main(){\tcin &gt;&gt; n &gt;&gt; (s + 1);\tint flg = 1;\tfor(int i = 1;i &lt;= n;i++)\t{\t\tif(i &lt; n) flg &amp;= (s[i] == s[i + 1]);\t\tsum[i] = sum[i - 1] ^ (s[i] == 'A' ? 1 : (s[i] == 'B' ? 2 : 3));\t}\tif(flg) return puts(\"1\"),0;\tfor(int i = 1;i &lt;= 3;i++)\t\tton[i] = n + 1;\tfor(int i = n;i &gt;= 0;i--)\t{\t\tton[sum[i]] = i;\t\tfor(int k = 0;k &lt;= 3;k++)\t\t\tif(k != sum[i])\t\t\t\tnxt[i][sum[i] ^ k] = ton[k];\t\tnxt[i][sum[i] ^ sum[i + 1]] = i + 1;\t}\tf[0] = 1;\tfor(int i = 0;i &lt; n;i++)\t\tfor(int k = 1;k &lt;= 3;k++)\t\t\t(f[nxt[i][k]] += f[i]) %= P;\tint ans = 0;\tfor(int i = 1;i &lt;= n;i++)\t\tif(sum[i] == sum[n])\t\t\t(ans += f[i]) %= P;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["DP"]},{"title":"CF388D 题解","url":"/posts/2809317364/","content":"题意：给出一个数 ，求最大元素\r\n 的线性空间数量，对  取模。\r\n\r\n计数线性空间，我们有必要了解一个叫“简化线性基”的东西。\r\n下文的矩阵中，每一行就是线性基每一个元素的二进制拆分，从左到右是从高位到低位。\r\n一般我们构建的线性基，在每一行的第一个  上方，还可能有其它的 ，比如这样： \r\n在上面的例子中，我们把第一行异或上第二行，就可以得到一个本质相同的线性基：\r\n 熟悉线性代数的读者可能知道，这就是一个简化阶梯形矩阵。\r\n这样的矩阵满足对于每行的第一个非  元素，它的上方全都是 。\r\n这样的线性基被成为简化线性基，它具有一些其它线性基没有的性质：\r\n\r\n这种基能张成的最大元素就是每一行的异或和（最高位选了肯定更优）\r\n一个简化线性基唯一对应一个线性空间，因为两个简化线性基不能通过行与行的相互异或来得到对方\r\n\r\n这两条性质恰恰与题目的限制吻合。\r\n我们只需计数每行的异或和 \r\n，且每行第一个  上方都是  的矩阵个数即可。\r\n数位 DP，设状态  表示现在处理到第  列，线性基一共加入了 \r\n个元素，当前的异或和有没有顶到上界。\r\n分类讨论：\r\n\r\n如果没有顶到上界，那么对于这一列，我们可以不新开元素，已经加入的\r\n\r\n个元素在这一列就可以随意取值，方案数为 \r\n，如果新开元素，已有的元素在这一列必须为 ，方案数为 。\r\n如果顶到了上界：\r\n\r\n如果我们令这一位的异或和为 ，那么就无法新开元素，只能让已有的  个元素保证异或和为 ，方案数为 。\r\n如果我们令这一维的异或和为 ，我们可以新开一个元素，也可以不新开元素，并保证已有的元素异或和为\r\n，方案数也为 （注意特判  的情况）\r\n\r\n\r\n本题至此已经结束，是一道考察对线性基理解和相关应用的好题，如果有线性代数的知识储备，理解线性基也不是什么难事。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 40,P = 1e9 + 7;int f[N][N][2];int Pow2[N];int K;int dfs(int pos,int cnt,int done){\tif(pos == -1) return 1;\tif(~f[pos][cnt][done]) return f[pos][cnt][done];\tint res = 0,num = ((long long)K &gt;&gt; pos) &amp; 1;\tif(!done)\t\tres = (dfs(pos - 1,cnt + 1,done) + 1ll * Pow2[cnt] * dfs(pos - 1,cnt,done) % P) % P;\telse\t{\t\tres = 1ll * (cnt ? Pow2[cnt - 1] : 1) * dfs(pos - 1,cnt,!num) % P;\t\tif(num)\t\t\tres = (res + 1ll * (cnt ? Pow2[cnt - 1] : 0) * dfs(pos - 1,cnt,1) % P) % P,\t\t\tres = (res + dfs(pos - 1,cnt + 1,1)) % P;\t}\tf[pos][cnt][done] = res;\treturn res;}int main(){\tcin &gt;&gt; K;\tPow2[0] = 1;\tfor(int i = 1;i &lt; N;i++)\t\tPow2[i] = 2ll * Pow2[i - 1] % P;\tmemset(f,-1,sizeof f);\tcout &lt;&lt; dfs(N - 1,0,1) &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting","linear algebra"]},{"title":"ARC130E 题解","url":"/posts/2210858697/","content":"思路基本全部正确，但是棋差一着，没有注意到转移点只有一个。\r\n说明所谓的思维题，并没有那么不可做。\r\n\r\n题意：对于一个长度为 \r\n的正整数序列 \r\n，定义一次操作为：选出最小值所在的位置（多个则任取），将下标加入  序列的末尾，并将对应位置 。\r\n我们做了  次操作，得到了序列\r\n。现在你知道序列 ，须求出是否存在一个初始序列  能得到这个 ，存在则输出字典序最小解。\r\n。\r\n观察一个 \r\n序列在操作过程中发生的变化。\r\n我们发现，我们会先把当前所有的最小值 ，然后再取出当前的所有最小值，再全部\r\n。\r\n因此，我们定义  为第  次操作前的序列最小值，那么 。\r\n\r\n的变化有明显的分段特征，我们考虑把  序列分段，每段的  都是一样的。\r\n稍微手玩一下可以得到分段方案合法的充要条件：\r\n除最后一段外，每段中出现的元素集合都必须包含上一段出现的所有元素。这也等价于必须包含这一段之前出现的所有元素。\r\n最后一段我们等会考虑，先考虑前面的段。\r\n我们考虑对于一个右端点 ，什么样的左端点  可以使 \r\n被分为合法段，显然，这与其他的段怎么划分是没有关系的。\r\n首先，\r\n中出现的元素，都必须在 \r\n中出现。同时，\r\n中不能出现重复的元素。\r\n设  中有  个不同元素，那么  要么是 ，要么无解。这说明对于每个  只有最多一个合法的 。\r\n而对于最后一段而言，它合法只需要没有重复元素即可。\r\n上述结论表明，如果我们确定了最后一段的端点，前面的划分方案是唯一的。\r\n那么我们如何确定这个点，使得字典序最小？\r\n考虑去掉最后一段之后，所有点在操作完后应该全部相等，那么我们当然让前面的段数越少越好（因为每个点被加几次已经确定了），在段数相等的条件下，我们会选择尽量靠后的点，因为最后一段相当于在这个“相等\"的值上额外\r\n，我们当然要让这个  越少越好。\r\n确定这个点之后，反推出初始方案即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5 + 5,inf = 0x3f3f3f3f;int n,k;int b[N],a[N];int f[N],lst[N],ton[N];int main(){\tcin &gt;&gt; n &gt;&gt; k;\tfor(int i = 1;i &lt;= k;i++) cin &gt;&gt; b[i];\tint pre = 0;\tfor(int i = 1,cnt = 0;i &lt;= k;i++)\t{\t\tpre = max(pre,ton[b[i]]);\t\tif(!ton[b[i]]) ++cnt;\t\tton[b[i]] = i;\t\tif(i - pre == cnt) f[i] = f[pre] + 1;\t\telse f[i] = inf;\t\t// printf(\"%d %d %d\\n\",f[i],lst[i],cnt);\t}\tint p = k;\tmemset(ton,0,sizeof ton);\tfor(int i = k;i &gt;= 1;i--)\t{\t\tif(ton[b[i]]) break;\t\tton[b[i]] = true;\t\tp = i;\t}\tint Mn = -1;\tfor(int i = p - 1;i &lt; k;i++)\t\tif(Mn == -1 || f[i] &lt;= f[Mn]) Mn = i;\tif(f[Mn] &gt;= inf) return puts(\"-1\"),0;\tfor(int i = 1;i &lt;= n;i++) a[i] = f[Mn] + 1;\tfor(int i = 1;i &lt;= Mn;i++) a[b[i]]--;\tfor(int i = 1;i &lt;= n;i++) printf(\"%d \",a[i]);printf(\"\\n\");\treturn 0;}\r\n","tags":["constructive algorithm","thinking"]},{"title":"CF1286E Fedya the Potter Strikes Back 题解","url":"/posts/2273955663/","content":"事实证明卡住的地方比我预想的要弱智一些，构思的时候已经想到了均摊，但对\r\nborder\r\n的变化规律似乎缺乏更深的理解，也对最值相关缺乏研究，导致没有想到另一个均摊。\r\n\r\n当然，这题也带来一个直觉，就是 border 相关的工程一般比较轻量级。\r\n第一眼是 border 的四种求法中的 SAM，后来发现显然不用这么复杂，考虑\r\nKMP 的过程即可。\r\n注意到一个前缀的所有 border 是 KMP\r\n失配树上的一条祖先链。想借此维护，但变化量看上去并不小，主要是  变为 \r\n的时候，可能接上了一条完全不同的祖先链，然后就卡在这儿了。\r\n但事实上，我们直接考虑每个 border\r\n串，在加入一个字符之后，它要么长度也加 ，要么就不是 border 串了。\r\n注意到处理完上述变化之后，最多只会有一个长度为  的 border 串新加入进来（因为剩下的\r\nborder 串都是由上一轮的 border 整体加  而来）。\r\n所以删除操作可以暴力执行，我们可以找到每个要删除的 border\r\n串，然后更新相应的信息。\r\n那么如何快速找到那些要删除的 border 串呢。\r\n之前说过，一个前缀的所有 border 是失配树上的祖先链，也就是 ，我们对于每个\r\n，维护最深的一个后继字符与它不同的祖先\r\n，即满足  的最深的点。在遍历祖先的过程中，使用  加速即可。\r\n至于 border 串长整体 \r\n怎么做，设当前加入了 \r\n个字符，考察一个长度为  的  串，它的区间从加入前的  变为了 ，我们发现，对于这些串，它们的权值只是对当前加入的  取了个 。\r\n那么现在就是要维护一堆数，支持对所有数取  和维护和。\r\n我们可以用 map 维护每种权值的出现次数，要对  取  时，把比  大的权值都直接变为  即可。\r\n考察 map 中不同元素个数的变化情况，容易证明这里的均摊复杂度是  的。\r\n所以总时间复杂度是  的。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;inline void write(const T &amp;a){\tif(a &gt;= 10) write(a / 10);\tputchar(a % 10 + '0');}const int N = 6e5 + 5,MASK = (1 &lt;&lt; 30) - 1;typedef long long ll;typedef __int128 lll;int n;int w[N],s[N];int stk[N],top;map&lt;int,int&gt; mp;int nxt[N];ll ans;lll lastans;int anc[N]; // 第一个后继字符与其不同的祖先，找到那些被删除的 borderinline int Qpos(int pos){\treturn w[*lower_bound(stk + 1,stk + top + 1,pos)];}int main(){\tcin &gt;&gt; n;\tint j = 0;\tnxt[1] = 0;\tchar ch;\tcin &gt;&gt; ch &gt;&gt; w[1];\ts[1] = ch - 'a';\tlastans = w[1];\tstk[++top] = 1;\twrite(lastans);\tputchar('\\n');\tfor(int i = 2;i &lt;= n;i++)\t{\t\tchar ch;\t\tcin &gt;&gt; ch &gt;&gt; w[i];ch -= 'a';\t\tw[i] ^= lastans &amp; MASK;\t\ts[i] = (ch + lastans) % 26;\t\twhile(j &amp;&amp; s[i] != s[j + 1]) j = nxt[j];\t\tif(s[i] == s[j + 1]) ++j;\t\tnxt[i] = j;\t\tif(s[i] == s[nxt[i - 1] + 1]) anc[i - 1] = anc[nxt[i - 1]];\t\telse anc[i - 1] = nxt[i - 1];\t\tfor(int k = i - 1;k;)\t\t{\t\t\tif(s[k + 1] == s[i]) k = anc[k];\t\t\telse\t\t\t{\t\t\t\tint val = Qpos(i - k);\t\t\t\t--mp[val];\t\t\t\tif(mp[val] == 0) mp.erase(val);\t\t\t\tans -= val;\t\t\t\tk = nxt[k];\t\t\t}\t\t}\t\tif(s[1] == s[i])\t\t\t++mp[w[i]],ans += w[i];\t\twhile(top &amp;&amp; w[stk[top]] &gt;= w[i])\t\t\t--top;\t\tstk[++top] = i;\t\tint num = 0;\t\tauto it = mp.upper_bound(w[i]);\t\twhile(it != mp.end())\t\t{\t\t\tnum += it -&gt; second;\t\t\tans -= 1ll * (it -&gt; first - w[i]) * it -&gt; second;\t\t\tmp.erase(it);\t\t\tit = mp.upper_bound(w[i]);\t\t}\t\tmp[w[i]] += num;\t\tlastans += w[stk[1]] + ans;\t\twrite(lastans);\t\tputchar('\\n');\t}\treturn 0;}\r\n这是一道总结 border\r\n变化规律和最值变化规律的好题，对向后加入字符的问题，border\r\n有比较简明的变化方式；对很多数不断地 ，也可以使用均摊复杂度做到优秀的结果。\r\n思考的大方向没有什么问题，但是细节并没有想清楚，这是需要改进的。\r\n","tags":["string theory"]},{"title":"CF1415F 题解","url":"/posts/1876701072/","content":"遇到新题型，茫然无措是必然的，但只有冷静下来，运用自己掌握的思维模式，才能从茫然中找到柳暗花明。\r\n\r\n考虑已经确定了本体和分身完成的任务集合，怎么判定合法性。\r\n设本体完成的任务为 A 类，分身完成的任务为 B 类。\r\n把 \r\n看成二维平面上的点，容易绘制以下图像：\r\n\r\n我们的行动轨迹需要经过上图所有的点。\r\nA 类任务可以限制人的行动轨迹，相比 B\r\n类任务具有更加”稳定“的约束，我们考虑研究两个 A 任务之间的间隔。\r\n\r\n右图是两个 A 夹着一段极长的 B ，左图是一段极长的 A。\r\n蓝色是不管 B 的路线，红色是管 B 的路线。\r\n容易发现，一段极长的 A，只会贡献一个 B，一段极长的 B\r\n的非开头部分 只会由夹着这一段的两个 A\r\n解决（开头那个被绿色圈住的部分可能已经被前一段解决）\r\n（上述图片来自 @command_block，感谢 cmd 的题解）\r\n两个 A 之间的间隔，就是一段 B 的极长连续段。\r\n假设这些  任务按时间顺序为\r\n， 对应的时间区间为 ，其实就是 。\r\n设初始时间为 ，初始位置为 ，假设下一个任务为 ，那么如果 ，则方案不合法，否则 \r\n变为 ，\r\n也对应变化（对  取  是因为，假如我在  之前就到达了 ，我也必须等到 \r\n的时候才能撤销原本放在那里的分身，把它移到当前位置）\r\n观察上述的贪心算法，我们只需在  的时候维护上面的  ，然后一个一个加入 B 类任务即可。\r\n具体地，设  表示任务\r\n 是 B 类，任务  是/否已经被  之前的某一段 A\r\n解决。（也就是那个绿色圈的情况）\r\n对于  ，当前本体肯定在\r\n，对于 ， 是 A 类，并且本体在 。\r\n记  表示任务  是否能成为一段 A。\r\n记 。\r\n对于 :\r\n\r\n 是 B 类\r\n\r\n从  转移：\r\n从  转移：\r\n\r\n 是 A 类\r\n枚举 A 类极长连续段 。\r\n\r\n条件：\r\n 为真\r\n且  （ 可以走到 ）\r\n且 \r\n（可以从  走到 ）\r\n\r\n对于 ：\r\n\r\n条件：\r\n枚举 A 类极长连续段 。\r\n存在一个  满足：\r\n\r\n 为真\r\n且  （ 可以走到 ）\r\n且存在一个 \r\n（存在一个空隙使得人可以拐出来，先放好分身再走回去） 或者  （这一段 A 的开头和上一段\r\nB 的结尾之间有个空隙可以让人出来放分身）\r\n\r\n把转移都分讨完后，代码就比较简单了：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll llinf = 0x3f3f3f3f3f3f3f3f;const int N = 5e3 + 5;int n;struct node {ll x,t;} p[N];bool cmp(const node &amp;a,const node &amp;b) { return a.t &lt; b.t;}ll dis(int x,int y) { return abs(p[x].x - p[y].x);}ll f[N][2];bool g[N];int main(){\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++)\t\tcin &gt;&gt; p[i].t &gt;&gt; p[i].x;\tp[++n].t = 0;p[n].x = 0;\tp[++n].t = llinf - 1;p[n].x = 0;\tsort(p + 1,p + n + 1,cmp);\tf[1][1] = llinf;\tfor(int i = 2;i &lt;= n;i++)\t{\t\tg[i - 1] = dis(i - 1,i) &lt;= p[i].t - p[i - 1].t;\t\tf[i][0] = f[i][1] = llinf;\t\tll now = f[i - 1][0] + dis(i - 1,i);\t\tif(now &lt;= p[i].t) f[i][0] = min(f[i][0],max(now,p[i - 1].t));\t\tnow = f[i - 1][1] + dis(i - 2,i);\t\tif(now &lt;= p[i].t) f[i][0] = min(f[i][0],max(now,p[i - 1].t));\t\tbool flag = 0;\t\tfor(int j = i - 2;j &gt;= 1;j--) // 枚举 A 类极长连续段 [j + 1,i - 1]\t\t{\t\t\tif(j + 2 &lt; i)\t\t\t{\t\t\t\tif(!g[j + 1]) break;\t\t\t\tflag |= (dis(i,j + 1) + dis(i,j + 2) &lt;= p[j + 2].t - p[j + 1].t);\t\t\t}\t\t\t// B 类 j 要接上 A 类 j + 1\t\t\tif(min(f[j][0] + dis(j,j + 1),f[j][1] + dis(j - 1,j + 1)) &lt;= p[j + 1].t)\t\t\t{\t\t\t\tif(flag || max(min(f[j][1] + dis(j - 1,i),f[j][0] + dis(j,i)),p[j].t) + dis(i,j + 1) &lt;= p[j + 1].t)\t\t\t\t\tf[i][1] = p[i - 1].t;\t\t\t\tif(g[i - 1]) f[i][0] = min(f[i][0],p[i - 1].t + dis(i - 1,i));\t\t\t}\t\t}\t}\tif(min(f[n][0],f[n][1]) &lt; llinf) puts(\"YES\");\telse puts(\"NO\");\treturn 0;}\r\n总的来说，是一道比较复杂的 DP 题，非常具有 CF\r\n风格，虽然最后的转移情况很多，但并没有思维上的难度，真正的难点主要在前面的状态设计和对问题的刻画。注意到\r\nA 类和 B 类各自的贡献条件是十分重要的，这样才能开始后面的转化。\r\n愈是复杂，愈要冷静。\r\n","tags":["DP"]},{"title":"P6789 题解","url":"/posts/2277016046/","content":"要打开此题的突破口，Kruskal 和拆贡献都要想到。我只想到了 Kruskal\r\n，所以寄了。大概在此种计数最优方案的题中，以已有的最优化算法为基础，进行贡献拆解是常见的套路。\r\n类似的题还有：P4517 JSOI2018 防御网络。\r\n\r\n对于一张确定的图，这道题是要我们求出边权和最大的基环树森林。\r\n而基环树森林与生成树是类似的，可以套用 Kruskal\r\n算法的模型，将边从大到小排序，如果加入一条边仍满足条件就加进去（因为\r\n“基环树森林”\r\n的限制可以像“生成树”一样导出一个拟阵，所以我们才能贪心地加边）。\r\n那么我们考察某一条边 \r\n的贡献，看它什么时候会被加进去。\r\n假设我们已经做完了边权大于 \r\n的所有边，那么这条边就面临两种产生贡献的情况：\r\n\r\n\r\n连通，且该连通块是棵树，\r\n\r\n不连通，且连起来的两个连通块要么是树，要么是基环树，且不都是基环树。\r\n\r\n我们发现第二类贡献的形式非常麻烦，首先这个基环树的限制不好处理，其次我们还要讨论三种情况。\r\n正难则反，我们考虑这条边不会产生贡献的情况。\r\n那就是：\r\n\r\n\r\n连通，且该连通块不是树。\r\n\r\n不连通，且连起来的两个连通块都不是树。\r\n\r\n对于第一类贡献，考虑算出 \r\n表示点集 \r\n的导出子图的生成树个数，这可以通过枚举子集做到 。\r\n具体地，枚举最后加入的一条边所连接起的两个连通块  和 ，然后在连接这两个连通块的边中任选一条作为“最后加入的一条边”\r\n即可。\r\n为了避免重复的枚举，我们选出一个特殊点 ，钦定 \r\n包含这个点。（在很多图计数中，会看到“枚举 \r\n号点所在的连通块”，其实就是这个意思，避免算重）\r\n（注意：类加完答案之后要除以 ，因为同一棵树会被这种方法算这么多次）\r\n如何快速求出两个连通块之间连了多少条边？预处理  表示点集  的导出子图有多少条边，那么边数就是\r\n。\r\n我们还要算出  表示点集 \r\n的导出子图的连通子图的个数，这个也可以用一个容斥做到 ，即枚举特殊点  所在的连通块点集。\r\n那么第一类贡献就很好计算了，直接枚举  所在的连通块即可。\r\n第二类贡献也很好计算，我们枚举  分别属于哪两个连通块，设为 ，那因为一个连通块  不是树的方案数就是 ，贡献系数就是 ，因为在  外的边可以任意排布，我们还需乘上\r\n，其中  为全集。\r\n注意到上面算的一直都是方案数，我们除以总数将其转为概率，再用总概率\r\n 去减即可（\r\n是因为当前考虑的这条边必须选）。\r\n总时间复杂度为 ，略微卡常，需要一些剪枝。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 17,Sz = 1 &lt;&lt; 15,M = 65,P = 998244353;inline int Add(int a,int b) { return (a + b &gt;= P) ? (a + b - P) : (a + b);}inline int Sub(int a,int b) { return (a &lt; b) ? (a - b + P) : (a - b);}inline int qpow(int a,int b) { int res = 1;while(b) {if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;} return res;}struct Edge{\tint u,v,w;\tEdge(){}\tEdge(const int _u,const int _v,const int _w):\t\tu(_u),v(_v),w(_w){}\tbool operator &lt; (const Edge &amp;rhs) const { return w &gt; rhs.w;}};int n,m;Edge e[M];int f[Sz],g[Sz];int pop[Sz];int cnt[Sz]; // 每个点集的导出子图的边数int Pow2[M];int inv[N];int Solve(int x) // 当前扫到第 x 条边{\tmemset(cnt,0,sizeof cnt);\tfor(int i = 1;i &lt; x;i++)\t\t++cnt[(1 &lt;&lt; e[i].u) | (1 &lt;&lt; e[i].v)];\tfor(int j = 0;j &lt; n;j++)\t\tfor(int i = 0;i &lt; (1 &lt;&lt; n);i++)\t\t\tif((i &gt;&gt; j) &amp; 1)\t\t\t\tcnt[i] += cnt[i ^ (1 &lt;&lt; j)];\tf[0] = g[0] = 0;\tint all = (1 &lt;&lt; n) - 1;\tfor(int S = 1;S &lt;= all;++S)\t{\t\tif(pop[S] == 1) {f[S] = g[S] = 1;continue;}\t\tif(cnt[S] &lt; pop[S] - 1) { f[S] = g[S] = 0;continue;}\t\tf[S] = 0;g[S] = Pow2[cnt[S]];\t\tint z = S &amp; (-S),w = S ^ z;\t\tfor(int T = w;T;T = (T - 1) &amp; w)\t\t{\t\t\tint bu = S ^ T,num = cnt[S] - cnt[T] - cnt[bu]; // bu 中包含了特殊点 z\t\t\tf[S] = Add(f[S], 1ll * f[T] * f[bu] % P * num % P);\t\t\tg[S] = Sub(g[S],1ll * g[bu] * Pow2[cnt[T]] % P);\t\t}\t\tf[S] = 1ll * f[S] * inv[pop[S] - 1] % P;\t}\tfor(int S = 1;S &lt;= all;++S)\t\tg[S] = Sub(g[S],f[S]);\tint res = 0;\tint u = 1 &lt;&lt; e[x].u,v = 1 &lt;&lt; e[x].v;\tfor(int S = 1;S &lt;= all;++S)\t{\t\tif(!(S &amp; u) || !(S &amp; v)) continue;\t\tres = Add(res,1ll * g[S] * Pow2[cnt[all ^ S]] % P);\t}\t// 第二类贡献\tfor(int A = 1;A &lt;= all;++A)\t{\t\tif((A &amp; v) || !(A &amp; u)) continue;\t\tint buA = all ^ A;\t\tfor(int B = buA;B;B = (B - 1) &amp; buA)\t\t{\t\t\tif(!(B &amp; v)) continue;\t\t\tres = Add(res,1ll * g[A] * g[B] % P * Pow2[cnt[all ^ A ^ B]] % P);\t\t}\t}\tint allp = (P + 1) / 2;\tres = 1ll * res * qpow(Pow2[x],P - 2) % P;\tres = Sub(allp,res);\tres = 1ll * res * e[x].w % P;\treturn res;}int main(){\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1;i &lt;= m;i++)\t{\t\tcin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;\t\t--e[i].u;--e[i].v;\t}\tsort(e + 1,e + m + 1);\t\tfor(int i = 1;i &lt; (1 &lt;&lt; n);i++) pop[i] = pop[i &gt;&gt; 1] + (i &amp; 1);\tPow2[0] = 1;\tfor(int i = 1;i &lt;= m;i++) Pow2[i] = 2ll * Pow2[i - 1] % P;\tinv[1] = 1;\tfor(int i = 2;i &lt;= n;i++) inv[i] = 1ll * inv[P % i] * (P - P / i) % P;\tint ans = 0;\tfor(int i = 1;i &lt;= m;i++)\t\tans = Add(ans,Solve(i));\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;}\r\n","tags":["counting","graph theory"]},{"title":"ABC221G 题解","url":"/posts/348044818/","content":"转化题意还是很妙的，但后半部分不知道如何评价。 \r\n看到题之后，一眼会有一个直接考虑四种方向，直接 DP\r\n的思路，显然做不得。\r\n问题主要在于没法将两维独立开来。\r\n这说明直接考虑 \r\n行不通，我们得考察一些性质更好的量。\r\n考察 （即将坐标轴\r\n45 度旋转，我也不知道出题人是怎么想到的）\r\n如果 ，那么  和  都会加上 。\r\n如果 ，那么  和  都会减去 。\r\n如果 ，那么  会加 ， 会减 。\r\n如果 ，那么  会减 ， 会加 。\r\n容易发现，此时  要么 ，要么 ，且  的决策和 \r\n无关。\r\n用 bitset 优化 01 背包，看看  和 \r\n是否均能被表出即可。\r\n为了避免在背包时出现负数，我们先默认每个  都取减号，取加号时，认为其带来  的贡献。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e3 + 5,S = 3.6e6 + 5;bitset&lt;S&gt; f[N];int n,d[N],sumd;int x,y;int ans[N];int main(){\tcin &gt;&gt; n &gt;&gt; x &gt;&gt; y;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; d[i],sumd += d[i];\tint a = x + y,b = x - y;\tif(abs(a) &gt; sumd || abs(b) &gt; sumd) return puts(\"No\"),0;\tif((a + sumd) &amp; 1) return puts(\"No\"),0;\tif((b + sumd) &amp; 1) return puts(\"No\"),0;\ta = (a + sumd) / 2;b = (b + sumd) / 2;\tf[0][0] = 1;\tfor(int i = 1;i &lt;= n;i++)\t\tf[i] = f[i - 1] | (f[i - 1] &lt;&lt; d[i]);\tif(!f[n][a] || !f[n][b]) return puts(\"No\"),0;\tputs(\"Yes\");\tfor(int i = n;i &gt;= 1;i--)\t{\t\tif(!f[i - 1][a]) {ans[i] += 1;a -= d[i];}\t\tif(!f[i - 1][b]) {ans[i] += 2;b -= d[i];}\t}\tfor(int i = 1;i &lt;= n;i++)\t{\t\t// 默认是 -，那一位有值就是 +\t\tif(ans[i] == 0) putchar('L');\t\tif(ans[i] == 1) putchar('U');\t\tif(ans[i] == 2) putchar('D');\t\tif(ans[i] == 3) putchar('R');\t}\treturn 0;\treturn 0;}\r\n","tags":["DP"]},{"title":"ARC137E 题解","url":"/posts/3886443264/","content":"对与区间有关的建模不够熟悉，即使想到了根据面包师建模，也难以建出东西来。\r\n需要对这方面加以训练。\r\n\r\n题意：\r\n有  天， 个面包师，第  个面包师需要花  元雇佣，雇佣过后，他会在第  到第  天，每天给你生产一个面包。\r\n每天有个预期销售量 ，如果你当天产出了  个面包，你实际只能卖出  个面包。\r\n卖出一个面包可以获得 \r\n元的收益。现在你是面包铺老板，请最大化自己的收益。\r\n。\r\n对面包建模是比较寄的。\r\n那不妨根据面包师建模。\r\n先把答案取反，变成最小费用模型。\r\n尝试建边 \r\n代表每一天的情况，因为这一天卖 \r\n个面包，每个可以带来 \r\n的贡献，溢出的则没贡献，所以建边 。\r\n对于一个面包师，建边 ，那么这就是一个循环流模型。我们每次增广一个圈，就相当于选择了一个面包师。\r\n注意到边有负权，我们使用带负权的最小费用流\r\n即可完成计算。\r\n因为这张图非常特殊，每个点连向  与连向 \r\n的边的数量是相等的，所以我们甚至不需要虚拟源汇，直接以  为源点， 为汇点跑就可以了。\r\n所以我们总共只需要建出三类边：\r\n\r\n\r\n\r\n\r\n\r\n注意： 本题在新图中需要保证流量不超过  ，因为在新图中有可能增广出大于 \r\n的流量，但这些东西是对应不回原来的流量意义的。\r\n因为这题  稍大，需要 \r\n的原始对偶算法方可通过（我写了但被卡常乐），所以我最终使用的是 AtCoder\r\nLibrary 自带的费用流，跑得很快。\r\n#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/mincostflow&gt;#pragma GCC optimize(3)using namespace std;typedef long long ll;const ll llinf = 0x3f3f3f3f3f3f3f3f;int n,m,D;ll ans;int main(){\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; D;\tatcoder::mcf_graph&lt;ll,ll&gt; G(n+2);\tfor(int i = 1;i &lt;= n;i++)\t{\t\tint a;\t\tcin &gt;&gt; a;\t\tG.add_edge(i,i + 1,a,D);\t\tG.add_edge(i,i + 1,m - a,0);\t\tans += 1ll * D * a;\t}\tfor(int i = 1;i &lt;= m;i++)\t{\t\tint l,r,c;\t\tcin &gt;&gt; l &gt;&gt; r &gt;&gt; c;\t\tG.add_edge(l,r + 1,1,c);\t}\tcout &lt;&lt; ans - G.flow(1,n + 1,m).second &lt;&lt; endl;\treturn 0;}\r\n","tags":["graph theory","flow"]},{"title":"Hello World","url":"/posts/1243066710/","content":"Welcome to Hexo! This is your very\r\nfirst post. Check documentation for\r\nmore info. If you get any problems when using Hexo, you can find the\r\nanswer in troubleshooting or\r\nyou can ask me on GitHub.\r\nQuick Start\r\nCreate a new post\r\n$ hexo new &quot;My New Post&quot;\r\nMore info: Writing\r\nRun server\r\n$ hexo server\r\nMore info: Server\r\nGenerate static files\r\n$ hexo generate\r\nMore info: Generating\r\nDeploy to remote sites\r\n$ hexo deploy\r\nMore info: Deployment\r\n"},{"title":"P3785 题解","url":"/posts/2705340643/","content":"妙妙题，一开始打全局平衡二叉树的单 ，300\r\n行没调出来。后来获知此题有线性做法。确实十分高妙，有一种字符串的美。\r\n\r\n题意：给出两个字符串 ，问能否将  划分为三个子串 ，并将其以某个顺序拼接可以组合出\r\n，若能请构造方案。。\r\n看到这题，当然要分六种情况：\r\n\r\n，直接判断即可。\r\n 或 ，我们发现有两个部分实际上是一段，所以我们只需要考虑将\r\n 划为两段，枚举端点，用 Hash\r\n判断相等即可。\r\n\r\n这是本文要讲述的重点。\r\n构造新串  （这个转化很妙，虽然我也不知道怎么想到的）。\r\n那么原问题相当于把 \r\n划分为三个长度为偶数的回文串。\r\n枚举第一个回文串 ，那么问题变为判断  是否能被划分为两个偶回文串。\r\n这里我们需要用到回文串划分的一个结论：\r\n\r\n那么，如果存在划分，那必有一种方案中有最长回文前缀或最长回文后缀。\r\n也就是说，我们如果只需找到一种回文串划分，只需考虑这个串的最长回文前缀和最长回文后缀即可。\r\n我们发现，把上述结论改成“偶回文串”，也是没有任何问题的。\r\n对  串跑一遍\r\nManacher，这样任意后缀的最长回文前缀和最长回文后缀都容易递推预处理了。\r\n具体的，设  表示  的最长回文前缀，那么有 。\r\n这样就可以从  递推到  了，在  处再算上  的位置的贡献即可。（ 表示以 \r\n为靠右的那个回文中心时的最长回文长度的一半）。\r\n。\r\n枚举  ，只需令\r\n\r\n，然后判断是否存在偶回文划分即可。\r\n但是我们要处理很多个  。\r\n注意到  的最长偶回文前缀就是\r\n 在  中对应位置的最长匹配长度 ，用\r\nKMP 跑出这个值即可。最长偶回文后缀同理。\r\n具体细节可见代码。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;namespace FastIO {\t#define iL (1 &lt;&lt; 20)\tchar ibuf[iL],*iS = ibuf + iL,*iT = ibuf + iL;\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf,1,iL,stdin),iS == iT ? EOF : *iS++) : *iS++)\ttemplate&lt;typename T&gt;\tinline void read(T &amp;a)\t{\t\tchar ch;int sign = 0;\t\tfor(ch = gc();!isdigit(ch);ch = gc())\t\t\tif(ch == '-') sign = 1;\t\ta = ch &amp; 15;\t\tfor(ch = gc();isdigit(ch);ch = gc())\t\t\ta = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch &amp; 15);\t\tif(sign) a = -a;\t}\tchar Out[iL],*iter = Out;\t#define flush() fwrite(Out,1,iter - Out,stdout),iter = Out\ttemplate&lt;typename T&gt;\tinline void write(T x,char end = '\\n')\t{\t\tint c[40],l = 0;if(x &lt; 0) *iter++ = '-',x = -x;\t\tdo c[++l] = x % 10,x /= 10; while(x);\t\twhile(l) *iter++ = c[l--] + '0';\t\t*iter++ = end;flush();\t}\t#undef iL \t#undef gc \t#undef flush}using namespace FastIO;const int N = 1e6 + 5;typedef unsigned long long ull;const int base = 1333331;int n,m;int s[N],t[N];int nxt[N &lt;&lt; 1],mth[2][N &lt;&lt; 1];ull hsh[2][N],Pow[N];void KMP(int *s,int *t,int n,int *mth){\tint j = 0;nxt[1] = 0;\tfor(int i = 1;i &lt; n;i++)\t{\t\twhile(j &amp;&amp; t[i + 1] != t[j + 1]) j = nxt[j];\t\tif(t[i + 1] == t[j + 1]) ++j;\t\tnxt[i + 1] = j;\t}\tj = 0;\tfor(int i = 1;i &lt;= n;i++)\t{\t\twhile(j &amp;&amp; s[i] != t[j + 1]) j = nxt[j];\t\tif(s[i] == t[j + 1]) ++j;\t\tif(j == i) j = nxt[j];\t\tmth[i] = j;\t}}inline int Hash(ull *hsh,int l,int r) { return hsh[r] - hsh[l - 1] * Pow[r - l + 1];}int len[N &lt;&lt; 1];int mxp[N &lt;&lt; 1],mxs[N &lt;&lt; 1];int ts[N &lt;&lt; 1];inline void work(){\tread(n);read(m);\tfor(int i = 1;i &lt;= n;i++) read(s[i]);\tfor(int i = 1;i &lt;= n;i++) read(t[i]);\tPow[0] = 1;\tfor(int i = 1;i &lt;= n;i++) Pow[i] = Pow[i - 1] * base;\thsh[0][0] = 1;\tfor(int i = 1;i &lt;= n;i++) hsh[0][i] = hsh[0][i - 1] * base + s[i];\thsh[1][0] = 1;\tfor(int i = 1;i &lt;= n;i++) hsh[1][i] = hsh[1][i - 1] * base + t[i];\tint flg = 1;\tfor(int i = 1;i &lt;= n;i++) flg &amp;= (s[i] == t[i]);\tif(flg) { printf(\"YES\\n1 1\\n2 2\\n3 %d\\n\",n);return;}\tfor(int i = 1;i &lt;= n;i++)\t\tif(Hash(hsh[1],1,i) == Hash(hsh[0],n - i + 1,n) &amp;&amp; Hash(hsh[1],i + 1,n) == Hash(hsh[0],1,n - i))\t\t{\t\t\tif(i == 1) printf(\"YES\\n%d %d\\n%d %d\\n%d %d\\n\",i + 1,i + 1,i + 2,n,1,i);\t\t\telse printf(\"YES\\n%d %d\\n%d %d\\n%d %d\\n\",i + 1,n,1,1,2,i);\t\t\treturn;\t\t}\tKMP(s,t,n,mth[0]);\tKMP(t,s,n,mth[1]);\tfor(int i = n;i &gt;= 1;i--)\t{\t\tint l = mth[0][i];\t\tif(l &gt; 0 &amp;&amp; Hash(hsh[1],l + 1,i) == Hash(hsh[0],1,i - l))\t\t\t{ printf(\"YES\\n%d %d\\n%d %d\\n%d %d\\n\",l + 1,i,1,l,i + 1,n);return;}\t\tl = mth[1][i];\t\tif(l &gt; 0 &amp;&amp; Hash(hsh[0],l + 1,i) == Hash(hsh[1],1,i - l))\t\t\t{ printf(\"YES\\n%d %d\\n%d %d\\n%d %d\\n\",i - l + 1,i,1,i - l,i + 1,n);return;}\t        if(s[i] != t[i]) break;\t}\treverse(s + 1,s + n + 1);\treverse(t + 1,t + n + 1);\tKMP(s,t,n,mth[0]);\tKMP(t,s,n,mth[1]);\treverse(s + 1,s + n + 1);\treverse(t + 1,t + n + 1);\treverse(mth[0] + 1,mth[0] + n + 1);\treverse(mth[1] + 1,mth[1] + n + 1);\tfor(int i = 1;i &lt;= n;i++)\t{\t\tint l = mth[0][i];\t\tif(l &gt; 0 &amp;&amp; Hash(hsh[0],i + l,n) == Hash(hsh[1],i,n - l))\t\t\t{ printf(\"YES\\n%d %d\\n%d %d\\n%d %d\\n\",1,i - 1,n - l + 1,n,i,n - l);return;}\t\tl = mth[1][i];\t\tif(l &gt; 0 &amp;&amp; Hash(hsh[0],i,n - l) == Hash(hsh[1],i + l,n))\t\t\t{ printf(\"YES\\n%d %d\\n%d %d\\n%d %d\\n\",1,i - 1,i + l,n,i,i + l - 1);return;}        if(s[i] != t[i]) break;\t}\tts[0] = m + 1;\tfor(int i = 1;i &lt;= n;i++)\t\tts[2 * i - 1] = s[i],ts[2 * i] = t[n - i + 1];\tint l = 0,r = 0;\tfor(int i = 1;i &lt;= 2 * n;i++) mxp[i] = mxs[i] = 0;\tfor(int i = 1;i &lt;= 2 * n;i++)\t{\t\tif(r &gt; i) len[i] = min(len[2 * l - i],r - i);        else len[i] = 0;\t\twhile(i + len[i] &lt;= 2 * n &amp;&amp; ts[i + len[i]] == ts[i - len[i] - 1])\t\t\t++len[i];\t\tif(i + len[i] &gt; r)\t\t\tl = i,r = i + len[i];\t\tif(i + len[i] &gt; 2 * n)\t\t{\t\t\tmxs[i - len[i]] = 2 * len[i];\t\t\tmxp[i - len[i] + 1] = max(mxp[i - len[i] + 1],2 * len[i] - 2);\t\t}\t\telse mxp[i - len[i]] = max(mxp[i - len[i]],2 * len[i]);\t}\tfor(int i = 2;i &lt;= 2 * n;i++) mxp[i] = max(mxp[i],mxp[i - 1] - 2);\tfor(int i = 2 * n - 1;i &gt;= 1;i--) mxs[i] = max(mxs[i],mxs[i + 1]);\tfor(int i = 1;i &lt; n;i++)\t{\t\tif(Hash(hsh[0],1,i) != Hash(hsh[1],n - i + 1,n))\t\t\tcontinue;\t\tint l = mxp[2 * i + 1] / 2;\t\tif(l &gt; 0 &amp;&amp; Hash(hsh[0],i + l + 1,n) == Hash(hsh[1],1,n - i - l))\t\t\t{ printf(\"YES\\n%d %d\\n%d %d\\n%d %d\\n\",n - i + 1,n,n - i - l + 1,n - i,1,n - i - l);return;}\t\tl = mxs[2 * i + 1] / 2;\t\tif(l &gt; 0 &amp;&amp; Hash(hsh[0],i + 1,n - l) == Hash(hsh[1],l + 1,n - i))\t\t\t{ printf(\"YES\\n%d %d\\n%d %d\\n%d %d\\n\",n - i + 1,n,l + 1,n - i,1,l);return;}\t}\tprintf(\"NO\\n\");}int main(){\tint T;\tcin &gt;&gt; T;\twhile(T--) work();\treturn 0;}\r\n","tags":["string theory"]}]