[{"title":"CF1773G 题解","url":"/posts/1150304450/","content":"这题增进了我对概率论的一些理解。\r\n\r\n设当前局面为 \\(S\\) 。\r\n容易发现，在一次 \\(S_1 \\to S_2 \\to \\dots\r\n\\to S_k\\) 的过程中，大部分的题目都不会对 \\(S\\) 产生影响。\r\n我们称对 \\(S\\) 序列产生影响的题目是\r\n\"关键的\"，显然，夹在两个“关键”题目之间的非关键题目可以任意排列，它们不会对概率产生影响。（这是比较重要的一点）。\r\n那我们的任务主要就是，在确定 \\(S\\)\r\n序列的过程中，顺便确定 \"关键题目的排列\"。\r\n\\(S\\) 只会越变越小，这给了我们 DP\r\n的状态和方式：设 \\(f_S\\) 表示到达局面\r\n\\(S\\) 的概率，转移则枚举子集。\r\n枚举从 \\(S\\) 转到 \\(T\\) 是因为哪道题目，设为 \\(s_i\\)，那么有 \\(s_i \\cap S = T\\)。设能够改变 \\(S\\) 的题目有 \\(c\\) 个（即满足 \\(S \\cap s_j \\ne \\varnothing,S\\) 的 \\(j\\) 的个数），那么这 \\(c\\) 个题目显然不会在 \\(S\\) 以前的地方出现（否则当前局面就不是\r\n\\(S\\)\r\n了）。在这一类题目中，我们要求当前枚举的 \\(s_i\\) 最早出现，对应的概率就是 \\(\\dfrac{1}{c}\\)，那么就会有 \\(\\dfrac{f_S}{c} \\to f_{S \\cap s_i}\\)。\r\n这显然过不去，但是注意到后继局面（即 \\(S\r\n\\cap s_i\\)） 相同的转移可以合并，故设 \\(g_{S,T}\\) 表示满足 \\(s_i \\cap S = T\\) 的 \\(i\\) 的个数，那么 \\(c = \\sum\\limits_{T \\ne \\varnothing,S}\r\ng_{S,T}\\)，上述转移就改写为 \\(\\dfrac{f_Sg_{S,T}}{c} \\to f_T\\)。\r\n\\(g_{S,T}\\)\r\n可以递推预处理，具体地，取任意不属于 \\(S\\) 的元素 \\(p\\)，有 \\(g_{S,T}\r\n= g_{S \\cup \\{p\\},T} + g_{S\\cup \\{p\\},T \\cup \\{p\\}}\\)。\r\n上述工作都可以在 \\(\\Theta(3^m)\\)\r\n时间内完成，故总时间复杂度为 \\(\\Theta(3^m)\\)，可以通过。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5,M = 1 &lt;&lt; 17;typedef double db;vector&lt;int&gt; g[M];db f[M],ans;int n,m;int cnt[M];int pop[M];int cc[M];#define lowbit(x) ((x)&amp;(-(x)))int tid[M];int main()&#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tstring st;int S = 0;\t\tcin &gt;&gt; st;\t\tfor(int j = 0;j &lt; m;j++)\t\t\tif(st[j] == &#x27;1&#x27;) S |= (1 &lt;&lt; j);\t\t++cnt[S];\t&#125;\tfor(int i = 1;i &lt; (1 &lt;&lt; m);i++) pop[i] = pop[i &gt;&gt; 1] + (i &amp; 1);\tfor(int S = (1 &lt;&lt; m) - 1;S &gt;= 0;--S)\t&#123;\t\tg[S].resize(1 &lt;&lt; pop[S]);\t\tif(S + 1 == (1 &lt;&lt; m))\t\t&#123;\t\t\tfor(int T = S &amp; (S - 1),i = 0;T;T = (T - 1) &amp; S,++i)\t\t\t\tg[S][i] = cnt[T],cc[S] += cnt[T];\t\t\tcontinue;\t\t&#125;\t\tint from = S | lowbit(((1 &lt;&lt; m) - 1) ^ S),p = lowbit(((1 &lt;&lt; m) - 1) ^ S);\t\tfor(int T = from &amp; (from - 1),i = 0;T;T = (T - 1) &amp; from,++i)\t\t\ttid[T] = i;\t\tfor(int T = S &amp; (S - 1),i = 0;T;T = (T - 1) &amp; S,++i)\t\t\tg[S][i] = g[from][tid[T]] + g[from][tid[T | p]],cc[S] += g[S][i];\t&#125;\tf[(1 &lt;&lt; m) - 1] = 1;\tfor(int S = (1 &lt;&lt; m) - 1;S;--S)\t&#123;\t\tif(cc[S] == 0)\t\t&#123;\t\t\tif(S &amp; 1) ans += f[S];\t\t\tcontinue;\t\t&#125;\t\tfor(int T = S &amp; (S - 1),i = 0;T;T = (T - 1) &amp; S,++i)\t\t\tf[T] += f[S] * g[S][i] / cc[S];\t&#125;\tprintf(&quot;%.9lf\\n&quot;,ans);\treturn 0;&#125;\r\n","tags":["counting"]},{"title":"省选至暑假期间的计划","url":"/posts/2035328838/","content":"之前因为种种原因，浪费了一些时间，但我还有一年时间，既然方向明确了，剩下的就是执行。\r\n\r\n在有 whk\r\n的时候，晚自习基本无法做题，不用强求，强行做题反而导致质量下降。\r\n周末有一天，除去上午和晚上用来写作业，只有一个下午的时间，能做 2\r\n道题。\r\n脱产期间，一天应该可以完成 4 题，差不多够了。\r\n先板刷 AT 吧，ARC 和 AGC 换着做。\r\n然后去寻找 CF 的题（题目来源主要是一些人的 VP 手记 和\r\n集训队作业）。\r\n可能还会去做 qoj 上的毛子题 (ptzcamp)。\r\n以及 JOISC。\r\n如果在瞎逛的时候发现好的题单也会加在这里。\r\n对于专题的训练应该要等到暑假。鉴于省选出了 4\r\n道图论，就先从图论开始练习，然后是最优化（包括贪心最优化和 DP\r\n最优化，虽然也有交叉部分），最后是计数（no poly）。\r\n希望有用。\r\n"},{"title":"模拟赛出题避坑指南","url":"/posts/1991476744/","content":"讲一下出模拟赛时踩到的坑，下次不要出锅了。\r\n\r\n数据\r\n\r\n样例也是数据的一部分，数据要检查的样例也要检查。\r\n一定要写 vaildator !!!（校验器）\r\n要时刻保证电脑上只存了一个版本的数据！\r\n上传题目前要检查每个点的数据范围是否与题面匹配。\r\n有时间就多想几个暴力/假做法，塞几组 hack 进去。\r\n上传之前用 std 再跑一遍，确保输出正确。\r\n\r\n题面\r\n\r\n检查输入输出格式是否写全，检查是否写了多组数据，检查交互格式是否清楚\r\n检查数据范围是否与数据匹配。\r\n检查对于数据的限制有没有写全。\r\n\r\n题解\r\n\r\n检查事实性错误和 typo\r\n\r\n时空限制\r\n\r\n开到 std 的两到三倍，尽量避免卡常。\r\n\r\n"},{"title":"JOISC 2021 大部分题解","url":"/posts/499612066/","content":"感觉比 \\(22\\)\r\n年的题目简单一些，能自己做出一些题目。\r\n这里有除了 【IOI 热病】 的所有传统题的题解。\r\n\r\nDay1T3 饮食区\r\n这道题再次说明 JOISC 的题目排序是乱序的。\r\n题意： https://loj.ac/p/3489\r\n容易发现，如果我们能求出这个队列目前一共 pop\r\n掉了多少人，那么我们进行整体二分/可持久化线段树+二分就可以求得答案。\r\n而求出 pop 掉多少人等价于求出这个队列现在有多少人。\r\n观察队列人数的变化，注意到操作 \\(1,2\\) 相当于区间加/区间减，同时每次操作后对\r\n\\(0\\) 取 \\(\\max\\)。\r\n当时脑子烧了，想了一个 \\(\\Theta(n \\sqrt\r\nn)\\) 的分块。实际上，Seg beats\r\n就可以做这个。然而，因为是区间操作，单点询问，我们甚至不需要 Seg\r\nbeats，只需维护一个二元标记 \\((a,b)\\)\r\n表示 \\(x \\gets \\max\\{x +\r\na,b\\}\\)，给线段树上对应节点打标记即可。\r\n时间复杂度 \\(\\Theta(Q \\log^2\r\nn)\\)。\r\n代码： https://loj.ac/s/1777073\r\nDay2T2 道路建设\r\n题意 : https://loj.ac/p/3491\r\n做完这题才意识到我两年前好像见过这题。\r\n欲求前 \\(K\\) 小，先求第 \\(K\\) 小。\r\n求第 \\(K\\)\r\n小需要二分，即找到有多少对点之间的距离 \\(\\le\r\nmid\\)。\r\n此时曼哈顿距离就不大好做了，考虑将坐标系旋转 \\(45^{\\circ}\\) （即 \\((x,y) \\to (x + y,x - y)\\)\r\n），此时原图的曼哈顿距离是新图的切比雪夫距离，即 \\(\\max\\{|x_1 - x_2|,|y_1 - y_2|\\}\\)。\r\n那么 \\(\\max\\{|x_1 - x_2|,|y_1 - y_2|\\} \\le\r\nmid\\) 就等价于 \\(|x_1 - x_2| \\le\r\nmid,|y_1 - y_2| \\le mid\\)。\r\n那么把点按 \\(x\\) 坐标排序后，用一个\r\nset 维护所有跟当前点 \\(x\\)\r\n坐标相差不超过 \\(mid\\) 的点集即可。\r\n在找有多少对点的距离 \\(\\le mid\\)\r\n的时候，我们顺便把所有 \\(\\le mid\\)\r\n的点对都扔到一个答案数组里，这样在二分得到第 \\(K\\) 小的时候，也顺便把前 \\(K\\) 小都找出来了。\r\n时间复杂度 \\(\\Theta(n \\log ^2\r\nn)\\)。\r\n代码：https://loj.ac/s/1777222\r\nDay3T2 保镖\r\n题意：https://loj.ac/p/3494\r\n神仙题，主要是第一步难以想到。\r\n考虑保镖和人相遇需要时间和位置都重合，在一维的数轴上不好做，不妨以坐标和时间为两维建立坐标系，将问题变为二维。\r\n此时每个人相当于一条斜率为 \\(1\\) 或\r\n\\(-1\\)\r\n的线段，保镖的行走路径则是摇摆着向上的折线。\r\n图还是不大美观，考虑将坐标系旋转 \\(45^{\\circ}\\)，此时每个人变为一条横线或一条竖线，保镖则是只能向右或向上走，想要最大化小费。\r\n注意到在两次变换之后，新图中两点之间的距离被拉长至原图的 \\(\\sqrt 2 \\times \\sqrt 2 = 2\\) 倍，所以 \\(C_i\\) 要除以 \\(2\\)（这就是为什么 \\(C_i\\) 是偶整数）。\r\n此时所有人的轨迹可以交织成一张网格图。如果保镖从一开始就在网格图的格点上，那么答案其实是容易算的。设\r\n\\(dp_{i,j}\\) 表示从网格图中的点 \\((i,j)\\)\r\n出发能得到的最大小费，转移是简单的。\r\n问题在于保镖一开始可能落在某个小网格的中间。\r\n考虑此时保镖的决策，一定是先向上走一段，走到某条格线，然后向右拐走到一个格点。也可能先向右再向上，这是对称的。\r\n此时，保镖走的第一段路是没有贡献的。设其走的第二段路权值为 \\(c\\)，长度为 \\(x\\)，走到了格点 \\((i,j)\\)，那么贡献是 \\(cx + dp_{i,j}\\)。\r\n对于一个 \\((i,j)\\)，\\(c\\) 和 \\(dp_{i,j}\\)\r\n都是确定的，这个式子就是一个关于长度的一次函数。我们回答询问，就是对于一个一次函数序列的前缀，查询某个横坐标对应的最值。\r\n显然，使用李超线段树即可做到 \\(\\Theta(n^2\r\n\\log n + Q \\log n)\\)。\r\n其实还可以做得更好。\r\n注意到 \\(DP\\) 值是具有单调性的，即\r\n\\(dp_{i,j} \\le dp_{i,j - 1}\\)。而 \\(dp\\)\r\n值就是一次函数的截距，而如果一个函数的斜率和截距都不超过另一个函数，说明该函数已经没有用了。据此我们可以维护一个斜率递减的单调栈，因为我们可以保证每次插入的直线的截距都是当前最大的。维护单调栈时再把不符合凸性的直线弹出\r\n，我们就可以均摊 \\(O(1)\\)\r\n的维护一个凸壳。查询时在凸壳上二分即可。\r\n实现的时候可能要把图像按 \\(y\\)\r\n轴对称，因为斜率递减的话，我们相当于是从右往左的维护了一个凸壳，不大方便。对称过后即使正常的从左往右维护凸壳。其实不这么做问题应该也不大。\r\n时间复杂度 \\(\\Theta(n^2 + Q\\log\r\nn)\\)。\r\n代码：https://loj.ac/s/1778383\r\nDay3T3 聚会 2\r\n题意：https://loj.ac/p/3495\r\n","tags":["板刷记录"]},{"title":"JOISC2022 Day2 题解","url":"/posts/401156015/","content":"事实上没有通信题题解。\r\n这两题都没想出完整做法，不知道是不是睡眠质量的问题。按道理来说都应是\r\n“刚好会做” 的题。\r\n按体感难度排序。\r\n\r\nloj3690 团队竞技\r\n题意： https://loj.ac/p/3690\r\n老老实实地想了除最后一个包的所有点。\r\n无语住了。\r\n按 \\(x\\) 从小到大排序，扫描 \\(x\\)\r\n最大的那个人，剩下两人都要在他前面。设剩下两人为 \\((y_1,z_1),(y_2,z_2)\\)，那么有 \\(y_1 &gt; y_2,z_1 &lt; z_2\\)。\r\n我们加入一个 \\((y,z)\\)\r\n的时候，其实就可以找到与其配对的另一个人 (满足 \\(y_0 &lt; y\\) 的 \\((y_0,z_0)\\) 中 \\(z_0\\) 最大的，以及满足 \\(z_0 &lt; z\\) 的 \\((y_0,z_0)\\) 中 \\(y_0\\) 最大的)。\r\n将 \\((y,z)\\) 与和其配对的点合成一对\r\n\\((Y,Z)\\)，扔到一个二维数据结构里面。扫描到\r\n\\(i\\) 时，查询 \\(Y &gt; y_i,Z &gt; z_i\\) 的 \\(Y + Z\\) 最大值即可。\r\n时间复杂度 \\(\\Theta(n \\log^2\r\nn)\\)。\r\nloj3688 复制粘贴 3\r\n题意 : https://loj.ac/p/3688\r\n想到了区间\r\nDP，但脑子不在状态，只是描绘了一个复制粘贴的形态，没有在纸上细推，导致转移没有编出来。\r\n至于如何想到，其实可以考虑观察样例 \\(1\\)\r\n的构造过程。其没有明显的顺序或倒序构造的特征，不过仍然是从小串构造出包含它的大串，即\r\n\\(\\text{ssi} \\to \\text{ssissi} \\to\r\n\\text{mississi} \\to \\text{mississippi}\\)，这反映到区间上就是\r\n\\([3,5] \\to [3,8] \\to [1,8] \\to\r\n[1,11]\\)。一条区间 DP 的转移路径。\r\n那么我们可设 \\(f(l,r)\\)\r\n表示不管当前的剪贴板是什么，构造出 \\(f(l,r)\\) 的最小步数。\r\n考虑我们剪切了一个串后，用其构造出来的串一定形如 \\(A_1YA_2Y\\dots YA_k\\) （其中 \\(A_i\\) 都是我们手打的字符）。\r\n其中头尾两段不是很好处理，我们考虑编两个转移来包含这两段。\r\n显然有 \\(f(l,r+1) \\gets f(l,r) + A\\)\r\n(其中 \\(\\gets\\) 表示 \\(\\text{ckmin}\\))。\r\n考虑 \\(A_1\\) 怎么办 ，我们设 \\(g(l,r)\\) 表示构造出 \\([l,r]\\)\r\n，且最后一次操作是粘贴的最小步数。\r\n当我们从 \\(f(l,r)\\)\r\n向外转移时，可以先令 \\(f(l,r) \\gets\r\ng(l,r)\\)，然后 \\(g(l,r) \\gets f(l,r) +\r\nB + C\\)。\r\n依据 \\(g\\) 的定义，我们可以转移\r\n\\(g(l - 1,r) \\gets g(l,r) + A\\)。\r\n至此，\\(A_1\\) 和 \\(A_k\\) 都处理完了。\r\n那么我们多次粘贴 \\(S[l,r]\\)\r\n时，可以默认我们构造出来的串开头是 \\(S[l,r]\\)，结尾也是 \\(S[l,r]\\)。\r\n那么我们设 \\(nxt(l,r)\\) 表示 \\(S[l,r]\\) 最早的出现位置使得该位置不在 \\([l,r]\\) 中。\r\n那么我们每次转移暴力跳 \\(nxt\\)\r\n即可转移。\r\n因为我们至多跳 \\(\\dfrac{n}{r-l+1}\\)\r\n次，复杂度是 \\(O(n^2 \\log n)\\) 的\r\n(\\(\\log\\) 是调和级数)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline void ckmin(T &amp;x,const T &amp;y) &#123; if(x &gt; y) x = y;&#125;const int N = 2.5e3 + 5;typedef unsigned long long ull;const ull base = 13331;int n;int A,B,C;char s[N];int nxt[N][N];long long f[N][N],g[N][N];ull hsh[N],Pow[N];ull h[N][N];map&lt;ull,int&gt; ton;int main()&#123;\tcin &gt;&gt; n;\tcin &gt;&gt; (s + 1);\tcin &gt;&gt; A &gt;&gt; B &gt;&gt; C;\tPow[0] = 1;\tfor(int i = 1;i &lt;= n;i++) Pow[i] = Pow[i - 1] * base;\tfor(int i = 1;i &lt;= n;i++) hsh[i] = hsh[i - 1] * base + (s[i] - &#x27;a&#x27; + 1);\tfor(int i = 1;i &lt;= n;i++)\t\tfor(int j = i;j &lt;= n;j++)\t\t\th[i][j] = hsh[j] - hsh[i - 1] * Pow[j - i + 1];\tfor(int l = 1;l &lt;= n;l++)\t&#123;\t\tton.clear();\t\tfor(int i = n - l + 1;i + l - 1 &gt; n - l;i--)\t\tnxt[i][i + l - 1] = n + 1;\t\tfor(int i = n - l - l + 1;i &gt;= 1;i--)\t\t&#123;\t\t\tton[h[i + l][i + l + l - 1]] = i + l;\t\t\tif(ton.find(h[i][i + l - 1]) == ton.end())\t\t\t\tnxt[i][i + l - 1] = n + 1;\t\t\telse nxt[i][i + l - 1] = ton[h[i][i + l - 1]];\t\t&#125;\t&#125;\tmemset(f,0x3f,sizeof f);\tmemset(g,0x3f,sizeof g);\tfor(int i = 1;i &lt;= n;i++)\t\tf[i][i] = A;\tfor(int len = 1;len &lt;= n;len++)\t&#123;\t\tfor(int i = 1;i + len - 1 &lt;= n;i++)\t\t&#123;\t\t\tint j = i + len - 1;\t\t\tckmin(f[i][j],g[i][j]);\t\t\tif(j &lt; n) ckmin(f[i][j + 1],f[i][j] + A);\t\t\tint now = nxt[i][j],cnt = 2;\t\t\twhile(now &lt;= n)\t\t\t\tckmin(f[i][now + len - 1],f[i][j] + B + 1ll * cnt * C + 1ll * A * (now + len - i - cnt * len)),\t\t\t\t++cnt,now = nxt[now][now + len - 1];\t\t&#125;\t\tfor(int i = 2;i + len - 1 &lt;= n;i++)\t\t\tckmin(f[i - 1][i + len - 1],f[i][i + len - 1] + A);\t&#125;\t\t\tcout &lt;&lt; f[1][n] &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["板刷记录"]},{"title":"JOISC2022 Day1 题解","url":"/posts/2573606988/","content":"体感难度 : T3 &lt; T1 &lt; T2\r\nT3 成了最近板刷唯一做出来的题。\r\nT1 是“刚好会做”和“刚好不会做”的题。\r\nT2 非常强大，有些启发。\r\n\r\nloj3687 D1T3 错误拼写\r\n题意：计数满足如下要求的字符串 \\(S\\)\r\n：\r\n\r\n\\(|S| = n\\)\r\n设 \\(T_i\\) 表示将 \\(S\\) 中第 \\(i\\)\r\n个字符删去后得到的字符串。给出两个长度为 \\(m\\) 的数组 \\(A_i,B_i\\)，要求 \\(S\\) 满足 \\(T_{A_i} \\le T_{B_i}\\) （$$\r\n是字典序小于等于）。\r\n\r\n\\(1 \\le n,m \\le 5 \\times\r\n10^5\\)。\r\n考虑一个 \\(T_{l} \\le T_{r} (l \\le\r\nr)\\) 代表什么。\r\n显然，这个大小关系等价于 \\(s[l,r -\r\n1]\\) 与 \\(s[l + 1,r]\\)\r\n的大小关系。\r\n对每一位进行比较，就相当于比较 \\(s_i\\) 和 \\(s_{i+1}\\)。\r\n这启发我们根据 \\(s\\)\r\n中的连续相等段进行 DP。\r\n设 \\(f[i][c][0/1]\\) 表示 \\(i\\) 是 \\(s\\) 中某个极长相等段的右端点，\\(s_i = c\\)，\\(s_i\\) 是小于 \\(s_{i+1}\\) 还是大于 \\(s_{i+1}\\)。枚举 \\(i\\) 的那个连续段 \\([j + 1,i]\\)，尝试从 \\(f[j]\\) 转移，然后考虑 \\(A,B\\) 带来的限制。\r\n如果存在 \\(k\\) 满足 \\(j + 1 \\le A_k \\le i \\lt B_k\\)，说明 \\(s_i\\) 必须小于 \\(s_{i+1}\\) （因为状态中定义 \\(s_i \\ne s_{i+1}\\)）。\r\n同理，如果存在 \\(k\\) 满足 \\(j + 1 \\le B_k \\le i \\lt A_k\\)，那 \\(s_i &gt; s_{i+1}\\)。\r\n如果这两个条件满足则不能从 \\(j\\)\r\n转移到 \\(i\\)。\r\n否则，不满足和只满足一个的 \\(j\\)\r\n肯定是一段区间，而这些区间的转移是相同的。进行一些前缀和优化即可做到\r\n\\(\\Theta(n \\Sigma)\\)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;namespace FastIO&#123;\t#define iL (1 &lt;&lt; 20)\tchar ibuf[iL],*iS = ibuf + iL,*iT = ibuf + iL;\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf,1,iL,stdin),iS == iT ? EOF : *iS++) : *iS++)\ttemplate&lt;typename T&gt;\tinline void read(T &amp;a)\t&#123;\t\tchar ch;int sign = 0;\t\tfor(ch = gc();!isdigit(ch);ch = gc())\t\t\tif(ch == &#x27;-&#x27;) sign = 1;\t\ta = ch &amp; 15;\t\tfor(ch = gc();isdigit(ch);ch = gc())\t\t\ta = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch &amp; 15);\t\tif(sign) a = -a;\t&#125;\tchar Out[iL],*iter = Out;\t#define flush() fwrite(Out,1,iter - Out,stdout),iter = Out\ttemplate&lt;typename T&gt;\tinline void write(T x,char end = &#x27;\\n&#x27;)\t&#123;\t\tint c[40],l = 0;if(x &lt; 0) *iter++ = &#x27;-&#x27;,x = -x;\t\tdo c[++l] = x % 10,x /= 10; while(x);\t\twhile(l) *iter++ = c[l--] + &#x27;0&#x27;;\t\t*iter++ = end;flush();\t&#125;\t#undef iL \t#undef gc\t#undef flush&#125;using namespace FastIO;const int N = 5e5 + 5,P = 1e9 + 7,C = 26;inline void Plus(int &amp;x,const int &amp;y) &#123; x += y;if(x &gt;= P) x -= P;&#125;int n,m;int a[N],b[N];bool tp[N];int Mxr[2][N];int L[N],R[N]; // 有限制的转移区间，[Ri+1,i-1] 是没有限制的转移区间int f[N][C][2],sum[N][C][2];int ST[2][20][N],lg[N];inline int Qmax(int (*ST)[N],int l,int r)&#123;\tint k = lg[r - l + 1];\treturn max(ST[k][l],ST[k][r-(1&lt;&lt;k)+1]);&#125;int main()&#123;\tread(n);read(m);\tfor(int i = 1;i &lt;= m;i++) read(a[i]),read(b[i]);\tfor(int i = 1;i &lt;= m;i++)\t\tif(a[i] &lt; b[i]) Mxr[0][a[i]] = max(Mxr[0][a[i]],b[i] - 1);\t\telse Mxr[1][b[i]] = max(Mxr[1][b[i]],a[i] - 1);\t\tlg[0] = -1;\tfor(int i = 1;i &lt;= n;i++) lg[i] = lg[i &gt;&gt; 1] + 1;\tfor(int i = 1;i &lt;= n;i++) ST[0][0][i] = Mxr[0][i],ST[1][0][i] = Mxr[1][i];\tfor(int j = 1;j &lt; 20;j++)\t\tfor(int i = 1;i + (1 &lt;&lt; j) - 1 &lt;= n;i++)\t\t\tST[0][j][i] = max(ST[0][j - 1][i],ST[0][j - 1][i + (1 &lt;&lt; j - 1)]),\t\t\tST[1][j][i] = max(ST[1][j - 1][i],ST[1][j - 1][i + (1 &lt;&lt; j - 1)]);\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tint v1,v2;\t\tint lef = 0,righ = i;\t\twhile(lef &lt; righ)\t\t&#123;\t\t\tint mid = lef + righ + 1 &gt;&gt; 1;\t\t\tif(Qmax(ST[0],mid,i) &gt;= i) lef = mid;\t\t\telse righ = mid - 1;\t\t&#125;\t\tv1 = lef;\t\tlef = 0;righ = i;\t\twhile(lef &lt; righ)\t\t&#123;\t\t\tint mid = lef + righ + 1 &gt;&gt; 1;\t\t\tif(Qmax(ST[1],mid,i) &gt;= i) lef = mid;\t\t\telse righ = mid - 1;\t\t&#125;\t\tv2 = lef;\t\tL[i] = min(v1,v2);\t\tR[i] = max(v1,v2) - 1;\t\tif(v1 &lt; v2) tp[i] = 1; else tp[i] = 0;\t\t// printf(&quot;L,R,tp:%d,%d,%d,%d,%d\\n&quot;,L[i],R[i],tp[i],v1,v2);\t&#125;\tf[0][0][0] = f[0][1][1] = sum[0][0][0] = sum[0][1][1] = 1;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tif(R[i] &lt; i)\t\t&#123;\t\t\tint ss[C];\t\t\tmemset(ss,0,sizeof ss);\t\t\tfor(int j = 0;j &lt; C;j++)\t\t\t&#123;\t\t\t\tss[j] = sum[i - 1][j][0];\t\t\t\tif(R[i] &gt;= 0) Plus(ss[j],P - sum[R[i]][j][0]);\t\t\t\tj ? Plus(ss[j],ss[j - 1]) : void();\t\t\t&#125;\t\t\t\t\t\t\tfor(int j = 1;j &lt; C;j++)\t\t\t\tPlus(f[i][j][0],ss[j - 1]),Plus(f[i][j][1],ss[j - 1]);\t\t\tmemset(ss,0,sizeof ss);\t\t\tfor(int j = C - 1;j &gt; 0;j--)\t\t\t&#123;\t\t\t\tss[j] = sum[i - 1][j][1];\t\t\t\tif(R[i] &gt;= 0) Plus(ss[j],P - sum[R[i]][j][1]);\t\t\t\tj != C - 1 ? Plus(ss[j],ss[j + 1]) : void();\t\t\t&#125;\t\t\tfor(int j = 0;j &lt; C - 1;j++)\t\t\t\tPlus(f[i][j][0],ss[j + 1]),Plus(f[i][j][1],ss[j + 1]);\t\t&#125;\t\tif(R[i] &gt;= 0 &amp;&amp; L[i] &lt;= R[i])\t\t&#123;\t\t\tint ss[C];\t\t\tmemset(ss,0,sizeof ss);\t\t\tfor(int j = 0;j &lt; C;j++)\t\t\t&#123;\t\t\t\tPlus(ss[j],sum[R[i]][j][0]);\t\t\t\tif(L[i] &gt; 0) Plus(ss[j],P - sum[L[i] - 1][j][0]);\t\t\t\tif(j) Plus(ss[j],ss[j - 1]);\t\t\t&#125;\t\t\tfor(int j = 1;j &lt; C;j++)\t\t\t\tPlus(f[i][j][tp[i]],ss[j - 1]);\t\t\tmemset(ss,0,sizeof ss);\t\t\tfor(int j = C - 1;j &gt; 0;j--)\t\t\t&#123;\t\t\t\tPlus(ss[j],sum[R[i]][j][1]);\t\t\t\tif(L[i] &gt; 0) Plus(ss[j],P - sum[L[i] - 1][j][1]);\t\t\t\tif(j != C - 1) Plus(ss[j],ss[j + 1]);\t\t\t&#125;\t\t\tfor(int j = 0;j &lt; C - 1;j++)\t\t\t\tPlus(f[i][j][tp[i]],ss[j + 1]);\t\t&#125;\t\tfor(int j = 0;j &lt; C;j++)\t\t\tsum[i][j][0] = sum[i - 1][j][0],Plus(sum[i][j][0],f[i][j][0]),\t\t\tsum[i][j][1] = sum[i - 1][j][1],Plus(sum[i][j][1],f[i][j][1]);\t&#125;\tint ans = 0;\tfor(int j = 0;j &lt; C;j++)\t\tPlus(ans,f[n][j][0]);\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\nloj3685 D1T1 监狱\r\n题意 : https://loj.ac/p/3685\r\n这种一眼难有多项式做法的题，一般是需要发掘一些性质的。\r\n我们断言一个囚犯如果开始走，就不会在中途停留，会一直从 \\(S_i\\) 走到 \\(T_i\\)。\r\n感性理解一下，考虑路径 \\((S_i,T_i)\\)\r\n如果中途停留在了某个点 \\(x\\)，说明有些路径的 \\(T\\) 在 \\(S_i\\) 到 \\(x\\) 的路径上上（所以要走到 \\(x\\) 使得它们可以走过来），有些路径的 \\(S\\) 在 \\(x\\) 到 \\(T_i\\) 的路径上。但是此时，我们先走那些\r\n\\(S\\) 在 \\(x\\) 到 \\(T_i\\) 的路径，再走当前这条，再走 \\(T\\) 在 \\(S_i\\) 到 \\(x\\)\r\n上的路径，效果是一样的，且没有中间停留。\r\n这个结论出来了之后，我们就可以直接考虑两条路径的关系。对于 \\((S_i,T_i)\\) 和 \\((S_j,T_j)\\)，如果 \\(S_j\\) 在 \\(S_i\\) 到 \\(T_i\\) 的路径上，说明 \\(j\\) 比 \\(i\\) 要先走，如果 \\(T_j\\) 在 \\(S_i\\) 到 \\(T_i\\) 的路径上，说明 \\(j\\) 比 \\(i\\) 要后走。\r\n把这个二元关系建个图跑拓扑排序就能拿到 \\(60\\) 分。\r\n我都想到了这里，但没有想到，接下来的事情只需一个倍增优化建图即可。\r\n优化建图的具体细节可以看代码。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1.5e5 + 5,Sz = N * 44,M = 4e7 + 5;int n,m;vector&lt;int&gt; G[N];int s[N],t[N];int anc[20][N],up[20][N],down[20][N],dep[N];int deg[Sz];int fir[Sz],nxt[M],to[M],ect = 0;inline void addedge(int u1,int v1) &#123; nxt[++ect] = fir[u1];fir[u1] = ect;to[ect] = v1;++deg[v1];&#125;int idcnt;void dfs0(int x,int f)&#123;\tanc[0][x] = f;dep[x] = dep[f] + 1;\tfor(int i = 1;i &lt;= 19;i++) anc[i][x] = anc[i - 1][anc[i - 1][x]];\tfor(auto y : G[x])\t\tif(y != f) dfs0(y,x);&#125;int jump(int x,int y)&#123;\tfor(int i = 19;i &gt;= 0;i--)\t\tif(dep[anc[i][x]] &gt; dep[y]) x = anc[i][x];\treturn x;&#125;int lca(int x,int y)&#123;\tif(dep[x] &lt; dep[y]) swap(x,y);\tfor(int i = 19;i &gt;= 0;i--)\t\tif(dep[anc[i][x]] &gt;= dep[y]) x = anc[i][x];\tif(x == y) return x;\tfor(int i = 19;i &gt;= 0;i--)\t\tif(anc[i][x] != anc[i][y])\t\t\tx = anc[i][x],y = anc[i][y];\treturn anc[0][x];&#125;void work()&#123;\t\tect = 0;\tfor(int i = 1;i &lt;= idcnt;i++)\t\tfir[i] = deg[i] = 0;\tidcnt = 0;\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++) G[i].clear();\tfor(int i = 1;i &lt; n;i++)\t&#123;\t\tint a,b;\t\tcin &gt;&gt; a &gt;&gt; b;\t\tG[a].push_back(b);\t\tG[b].push_back(a);\t&#125;\tcin &gt;&gt; m;\tfor(int i = 1;i &lt;= m;i++)\t\tcin &gt;&gt; s[i] &gt;&gt; t[i];\tidcnt = m;\tfor(int i = 1;i &lt;= n;i++)\t\tfor(int j = 0;j &lt; 20;j++) anc[j][i] = 0;\tdfs0(1,0);\tfor(int i = 1;i &lt;= n;i++)\t\tup[0][i] = ++idcnt,down[0][i] = ++idcnt;\tfor(int j = 1;j &lt; 20;j++)\t\tfor(int i = 1;i &lt;= n;i++)\t\tif(dep[i] &gt;= (1 &lt;&lt; j))\t\t&#123;\t\t\tup[j][i] = ++idcnt;down[j][i] = ++idcnt;\t\t\tif(j)\t\t\t&#123;\t\t\t\taddedge(up[j - 1][i],up[j][i]);addedge(up[j - 1][anc[j - 1][i]],up[j][i]);\t\t\t\taddedge(down[j][i],down[j - 1][i]);addedge(down[j][i],down[j - 1][anc[j - 1][i]]);\t\t\t&#125; \t\t&#125;\tfor(int i = 1;i &lt;= m;i++)\t&#123;\t\tint x = s[i],y = t[i];\t\taddedge(i,up[0][x]);addedge(down[0][y],i);\t\tx = lca(s[i],t[i]) == s[i] ? jump(t[i],s[i]) : anc[0][s[i]];\t\tif(dep[x] &lt; dep[y]) swap(x,y);\t\tfor(int j = 19;j &gt;= 0;j--)\t\t\tif(dep[anc[j][x]] &gt;= dep[y])\t\t\t\taddedge(up[j][x],i),x = anc[j][x];\t\tif(x == y) addedge(up[0][x],i);\t\telse\t\t&#123;\t\t\tfor(int j = 19;j &gt;= 0;j--)\t\t\tif(anc[j][x] != anc[j][y])\t\t\t\taddedge(up[j][x],i),addedge(up[j][y],i),\t\t\t\tx = anc[j][x],y = anc[j][y];\t\t\taddedge(up[0][x],i);addedge(up[0][y],i);\t\t\taddedge(up[0][anc[0][x]],i);\t\t&#125;\t\t\t\tx = s[i];y = lca(s[i],t[i]) == t[i] ? jump(s[i],t[i]) : anc[0][t[i]];\t\tif(dep[x] &lt; dep[y]) swap(x,y);\t\tfor(int j = 19;j &gt;= 0;j--)\t\t\tif(dep[anc[j][x]] &gt;= dep[y])\t\t\t\taddedge(i,down[j][x]),x = anc[j][x];\t\tif(x == y) addedge(i,down[0][x]);\t\telse\t\t&#123;\t\t\tfor(int j = 19;j &gt;= 0;j--)\t\t\tif(anc[j][x] != anc[j][y])\t\t\t\taddedge(i,down[j][x]),addedge(i,down[j][y]),\t\t\t\tx = anc[j][x],y = anc[j][y];\t\t\taddedge(i,down[0][x]);addedge(i,down[0][y]);\t\t\taddedge(i,down[0][anc[0][x]]);\t\t&#125;\t\t&#125;\tqueue&lt;int&gt; Q;\tfor(int i = 1;i &lt;= idcnt;i++) if(!deg[i]) Q.push(i);\twhile(!Q.empty())\t&#123;\t\tint x = Q.front();Q.pop();\t\t// printf(&quot;Q:%d\\n&quot;,x);\t\tfor(int i = fir[x],y;y = to[i],i;i = nxt[i])\t\t\tif(!(--deg[y])) Q.push(y);\t&#125;\tfor(int i = 1;i &lt;= idcnt;i++) if(deg[i]) return puts(&quot;No&quot;),void();\tputs(&quot;Yes&quot;);&#125;int main()&#123;\tint T;\tcin &gt;&gt; T;\twhile(T--) work();\treturn 0;&#125;\r\nloj3686 D1T2 京都观光\r\n题意： https://loj.ac/p/3686\r\n直接 DP 可以拿到 10 分的高分。我们仍然需要挖掘一些性质。\r\n考察两行 \\(x = i,x = j\\)，两列 \\(y = l,y = r\\)，假设我们不会中间拐弯。\r\n先横再竖的代价是 \\(A_i(r - l) + B_r(j -\r\ni)\\)\r\n先竖再横的代价是 \\(B_l(j - i) + A_j(r -\r\nl)\\)。\r\n那么我们选择先走横当且仅当 \\(\\dfrac{A_j -\r\nA_i}{j-i} &gt; \\dfrac{B_r - B_l}{r-l}\\)。\r\n这启示我们答案路径的选择和斜率有关。\r\n既然涉及到了斜率，就不能只考察二元关系了。\r\n考察三行 \\(x = i,x = j,x = k\\)，两列\r\n\\(y = m,y = n\\)。\r\n\r\n蓝色路径减红色路径的代价是 \\((B_n - B_m)(k\r\n- j) + (A_j - A_k)(n - m)\\)\r\n蓝色路径减绿色路径的代价是 \\((B_m - B_n)(j\r\n- i) + (A_j - A_i)(n-m)\\)。\r\n如果这两个值不都小于 \\(0\\)，说明\r\n\\(x = j\\) 这一列就没啥用了。\r\n上面的式子小于 \\(0\\) 当且仅当 \\(\\dfrac{B_n - B_m}{n - m} &lt; \\dfrac{A_k - A_j}{k\r\n- j}\\)。\r\n下面的式子小于 \\(0\\) 当且仅当 \\(\\dfrac{B_m - B_n}{m - n} &gt; \\dfrac{A_j - A_i}{j\r\n- i}\\)\r\n那么我们发现，当对于任意 \\(i &lt; j &lt;\r\nk\\) ，都有 \\(\\dfrac{A_j - A_i}{j - i}\r\n&lt; \\dfrac{A_k - A_j}{k - j}\\) 时，\\(j\\) 才可能有用，说明有用的 \\((i,A_i)\\) 一定形成一个凸包。\\(B\\) 同理。\r\n把两个序列的凸包求出来之后，我们要根据这两个凸包求答案。\r\n这个时候可以直接做个闵可夫斯基和，也就是对凸包中的直线进行一个归并排序。再换句话说，就是每次根据最开始的那个\r\n\\(\\dfrac{A_j - A_i}{j - i}\\) 与 \\(\\dfrac{B_r - B_l}{r - l}\\)\r\n的大小关系，决定先走横还是先走竖。这个过程可以导出唯一解，且任意其他的解都可以通过不断调整得到这个解，所以这就是个最优解。\r\n具体细节可以看代码。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int n,m,a[N],b[N];inline double slopeA(int x,int y) &#123; return 1.0*(a[y] - a[x]) / (y - x);&#125;inline double slopeB(int x,int y) &#123; return 1.0*(b[y] - b[x]) / (y - x);&#125;int ha[N],cnta; int hb[N],cntb;// a,b 两边的凸包int main()&#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i];\tfor(int i = 1;i &lt;= m;i++) cin &gt;&gt; b[i];\tha[cnta = 1] = 1;\tfor(int i = 2;i &lt;= n;i++)\t&#123;\t\twhile(cnta &gt; 1 &amp;&amp; slopeA(ha[cnta - 1],ha[cnta]) &gt; slopeA(ha[cnta],i))\t\t\t--cnta;\t\tha[++cnta] = i;\t&#125;\thb[cntb = 1] = 1;\tfor(int i = 2;i &lt;= m;i++)\t&#123;\t\twhile(cntb &gt; 1 &amp;&amp; slopeB(hb[cntb - 1],hb[cntb]) &gt; slopeB(hb[cntb],i))\t\t\t--cntb;\t\thb[++cntb] = i;\t&#125;\tlong long ans = 0;\tint i = 1,j = 1;\twhile(i &lt; cnta &amp;&amp; j &lt; cntb)\t\tif(slopeA(ha[i],ha[i + 1]) &lt;= slopeB(hb[j],hb[j + 1]))\t\t\tans += 1ll * b[hb[j]] * (ha[i + 1] - ha[i]),++i;\t\telse ans += 1ll * a[ha[i]] * (hb[j + 1] - hb[j]),++j;\twhile(i &lt; cnta) ans += 1ll * b[hb[j]] * (ha[i + 1] - ha[i]),++i;\twhile(j &lt; cntb) ans += 1ll * a[ha[i]] * (hb[j + 1] - hb[j]),++j;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\t\r\n","tags":["板刷记录"]},{"title":"「USACO 2022.2 Platinum」 题解","url":"/posts/2649489914/","content":"没有一道题想出完整做法。真是让人自闭。\r\n按体感难度排序。\r\n\r\nloj3668 Sleeping in Class\r\n题意：给出一个序列 \\(a_1,a_2,\\dots,a_n\\)，一次操作可以将两个相邻的数\r\n\\(x,y\\) 合并为 \\(x + y\\)，也可以将数 \\(t\\) 分解为两个相邻的数 \\(x,t-x\\)，问最后使得序列中的所有数都等于\r\n\\(V\\) 的最少操作次数。可能无解。\\(Q\\) 次询问，每次给出不同的 \\(V\\)。\r\n\\(1 \\le n,Q \\le 10^5\\)。\r\n设 \\(s_i\\) 表示 \\(a_i\\) 的前缀和。\r\n那么 \\(V \\nmid s_n\\) 则无解。\r\n否则最优策略一定如下：\r\n维护当前准备参与操作的数 \\(p\\)\r\n，初始 \\(p = 0\\)。从左到右扫描到 \\(i\\)，把 \\(p\\) 与 \\(a_i\\) 合并，如果此时 \\(p &gt; V\\)，就不停地从 \\(p\\) 中分出 \\(V\\) 来。\r\n观察这个过程，发现 \\(p = s_i \\bmod\r\nV\\) （特例，如果 \\(s_i \\bmod V =\r\n0\\)，\\(p = V\\)）\r\n我们发现，如果没有 \\(s_i \\bmod V = 0 (i\r\n&lt; n)\\) 的位置，那么分裂要进行 \\(\\dfrac{s_n}{V} - 1\\) 次，合并要进行 \\(n - 1\\)\r\n次，而每出现一个这样的位置，可以少一次分裂，少一次合并。故答案为 \\(\\dfrac{s_n}{V} - 1 + (n - 1) + \\sum_{i=1}^{n-1} [V\r\n\\mid s_i]\\)。\r\n我当时转化出来的东西没有这么简洁明了，所以寄了。\r\n考虑如何求出 \\(\\sum [V |\r\ns_i]\\)，注意到 \\(V |\r\ns_n\\)，所以我们只关心所有的 \\(\\gcd(s_i,s_n)\\) 。考察 \\(V\\) 和 \\(D =\r\n\\gcd(s_i,s_n)\\) 的质因子分解。设其分别为 \\(\\prod p_i^{b_i},\\prod p_i^{c_i}\\) ，那么\r\n\\(D\\) 对 \\(V\\) 有贡献当且仅当 \\(\\forall i,b_i \\le\r\nc_i\\)。我们发现这是一个高维后缀和的形式，而这事实上也是可以做的，因为\r\n\\(d(s_n)\\) 在 \\(s_n \\le 10^{18}\\) 时大约只有 \\(10^5\\) 级别，而维数也是 \\(\\omega(s_n)\\)\r\n，很小。这里高维后缀和的时间复杂度为 \\(O(d(s_n)w(s_n)\\log d(s_n))\\) （这里的 \\(\\log\\) 是使用 map\r\n进行离散化的复杂度）。\r\n现在的问题在于如何求出 \\(s_n\\)\r\n的质因子分解了。做过 AGC003D 的同学应该熟悉这样一个方法：设值域为 \\(L\\)，先将不超过 \\(L^{1/3}\\) 的质因子试除掉。如果剩下的数小于\r\n\\(L^{2/3}\\)，那么其一定是一个质数\r\n，否则其质因子就被试除掉了。如果大于 \\(L^{2/3}\\)，那么先前试除掉的部分总共就不超过\r\n\\(L^{1/3}\\)，而剩余部分一定是至多两个质数相乘的形式。此时\r\n\\(d(s_n) \\le 4 \\times \\max_{1 \\le i \\le\r\nL^{1/3}} d(i)\\)。\r\n此题中 \\(L =\r\n10^{18}\\)。对于最后的那种情况，可能的 \\(V\\) 只有几千个，直接暴力即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;typedef long long ll;int n,Q;ll a[N];map&lt;long long,long long&gt; mp;int pri[N],cnt[N],tot;ll pw[N];map&lt;long long,int&gt; f;inline ll calc(int *p) // 把幂次数组压成long long 整数&#123;\tll res = 0;\tfor(int i = 1;i &lt;= tot;i++)\t\tres += 1ll * p[i] * pw[i];\treturn res;&#125;inline ll rev(ll x) // 把状压后的整数变为质因数分解前的数&#123;\tll res = 1;\tfor(int i = 1;i &lt;= tot;i++)\t&#123;\t\tll pp = (x / pw[i]) % (cnt[i] + 1);\t\twhile(pp--) res = res * pri[i];\t&#125;\treturn res;&#125;void dfs(int x,ll now,int fix)&#123;\tif(x &gt; tot)\t\treturn f[now - pw[fix]] += f[now],void();\tll np = cnt[x] * pw[x];\tfor(int i = cnt[x];i &gt;= (x == fix);i--)\t\tdfs(x + 1,now + np,fix),np -= pw[x];&#125;int tp[N];inline void Divide()&#123;\tll tmp = a[n];\tfor(int i = 2;i &lt;= 1e6;i++)\t\tif(tmp % i == 0)\t\t&#123;\t\t\tpri[++tot] = i;\t\t\twhile(tmp % i == 0) tmp /= i,++cnt[tot];\t\t&#125;\tif(tmp &gt; 1e12) return;\tif(tmp &gt; 1) pri[++tot] = tmp,cnt[tot] = 1;\tpw[tot] = 1;\tfor(int i = tot - 1;i &gt;= 0;i--)\t\tpw[i] = pw[i + 1] * (cnt[i + 1] + 1);\tfor(int i = 1;i &lt; n;i++)\t&#123;\t\ttmp = a[i];\t\tfor(int j = 1;j &lt;= tot;j++)\t\t&#123;\t\t\ttp[j] = 0;\t\t\twhile(tmp % pri[j] == 0) ++tp[j],tmp /= pri[j];\t\t\ttp[j] = min(tp[j],cnt[j]);\t\t&#125;\t\tf[calc(tp)]++;\t&#125;\tfor(int i = 1;i &lt;= tot;i++)\t\tdfs(1,0,i);\tfor(int i = 0;i &lt; pw[0];i++)\t\tmp[rev(i)] = (a[n] / rev(i) - 1) + (n - 1) - 2 * f[i];&#125;int main()&#123;\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i],a[i] += a[i - 1];\tDivide();\tcin &gt;&gt; Q;\tfor(int i = 1;i &lt;= Q;i++)\t&#123;\t\tll x;\t\tcin &gt;&gt; x;\t\tif(a[n] % x) &#123;puts(&quot;-1&quot;);continue;&#125;\t\tif(!mp[x])\t\t&#123;\t\t\tint res = 0;\t\t\tfor(int j = 1;j &lt; n;j++) res += (a[j] % x == 0);\t\t\tmp[x] = (a[n] / x - 1) + (n - 1) - 2 * res;\t\t&#125;\t\tcout &lt;&lt; mp[x] &lt;&lt; endl;\t&#125;\treturn 0;&#125;\r\nloj3669 Phone Number\r\n题意：https://loj.ac/p/3669\r\n我当时先思考的前两个包，因为只有两键的状态转移较为简单，只需记录一个\r\n\\(f[i]\\) 便可通过。后来想直接从 \\(f[i]\\) 转移到 \\(f[i + 4]\\)\r\n。发现难以配出简单系数，转移跟你填的那些数关联性较强，然后就不会了。\r\n事实上大力 DP，设状态 \\((i,t_0,t_1,t_2,v_0,v_1,v_2,v_3)\\) 。\\(t_0,t_1,t_2\\) 分别表示第 \\(i,i - 1,i - 2\\) 位你填的是什么字符，\\(v_t\\) 表示前缀 \\([1,i - t]\\)\r\n能否根据题目规则匹配得上。转移枚举下一个字符填什么，比较简单。\r\n但是直接做会有 \\(2^4 \\times 9^3\\)\r\n个状态，过不去的。\r\n发现当 \\(v_3 = 0\\) 时，\\(t_2\\) 已经没有用了（因为 \\(t_2\\) 只会用来帮我们判断 \\([i - 2,i + 1]\\) 能否匹配，从而接上 \\([1,i - 3]\\)，但如果 \\([1,i - 3]\\)\r\n本身就无法匹配，我们也不用做这个判断了），同理，当 \\(v_3 = v_2 = 0\\) 时，\\(t_1\\) 无用，当 \\(v_3 = v_2 = v_1 = 0\\) 时，\\(t_0\\) 也无用了。全为 \\(0\\) 就是不合法状态了。\r\n根据这个进行裁剪，状态数好像只减少了不到一半。\r\n还有一个优化，即若 \\(v_3 =\r\n1\\)，那么对于 \\(t_0,t_1,t_2\\)，如果它们中有一个数不在 \\([i - 2,i + 1]\\)\r\n中，或者它们再加一个数也拼不出正方形，那么 \\(v_3\\) 就没用了，我们可以将其设为 \\(0\\)。对于 \\(v_2,v_1\\) 也可以类似处理。\r\n考虑分析状态数的上界。如果 \\(v_3 =\r\n1\\)，那么 \\(t\\) 的方案就是在\r\n\\([i - 2,i + 1]\\)\r\n种选三个数的方案数，只有 \\(24\\)\r\n种选法，\\(v_{0,1,2}\\) 不确定，一共\r\n\\(8 \\times 24 = 192\\) 状态。如果 \\(v_3 = 0,v_2 = 1\\)，\\(t\\) 就只有 \\(t_0,t_1\\) 有用，且在 \\([i-1,i+2]\\) 中选，一共 \\(12\\) 种，乘上 \\(v_0,v_1\\) 的选法，一共 \\(48\\) 种。如果 \\(v_3 = v_2 = 0,v_1 = 1\\)，就是 \\(8\\) 种状态。\\(v_3\r\n= v_2 = v_1 = 0\\) 就 \\(1\\)\r\n种状态。总状态数有个上界 \\(192 + 48 +8 + 1 =\r\n249\\) 。\r\n据说实际状态大约只有 \\(50\\)\r\n多个。可以用 unordered_map 存状态来进行转移。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5,P = 1e9 + 7;inline void Plus(int &amp;x,const int &amp;y) &#123; x += y;if(x &gt;= P) x -= P;&#125;int n;char s[N];int a[N];bool Can[5][4096];// Can[2] : 相邻// Can[3] : 能否加一个数变成方// Can[4] : 能否方struct State&#123;\tint t0,t1,t2;\tbool v0,v1,v2,v3;\tState()&#123;&#125;\tState(const int _t0,const int _t1,const int _t2 \t\t,const int _v0,const int _v1,const int _v2,const int _v3):\t\tt0(_t0),t1(_t1),t2(_t2),v0(_v0),v1(_v1),v2(_v2),v3(_v3)&#123;&#125;\tbool operator == (const State &amp;rhs) const &#123;\t\treturn t0 == rhs.t0 and t1 == rhs.t1 and t2 == rhs.t2\t\tand v0 == rhs.v0 and v1 == rhs.v1 and v2 == rhs.v2 and v3 == rhs.v3;\t&#125;&#125;;struct Hash&#123;\tstatic const int base = 131;\ttypedef unsigned int uint;\tuint operator ()(const State &amp;x) const \t&#123;\t\tuint res = 0;\t\tres = res * base + x.t0;res = res * base + x.t1;\t\tres = res * base + x.t2;res = res * base + x.v0;\t\tres = res * base + x.v1;res = res * base + x.v2;\t\tres = res * base + x.v3;return res;\t&#125;&#125;;inline State Reduce(int id,const State &amp;x)&#123;\tState res = x;\tif(res.v3 == 0) res.t2 = 10;\tif(res.v3 == 0 &amp;&amp; res.v2 == 0) res.t1 = 10;\tif(res.v3 == 0 &amp;&amp; res.v2 == 0 &amp;&amp; res.v1 == 0) res.t0 = 10;\tint bk[10];memset(bk,0,sizeof bk);\tif(res.v3 == 1)\t&#123;\t\tif(id &gt; 2) bk[a[id - 2]] = 1;\t\tif(id &gt; 1) bk[a[id - 1]] = 1;\t\tbk[a[id]] = 1;\t\tif(id &lt; n) bk[a[id + 1]] = 1;\t\tif(!Can[3][(1 &lt;&lt; res.t0) | (1 &lt;&lt; res.t1) | (1 &lt;&lt; res.t2)])\t\t\tres.v3 = 0;\t\tif(!bk[res.t0] || !bk[res.t1] || !bk[res.t2]) res.v3 = 0;\t&#125;\tif(res.v2 == 1)\t&#123;\t\tmemset(bk,0,sizeof bk);\t\tif(id &gt; 1) bk[a[id - 1]] = 1;\t\tbk[a[id]] = 1;\t\tif(id &lt; n) bk[a[id + 1]] = 1;\t\tif(id &lt; n - 1) bk[a[id + 2]] = 1;\t\tif(!bk[res.t0] || !bk[res.t1]) res.v2 = 0;\t&#125;\tif(res.v1 == 1)\t&#123;\t\tmemset(bk,0,sizeof bk);\t\tbk[a[id]] = 1;\t\tif(id &lt; n) bk[a[id + 1]] = 1;\t\tif(id + 1 &lt; n) bk[a[id + 2]] = 1;\t\tif(id + 2 &lt; n) bk[a[id + 3]] = 1;\t\tif(!bk[res.t0]) res.v1 = 0;\t&#125;\treturn res;&#125;inline State Next(int id,State x,int c)&#123;\tState res;\tres.t2 = x.t1;res.t1 = x.t0;res.t0 = c;\tres.v3 = x.v2;res.v2 = x.v1;res.v1 = x.v0;\tres.v0 = 0;\tif(x.v0 &amp;&amp; res.t0 == a[id + 1]) res.v0 = 1;\tif(x.v1) &#123; \t\tint tv = (1 &lt;&lt; a[id]) | (1 &lt;&lt; a[id + 1]);\t\tif(tv == (1 &lt;&lt; res.t0) + (1 &lt;&lt; res.t1) &amp;&amp; Can[2][tv])\t\t\tres.v0 = 1;\t&#125;\tif(x.v3)\t&#123;\t\tint tv = (1 &lt;&lt; a[id - 2]) | (1 &lt;&lt; a[id - 1]) | (1 &lt;&lt; a[id]) | (1 &lt;&lt; a[id + 1]);\t\tif(tv == (1 &lt;&lt; res.t0) + (1 &lt;&lt; res.t1) + (1 &lt;&lt; res.t2) + (1 &lt;&lt; x.t2) &amp;&amp; Can[4][tv])\t\t\tres.v0 = 1;\t&#125;\treturn res;&#125;unordered_map&lt;State,int,Hash&gt; mp1,mp2;inline void Work()&#123;\tcin &gt;&gt; (s + 1);\tn = strlen(s + 1);\tfor(int i = 1;i &lt;= n;i++) a[i] = s[i] - &#x27;0&#x27;;\tmp1.clear();\tmp1[State(10,10,10,1,0,0,0)] = 1;\tfor(int i = 0;i &lt; n;i++)\t&#123;\t\tmp2.clear();\t\tfor(auto it : mp1)\t\t&#123;\t\t\tState t = it.first;\t\t\tfor(int c = 1;c &lt;= 9;c++)\t\t\t&#123;\t\t\t\tState nxt = Next(i,t,c);\t\t\t\tnxt = Reduce(i + 1,nxt);\t\t\t\tif(nxt.v3 + nxt.v2 + nxt.v1 + nxt.v0 == 0) continue;\t\t\t\tPlus(mp2[nxt],it.second);\t\t\t&#125;\t\t&#125;\t\tmp1 = mp2;\t&#125;\tint ans = 0;\tfor(auto it : mp1)\t\tif(it.first.v0 == 1)\t\t\tPlus(ans,it.second);\tcout &lt;&lt; ans &lt;&lt; endl;&#125;\tint main()&#123;\tfor(int i = 1;i &lt;= 9;i++)\t\tfor(int j = i + 1;j &lt;= 9;j++)\t\t\tif(abs(i - j) == 3 || (abs(i - j) == 1 &amp;&amp; i != 3 &amp;&amp; i != 6))\t\t\t\tCan[2][(1 &lt;&lt; i) | (1 &lt;&lt; j)] = 1;\tCan[4][32 + 16 + 4 + 2] = 1;\tCan[4][64 + 32 + 8 + 4] = 1;\tCan[4][256 + 128 + 32 + 16] = 1;\tCan[4][512 + 256 + 64 + 32] = 1;\tfor(int i = 1;i &lt;= 9;i++)\t\tfor(int j = i + 1;j &lt;= 9;j++)\t\t\tfor(int k = j + 1;k &lt;= 9;k++)\t\t\t\tfor(int p = 1;p &lt;= 9;p++)\t\t\t\t\tCan[3][(1 &lt;&lt; i) | (1 &lt;&lt; j) | (1 &lt;&lt; k)] |= Can[4][(1 &lt;&lt; i) + (1 &lt;&lt; j) + (1 &lt;&lt; k) + (1 &lt;&lt; p)];\tint T;\tcin &gt;&gt; T;\twhile(T--) Work();\treturn 0;&#125;\r\n","tags":["板刷记录"]},{"title":"CF1368E 题解","url":"/posts/3690709470/","content":"比起题解区的神奇构造，我更喜欢@约瑟夫用脑玩\r\n的思维模式，能够推广到更加普适的问题，为图论解题提供启发，我们接下来讲述一下这种做法。\r\n\r\n考虑到这是个 DAG，我们不妨对每个点设一个深度 \\(dp_x\\)，然后强制在删完后的图中，边 \\((x,y)\\) 等价于 \\(dp_y = dp_x + 1\\)，那么原限制等价于，不存在\r\n\\(dp_x \\ge 3\\) 的点。\r\n考察特殊对象是 OI 中的常见手段，我们在这道题中，首先考察入度为 \\(0\\) 的点，那么其深度为 \\(1\\)。\r\n深度为 \\(1\\)\r\n的点指出去的点，要么深度为 \\(2\\)，要么就被删掉。\r\n而深度为 \\(2\\)\r\n的点指出去的点，一定要被删掉。\r\n因为我们要删掉的尽量少，一个点肯定不能随便成为深度为 \\(2\\) 的点。\r\n如果一个点，比它拓扑序小的都确定了，且有深度为 \\(1\\) 的点指向它，那么它就只能是深度为 \\(2\\) 的点。\r\n因为深度为 \\(3\\)\r\n的点等价于被删掉，所以，如果一个点的入边都是深度为 \\(3\\) 的点，它和深度为 \\(1\\) 的点是等效的。\r\n按照上面的规则，按拓扑序更新 \\(dp_x\\) 即可。\r\n设 \\(dp_x = i\\) 的点的个数为 \\(C_i\\)。\r\n因为出度 \\(\\le 2\\)，所以 \\(C_2 \\le 2C_1 ,C_0 \\le 2C_2\\)\r\n容易发现 \\(C_0 \\le\r\n\\dfrac{4n}{7}\\)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n,m;vector&lt;int&gt; G[N];int dep[N],deg[N];queue&lt;int&gt; Q;inline void Work()&#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1;i &lt;= n;i++) dep[i] = deg[i] = 0,G[i].clear();\tfor(int i = 1;i &lt;= m;i++)\t&#123;\t\tint x,y;\t\tcin &gt;&gt; x &gt;&gt; y;\t\tG[x].push_back(y);++deg[y];\t&#125;\tfor(int i = 1;i &lt;= n;i++)\t\tif(!deg[i]) Q.push(i),dep[i] = 1;\t//\telse dep[i] = 1e9;\twhile(!Q.empty()) // dp = -1 表示已经被删除;dp = 0 表示所有入边都是被删的点，我们在入队时会把这种情况置为 1\t&#123;\t\tint x = Q.front();Q.pop();\t\t// printf(&quot;dep[%d]=%d\\n&quot;,x,dep[x]);\t\tfor(auto y : G[x])\t\t&#123;\t\t\t--deg[y];\t\t\tif(dep[x] != -1)\t\t\t&#123;\t\t\t\tif(dep[x] == 1 &amp;&amp; dep[y] != -1) dep[y] = 2;\t\t\t\telse dep[y] = -1;\t\t\t&#125;\t\t\tif(!deg[y]) &#123;Q.push(y); if(dep[y] == 0) dep[y] = 1;&#125;\t\t&#125;\t&#125;\tvector&lt;int&gt; Ans;\tfor(int i = 1;i &lt;= n;i++)\t\tif(dep[i] == -1) Ans.push_back(i);\tprintf(&quot;%lu\\n&quot;,Ans.size());\tfor(auto i : Ans) printf(&quot;%d &quot;,i);\tprintf(&quot;\\n&quot;);&#125;int main()&#123;\tint T;\tcin &gt;&gt; T;\twhile(T--) Work();\treturn 0;&#125;\r\n","tags":["graph theory"]},{"title":"Backward Induction 相关总结","url":"/posts/384412733/","content":"Backward Induction ，译为逆向归纳法，常用于在有向图上做带环的 DP\r\n与博弈，是一个很有用的技巧。 \r\n这种方法常用于，你要对每个点维护一个状态 \\(f_x\\)，而 \\(f_x\\) 由后继 \\(f_y\\) 推得的时候。\r\n直接考虑环并不好做，我们先从简单的情况开始归纳，即 \\(x\\) 没有出边的情况，这一般很简单。\r\n然后对反图做类似拓扑排序 / dijkstra 的 DP，让 \\(y\\) 一步一步更新 \\(x\\)，在队列/堆中存储已经确定的 \\(f_x\\)。\r\n有向图博弈\r\n有向图博弈，有环，那么就肯定存在平局。\r\n要让博弈进行下去，肯定是有一方希望平局，另一方不希望平局。\r\n先 DP 出每个状态是否为平局，再导出每个点的胜负状态即可。\r\nDP\r\n平局较为容易，没有出边肯定不是平局，对于希望平局的一方，后继有平则平，对于不希望平局的一方，后继有不平则不平，记录每个点在原图上的出度\r\n\\(out[x]\\)，在原图上做拓扑排序式的 DP\r\n即可。\r\n怎么导出胜负状态呢？\r\n我们一般会记录 \\(D[x][0/1]\\)，表示\r\n\\(x\\) 为起点，\\(A/B\\)\r\n先手，能到达多少个非平局后继。这样我们就可以在 DP 过程中判别， \\(x\\) 的非平局后继是否都已经被确定。\r\n如果 \\(x\\)\r\n的非平局后继都已经被确定，将其加入队列 /\r\n堆等数据结构，更新其它点即可。\r\n第一道例题\r\n洛谷 P6970\r\nAlice : 先平再赢后输\r\nBob : 先赢再输后平\r\n我们先 DP 出 \\(drw[x][0/1]\\) 表示以\r\n\\(x\\) 为起点，\\(A/B\\) 先手，是否为平局。\r\n讲一下 DP 过程中的细节：\r\n我们一开始将无出度节点的 \\(drw\\)\r\n置为 \\(0\\)，其余点的 \\(drw\\) 均置为 \\(1\\)。\r\n维护一个队列 \\(Q\\)，里面只会存放非平局的状态。\r\n取出队头 \\((x,v \\in \\{0,1\\})\\)，取出\r\n\\(x\\) 的前驱 \\(y\\)。\r\n如果 \\(v = 0\\)，那么对应的，\\(y\\) 那里是 Bob 先手，既然 Bob\r\n不喜欢平局，\\(drw[y][1]\\) 肯定为 \\(False\\)，更新并入队即可。\r\n如果 \\(v = 1\\)，那么对应的，\\(y\\) 那里是 Alice 先手，那得 \\(y\\) 的所有后继均为非平局，\\(drw[y][0]\\) 才是非平局，所以碰到 \\((x,1)\\)，就把 \\(out[y] \\gets out[y] - 1\\)，什么时候减到\r\n\\(0\\) 了，就更新并入队。\r\nfor(int i = 1;i &lt;= n;i++)&#123;\tdeg[i] = out[i];\tif(!deg[i]) Q.emplace(i,0),Q.emplace(i,1);\telse drw[i][0] = drw[i][1] = 1;&#125;while(!Q.empty())&#123;\tint x = Q.front().FI,tp = Q.front().SE; // 队列里只放非平局状态\tQ.pop();\tfor(auto y : Gr[x])        if((tp == 0 &amp;&amp; drw[y][1]) || (tp == 1 &amp;&amp; !--deg[y]))\t \t\tdrw[y][tp ^ 1] = 0,Q.emplace(y,tp ^ 1);&#125;\r\n然后对非平局状态 DP 出胜负即可，这个比较容易。\r\n这题还有一个特殊情况，就是对于一些非平局状态，其在上一轮的 DP\r\n中并没有确定胜负态。\r\n对于 Bob 来说，这体现为该点在某个环上，后继有 Alice\r\n的必胜与平局，在所有已经确定的状态都转移完之后，这些状态没有被转移到（因为在环上有相邻的点是非平局，导致无法进入这个环，因为相邻点的状态始终无法确定）。\r\n那么这些点在环上，但为什么不是平局呢？\r\n只有可能是 Bob 没法赢，但由不想平局，所以选择了输，特判这些点为 Alice\r\n胜 Bob 败即可。\r\nfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tdeg[i] = out[i];\t\tif(!deg[i]) Q.emplace(i,0),Q.emplace(i,1);\t\telse F[i][0] = F[i][1] = -1;\t\tfor(auto v : G[i])\t\t\tD[i][0] += !drw[v][1],D[i][1] += !drw[v][0];\t&#125;\twhile(!Q.empty())\t&#123;\t\tint x = Q.front().FI,tp = Q.front().SE;Q.pop(); // 做出非平局状态的输赢\t\tfor(auto y : Gr[x]) \t\t\tif(!drw[y][tp ^ 1]) // 目标状态非平局\t\t\t&#123;\t\t\t\tif(F[x][tp]) &#123; if(!--D[y][tp ^ 1]) Q.emplace(y,tp ^ 1),F[y][tp ^ 1] = 0;&#125;\t\t\t\telse &#123;if(F[y][tp ^ 1] == -1) Q.emplace(y,tp ^ 1),F[y][tp ^ 1] = 1;&#125;\t\t\t&#125; \t&#125;\tfor(int i = 1;i &lt;= n;i++) // 特判上述情况\t&#123;\t\tif(F[i][0] == -1) F[i][0] = 1;\t\tif(F[i][1] == -1) F[i][1] = 0;\t&#125;\r\n有向图 DP\r\n与有向图博弈的流程大同小异，先考虑没有出度的点，再使用类似 Dijkstra\r\n的方式维护转移即可。\r\n第一道例题\r\nAtCoder\r\nBeginning Contest 261 H\r\n这道题是个博弈与 DP 结合的题，放在这里比较合适。\r\n容易发现，Aoki 当然会尽量促成 \"INFINITY\"。\r\n设 \\(F[x][0/1]\\) 表示以 \\(x\\) 为起点，Takahashi/Aoki\r\n先手的最终得分，初始时 \\(F[x][0] =\r\n\\infty,F[x][1] = 0\\)。\r\n对于没有出度的点，\\(F[x][0] = F[x][1] =\r\n0\\)，将其加入堆。\r\n有转移： \\[\r\n\\begin{cases}\r\nf_{x,0} \\gets \\min_{(x,y,w) \\in E}f_{y,1} + w \\\\\r\nf_{x,1} \\gets \\max_{(x,y,w) \\in E}f_{y,0} + w \\\\\r\n\\end{cases}\r\n\\] 事实上，我们可以直接把平局的情况并入上述的转移。\r\n如果有一个 \\(f_{y,1}\\) 有值，那么\r\n\\(f_{x,0}\\) 就肯定有值。\r\n如果所有的 \\(f_{y,0}\\) 有值，那么\r\n\\(f_{x,1}\\) 才会有值。\r\n上述的有值就是不为 \\(\\infty\\)\r\n的情况。\r\n以上述规则转移即可。\r\n在这里，我们维护可用状态用的是小根堆，这与 dijkstra\r\n是本质相同的，我们只会从小的 DP 值转移到大的 DP\r\n值，什么时候一个状态从堆中被弹出了，那它就已经确定了，因为比它小的 DP\r\n值已经都被弹出，所有能更新它的转移都已经做完了。\r\n如果还使用队列的话，那么这就与 SPFA\r\n本质相同，你就无法在每个状态第一次出队时确定它，而是需要若干次松弛，直到状态收敛，这样就无法保证复杂度了。\r\n#include &lt;bits/stdc++.h&gt;#define FI first#define SE secondusing namespace std;typedef long long ll;const int N = 2e5 + 5;int n,m,s;vector&lt;pair&lt;int,int&gt; &gt; G[N],Gr[N];ll f[N][2];int out[N][2];struct node&#123;\tint x,tp;\tll val;\tnode()&#123;&#125;\tnode(const int _x,const int _tp,const ll _val):\t\tx(_x),tp(_tp),val(_val)&#123;&#125;\tbool operator &lt; (const node &amp;rhs) const &#123; return val &gt; rhs.val;&#125;&#125;;priority_queue&lt;node&gt; Q;int deg[N][2];int vst[N][2];inline void Dijk()&#123;\twhile(!Q.empty())\t&#123;\t\tint x = Q.top().x,tp = Q.top().tp;\t\t// if(Q.top().val != f[x][tp]) &#123; Q.pop();continue;&#125;\t\tQ.pop();\t\tif(vst[x][tp]) continue;\t\tvst[x][tp] = true;\t\tfor(auto it : Gr[x])\t\t&#123;\t\t\tint y = it.FI,w = it.SE;\t\t\tif(tp == 0) f[y][1] = max(f[y][1],f[x][0] + w);\t\t\tif(tp == 1) f[y][0] = min(f[y][0],f[x][1] + w);\t\t\tdeg[y][tp ^ 1]--;\t\t\tif(!deg[y][tp ^ 1]) Q.push(node(y,tp ^ 1,f[y][tp ^ 1]));\t\t\telse if(tp == 1) Q.push(node(y,0,f[y][0])); // 对于先手而言，只要一个转移边有值就可以更新\t\t&#125;\t&#125;&#125;int main()&#123;\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\tfor(int i = 1;i &lt;= m;i++)\t&#123;\t\tint a,b,c;\t\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\t\tGr[b].emplace_back(a,c);\t\t++deg[a][0];++deg[a][1];\t&#125;\tfor(int i = 1;i &lt;= n;i++)\t\tf[i][0] = 9e18;\tfor(int i = 1;i &lt;= n;i++)\t\tif(!deg[i][0])\t\t&#123;\t\t\tQ.push(node(i,0,f[i][0] = 0));\t\t\tQ.push(node(i,1,f[i][1] = 0));\t\t&#125;\tDijk();\tif(!vst[s][0]) puts(&quot;INFINITY&quot;);\telse cout &lt;&lt; f[s][0] &lt;&lt; endl;\treturn 0;&#125;\r\n当然，也是可以先按照上文的方法 DP\r\n出每个状态是否平局，然后用优先队列转移非平局状态。\r\n第二道例题\r\n洛谷 P4042\r\n这题，令 \\(dp_i\\) 表示消灭 \\(i\\) 号怪兽的最小代价，那么有 \\[\r\ndp_i = \\min(K_i,S_i + \\sum_{(i,j) \\in E} dp_j)\r\n\\]\r\n因为这题每个状态都最终会有个确定的值，并不需要像上一题一样加入特殊的转移规则，转移比较普通。\r\n也是因此，我们可以等到每个点的后继均被确定，再将其入队，事实上，这样每个点只会被入队一次。\r\n因为不确定要让哪些点的 DP 值取到 \\(K_i\\)，我们一开始将所有 \\((i,K_i)\\) 入队即可。\r\n每个点算上最开始的一次入堆，最多被入堆两次，时间复杂度为 \\(\\Theta(n \\log n + m)\\)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5,M = 1e6 + 5;typedef long long ll;int n,R[N];ll S[N],K[N];vector&lt;int&gt; G[N];ll dp[N];struct node&#123;\tint id;ll val;\tnode()&#123;&#125;\tnode(const int _id,const ll _val):id(_id),val(_val)&#123;&#125;\tbool operator &lt; (const node &amp;rhs) const &#123; return val &gt; rhs.val;&#125;&#125;;priority_queue&lt;node&gt; Q;int vst[N];ll ans[N];int main()&#123;\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tcin &gt;&gt; S[i] &gt;&gt; K[i];\t\tint k;\t\tcin &gt;&gt; k;R[i] = k;\t\tfor(int j = 1,x;j &lt;= k;j++)\t\t\tcin &gt;&gt; x,G[x].push_back(i);\t&#125;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tdp[i] = S[i]; // 维护 S[i] + \\sum dp_j\t\tQ.push(node(i,K[i]));\t&#125;\twhile(!Q.empty())\t&#123;\t\tint x = Q.top().id;\t\tll val = Q.top().val;\t\tQ.pop();\t\tif(vst[x]) continue;\t\tvst[x] = true;ans[x] = val;\t\tfor(auto y : G[x])\t\t&#123;\t\t\tif(vst[y] || dp[y] &gt; K[y]) continue;\t\t\tR[y]--;dp[y] += val;\t\t\tif(!R[y]) Q.push(node(y,dp[y]));\t\t&#125;\t&#125;\tcout &lt;&lt; ans[1] &lt;&lt; endl;\treturn 0;&#125;\r\n这种在有向图上的 DP 有一个共性：由小的 DP 值转移到大的 DP\r\n值，所以用小根堆维护当前可用的状态即可。\r\n这与 dijkstra\r\n的正确性是本质相同的，事实上，最短路问题也可以看作在有环图上的最优化\r\nDP。\r\n第三道例题\r\n[CCO2021] Travelling\r\nMerchant\r\n设 \\(f_x\\) 表示从 \\(x\\)\r\n出发，至少需要多少资产可以一直走下去，可以写一个转移： \\(f_x \\gets \\min_{(x,y,r,p) \\in E}\\max(r,f_y -\r\np)\\)。\r\n还是考虑没有出度的点，显然 \\(f_x\\)\r\n为 \\(\\infty\\)，答案为 \\(-1\\)。\r\n如果不断删去出度为 \\(0\\)\r\n的点，最后剩下的点一定是有答案的（即在环上的点）\r\n读者从前面的题可以发现，对于这种有环的\r\nDP,我们可以考察答案的界，来看看答案会收敛成什么样子。\r\n我们考虑这些点的答案上界。\r\n显然，取出当前最大的 \\(r\\)，那么如果你初始有 \\(r\\)\r\n的资产，那就可以通行全图，因为资产不会减少。\r\n取出这条边的起点 \\(u\\)，并将 \\(f_u\\) 对 \\(r\\) 取 \\(\\min\\)，再删掉这条边。\r\n如果删完之后这条边已经没有出边了，说明 \\(f_x\\)\r\n已经确定，可以拿来更新其它的点，将其放入一个队列。\r\n跑类似上文的 DP\r\n即可，一边松弛答案，一边观察目标点的后继是否全被删空，要注意，给每条边打个标记，使得每条边只被删一次。\r\n在寻常的 Backward DP\r\n中，打标记并不是必要的，一来每个状态入队不一定只有一次（比如上一道题），二来不打标记也只会对常数造成影响。\r\n但是这道题中，我们要一边找当前 \\(r\\)\r\n最大的边，一边去做 Backward DP 来更新 \\(f\\)\r\n数组，为了让这两个过程不重复统计，我们对每条边打了个删除标记。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int n,m;struct Edge&#123;\tint a,b,r,p;\tEdge()&#123;&#125;\tEdge(const int _a,const int _b,const int _r,const int _p):\t\ta(_a),b(_b),r(_r),p(_p)&#123;&#125;\tbool operator &lt; (const Edge &amp;rhs) const &#123; return r &gt; rhs.r;&#125;&#125;;Edge p[N];vector&lt;int&gt; G[N];queue&lt;int&gt; Q;bool vst[N];int out[N];int ans[N];int main()&#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1;i &lt;= m;i++)\t\tcin &gt;&gt; p[i].a &gt;&gt; p[i].b &gt;&gt; p[i].r &gt;&gt; p[i].p;\tsort(p + 1,p + m + 1);\tfor(int i = 1;i &lt;= m;i++)\t\tG[p[i].b].push_back(i);\tfor(int i = 1;i &lt;= m;i++)\t\t++out[p[i].a];\tfor(int i = 1;i &lt;= n;i++)\t\tans[i] = 2e9;\tfor(int i = 1;i &lt;= n;i++)\t\tif(!out[i]) Q.push(i);\tfor(int i = 1;i &lt;= m;i++)\t&#123;\t\twhile(!Q.empty())\t\t&#123;\t\t\tint x = Q.front();Q.pop();\t\t\tfor(auto id : G[x])\t\t\t&#123;\t\t\t\tif(vst[id]) continue;\t\t\t\tint y = p[id].a;\t\t\t\tvst[id] = true;\t\t\t\t--out[y];\t\t\t\tif(ans[x] &lt; 2e9) ans[y] = min(ans[y],max(p[id].r,ans[x] - p[id].p));\t\t\t\tif(!out[y])\t\t\t\t\t\tQ.push(y);\t\t\t\t\t\t\t&#125;\t\t&#125;\t\tif(vst[i]) continue;\t\tans[p[i].a] = min(ans[p[i].a],p[i].r);\t\tvst[i] = true;\t\t--out[p[i].a];\t\tif(!out[p[i].a]) Q.push(p[i].a);\t&#125;\tfor(int i = 1;i &lt;= n;i++)\t\tif(ans[i] &gt;= 2e9) printf(&quot;-1 &quot;);\t\telse printf(&quot;%d &quot;,ans[i]);\tprintf(&quot;\\n&quot;);\treturn 0;&#125;\r\n","tags":["graph theory"]},{"title":"ARC118E 题解","url":"/posts/1021998316/","content":"这题，我和王队一共看了一个小时，王队一句话让我突然想到了状态和相关的转移，然后花了半天把它写完。事实上我们都想到了这题的大部分解法。\r\n\r\n如果排列确定了，很容易有个 \\(\\Theta(n^2)\\) 的 DP,设 \\(dp[i][j]\\) 表示当前走到点 \\((i,j)\\) 的方案数，转移不再赘述。\r\n现在排列不确定了，我们枚举排列去计数路径是十分困难的，那反过来考虑，考察一条路径能贡献多少个排列。\r\n那现在假设路径确定了，我们要绕开这条路径来填充排列。\r\n“所有点都不经过”是十分困难的，我们可以钦定 有 \\(t\\) 个点被经过，容斥系数为 \\((-1)^t\\)。\r\n需要注意的是，对于已经确定的 \\(p_i\\)，其带来的限制是 \"第 \\(i\\) 行和第 \\(p_i\\) 列不能再有障碍被钦定\" 且 ”\\((i,p_i)\\) 不能被经过“，换言之，我们所“钦定”\r\n的，都是那些 \\(p_i = -1\\)\r\n的位置，对于已经确定的 \\(p_i\\)，我们只是把它当成一个确定的障碍，不将其纳入容斥的部分。\r\n设一共有 \\(m\\) 个位置满足 \\(p_i = -1\\)。\r\n那么就容易设出状态 \\(dp[i][j][k][0/1][0/1]\\) 表示当前走到了\r\n\\((i,j)\\) ，一共钦定了 \\(k\\) 个障碍的方案数之和。（后面两个 \\(0/1\\) 表示第 \\(i\\) 行与第 \\(j\\) 列是否已经被钦定过了障碍。\r\n那么分类讨论 \\((i,j)\\)\r\n处钦定障碍或不钦定障碍转移即可。\r\n最后的答案是 \\(\\sum_{i=0}^m dp[n + 1][n +\r\n1][i][0][0] (m - i)!\\)。\r\n上文中 \\((-1)^t\\) 的容斥系数在 DP\r\n转移中顺带处理了。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e2 + 5,P = 998244353;inline void Plus(int &amp;x,const int &amp;y) &#123; x += y;if(x &gt;= P) x -= P;&#125;int f[N][N][N][4];int n,p[N],fac[N],num = 0,vst[N];int main()&#123;\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++) \t\tcin &gt;&gt; p[i],num += p[i] == -1;\tfor(int i = 1;i &lt;= n;i++)\t\tif(p[i] != -1) vst[p[i]] = true;\tp[n + 1] = -1;\tfor(int i = 0;i &lt;= n + 1;i++)\t\tf[0][i][0][0] = f[i][0][0][0] = 1;\tfor(int i = 1;i &lt;= n + 1;i++)\t\tfor(int j = 1;j &lt;= n + 1;j++)\t\t\tfor(int k = 0;k &lt;= min(i,j);k++)\t\t\t&#123;\t\t\t\tif(p[i] != j) // (i,j) 不放障碍\t\t\t\t&#123;\t\t\t\t\tPlus(f[i][j][k][1],f[i - 1][j][k][1]);\t\t\t\t\tPlus(f[i][j][k][1],f[i - 1][j][k][3]);\t\t\t\t\tPlus(f[i][j][k][2],f[i][j - 1][k][2]);\t\t\t\t\tPlus(f[i][j][k][2],f[i][j - 1][k][3]);\t\t\t\t\tPlus(f[i][j][k][0],f[i - 1][j][k][0]);\t\t\t\t\tPlus(f[i][j][k][0],f[i - 1][j][k][2]);\t\t\t\t\tPlus(f[i][j][k][0],f[i][j - 1][k][0]);\t\t\t\t\tPlus(f[i][j][k][0],f[i][j - 1][k][1]);\t\t\t\t&#125;\t\t\t\t\tif((p[i] == -1) &amp;&amp; !vst[j] &amp;&amp; k) //(i,j) 放障碍\t\t\t\t&#123;\t\t\t\t\tPlus(f[i][j][k][3],P - f[i - 1][j][k - 1][0]);\t\t\t\t\tPlus(f[i][j][k][3],P - f[i - 1][j][k - 1][2]);\t\t\t\t\tPlus(f[i][j][k][3],P - f[i][j - 1][k - 1][0]);\t\t\t\t\tPlus(f[i][j][k][3],P - f[i][j - 1][k - 1][1]);\t\t\t\t&#125;\t\t\t&#125;\tfac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tint ans = 0;\tfor(int k = 0;k &lt;= num;k++)\t&#123;\t\tint res = f[n + 1][n + 1][k][0];\t\tPlus(ans,1ll * res * fac[num - k] % P);\t&#125;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n总的来说，这是道计数练手好题。\r\n","tags":["counting","inclusion-exclusion"]},{"title":"CF704B 题解","url":"/posts/606539281/","content":"这是道充分体现了水淹笛卡尔树这个模型的应用的好题。\r\n类似题目：洛谷 P5999，ARC117E\r\n\r\n观察这题的权值函数，与排列的相邻元素有关，与元素的大小关系有关。\r\n而笛卡尔树，它的中序遍历记录了位置相关信息，它的拓扑序记录了权值相关信息。\r\n而水淹笛卡尔树，就是一类在笛卡尔树上按层/权值 DP 的思路。\r\n往往我们并不需要显式地说明笛卡尔树的构型，也有些时候，这类题目可以不用笛卡尔树来理解。\r\n既然是按权值 DP ，我们考虑从小到大插入每个数 \\(i\\)。\r\n在 \\(i\\)\r\n之前，已经插入的数会形成若干个连续段，这些数的贡献是已经计算了的，我们只需知道\r\n\\(i\\) 与两侧数的大小关系，即可计算\r\n\\(i\\) 的贡献。\r\n在写方程之前，重写一下题目所给的量：\\(a_i\r\n\\gets a_i + x_i,b_i \\gets b_i - x_i,c_i \\gets c_i + x_i,d_i \\gets d_i -\r\nx_i\\)。\r\n那么 \\[f(i,j) = \\begin{cases} c_i + b_j ,i\r\n&gt; j \\\\ d_i + a_j,i &lt; j \\\\ \\end{cases}\\]\r\n考察 \\(i\\) 的转移：\r\n先考虑 \\(i \\ne s,t\\) 的情况：\r\n\r\n\\(i\\) 把已有的两段接起来，在\r\n\\(j &gt; 1\\) 时转移，显然 \\(i\\) 两侧的数小于 \\(i\\)，那么 \\(i\\) 的贡献就是 \\(a_i + c_i\\)，则有转移 \\(f_{i,j-1} \\gets f_{i-1,j} + a_i +\r\nc_i\\)。\r\n\\(i\\)\r\n新开一段，那么它周围的两个数都大于它，在 \\(j =\r\n1\\) 且 \\(i &gt; s,t\\)\r\n时无法转移：\r\n\\(f_{i,j+1} \\gets f_{i-1,j} + b_i +\r\nd_i\\)。\r\n\\(i\\) 接在某一段的左边，在 \\(j = 1\\) 且 \\(i\r\n&gt; s\\) 时无法转移：\r\n\\(f_{i,j} \\gets f_{i-1,j} + c_i +\r\nb_i\\)。\r\n\\(i\\) 接在某一段的右边，在 \\(j = 1\\) 且 \\(i\r\n&gt; e\\) 时无法转移：\r\n\\(f_{i,j} \\gets f_{i-1,j} + a_i +\r\nd_i\\)。\r\n\r\n在 \\(i = s\\) 或 \\(i = t\\)\r\n时，新开一段或接在某一段边上即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e3 + 5;typedef long long ll;template&lt;typename T&gt; inline void ckmin(T &amp;x,const T &amp;y) &#123; if(x &gt; y) x = y;&#125;ll f[2][N];int n,s,t;int X[N],a[N],b[N],c[N],d[N];int main()&#123;\tcin &gt;&gt; n &gt;&gt; s &gt;&gt; t;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; X[i];\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i],a[i] += X[i];\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; b[i],b[i] -= X[i];\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; c[i],c[i] += X[i];\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; d[i],d[i] -= X[i];\tmemset(f,0x3f,sizeof f);\tf[0][0] = 0;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tmemset(f[i&amp;1],0x3f,sizeof f[i&amp;1]);\t\tif(i != s &amp;&amp; i != t)\t\t\tfor(int j = 0;j &lt; i;j++)\t\t\t&#123;\t\t\t\tll val = f[(i-1)&amp;1][j];\t\t\t\tif((i &lt; max(s,t)) || j &gt; 1) ckmin(f[i&amp;1][j + 1],val + b[i] + d[i]); // 新开一段\t\t\t\tif(j &gt; 1) ckmin(f[i&amp;1][j - 1],val + a[i] + c[i]);\t\t\t\tif(j &gt; 0 &amp;&amp; (j &gt; 1 || i &lt; s)) ckmin(f[i&amp;1][j],val + c[i] + b[i]);\t\t\t\tif(j &gt; 0 &amp;&amp; (j &gt; 1 || i &lt; t)) ckmin(f[i&amp;1][j],val + a[i] + d[i]);\t\t\t&#125;\t\tif(i == s)\t\t\tfor(int j = 0;j &lt; i;j++)\t\t\t&#123;\t\t\t\tll val = f[(i-1)&amp;1][j];\t\t\t\t// 新开一段或贴在左边\t\t\t\tckmin(f[i&amp;1][j+1],val + d[i]);\t\t\t\tif(j &gt; 0) ckmin(f[i&amp;1][j],val + c[i]);\t\t\t&#125;\t\tif(i == t)\t\t\tfor(int j = 0;j &lt; i;j++)\t\t\t&#123;\t\t\t\tll val = f[(i-1)&amp;1][j];\t\t\t\tckmin(f[i&amp;1][j+1],val + b[i]);\t\t\t\tif(j &gt; 0) ckmin(f[i&amp;1][j],val + a[i]);\t\t\t&#125;\t&#125;\tcout &lt;&lt; f[n&amp;1][1] &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["DP"]},{"title":"一种最长反链的构造方法","url":"/posts/4267914291/","content":"下文简述在偏序集上构造最长反链的一种方法。\r\n\r\n（实际上就是从 [CTSC2008] 祭祀 的题解区抄来的）。\r\n首先，根据 Dilworth 定理，最长反链等于最小不可重链覆盖。\r\n求最小链覆盖有个经典的拆点二分图做法，就是把每个点拆成两个点 \\(x_{in},x_{out}\\)。然后对于原图的边 \\((x,y)\\)，连边 \\((x_{out},y_{in})\\)。然后跑二分图最大匹配，一个关于\r\n\\(in\\)\r\n点的匹配相当于给一个点找前驱，一个关于 \\(out\\) 点的匹配相当于给一个点找后继。\r\n那么最小链覆盖就是 \\(n\\) -\r\n拆点二分图的最大匹配。\r\n接下来，我们尝试从这个匹配中，构造出最长反链。\r\n我们先构造二分图最大独立集。\r\n首先引入最小点覆盖：选出一个最小的点集，使得每条边的两端都有至少一个点被选中。\r\n因为二分图最大独立集等于最小点覆盖的补（因为最小点覆盖不会出现一条边两端都没有点，等价于最大独立集中不会出现一条边两端都有点），这等价于构造最小点覆盖。\r\n而最小点覆盖等于最大匹配。\r\n因为最小点覆盖肯定大于等于最大匹配（匹配边的两端必须至少选一个点），我们接下来给出一种点覆盖使得其大小等于最大匹配。\r\n考虑从右侧的每个非匹配点开始\r\nDFS，右部点只能走非匹配边向左访问，左部点只能走匹配边向右访问。\r\n我们取出左侧被 DFS 到的点和右侧没被 DFS\r\n到的点，就构成了一个点覆盖。\r\n下文证明这是一个合法点覆盖，且大小等于最大匹配：\r\n\r\n合法性\r\n对于右侧被 DFS 到的所有点，与其相邻的左侧点肯定也被 DFS\r\n到了，这个可以根据这个右部点是否有匹配来讨论证明。\r\n我们取出的是左侧被搜到的和右侧没被搜到的，基于上述事实，每条边都会被覆盖。\r\n大小等于最大匹配\r\n因为右侧的非匹配点肯定都被搜到了，在右侧选取的一定是匹配点。\r\n如果一个右侧的匹配点被搜到了，那与其匹配的左部点肯定也被搜到了，那么它的匹配点就会被选上。\r\n上述两个事实表明：每条匹配边的端点恰好选一个。\r\n而左侧的非匹配点肯定不会被搜到，因为如果被搜到了，在 DFS\r\n的过程中就会形成一条增广路，与最大匹配矛盾。\r\n\r\n我们取最小点覆盖的补就得到了最大独立集。也就是左侧没被 DFS\r\n到的点和右侧被 DFS 到的点。\r\n然后考虑怎么求出最长反链。\r\n我们对于原图所有点 \\(x\\)，取出 \\(x_{in}\\) 与 \\(x_{out}\\)\r\n都在二分图独立集的点，就得到了最长反链。\r\n显然这是一个合法的反链，大小也与 Dilworth 指出的结果相符。\r\n先记下来，以后应该用得上。\r\n","tags":["graph matching"]},{"title":"CF1782F Bracket Insertion 题解","url":"/posts/2615667224/","content":"打的时候在错误的思路上卡了半个小时，以至于最后 10\r\n分钟想到了正解，但已经没时间写了。\r\n赛后把这题改过了，比改错了还难受。\r\n\r\n考虑最终形成的序列满足什么条件。\r\n我们不妨把第 \\(i\\)\r\n次插入的两个字符编号为 \\(i\\)。\r\n那么会形成 \\(1 2 2 1 3 3\\)\r\n之类的结构，但一定不会有 \\(1 2 1\r\n2\\)（交错），也不会有 \\(3 2 2\r\n3\\) (大包小）\r\n这其实是一个类似树的结构，跟括号树其实长得差不多，我们如果按包含关系建树（在上述例子中，\\(2\\) 就是 \\(1\\) 的儿子，如果有 \\(1 2332441\\) 那 \\(2,4\\) 就是 \\(1\\)\r\n的儿子），那么问题实际上被分成两部分：\r\n\r\ndp 这棵树以及节点上的状态，使得最终的括号串合法。\r\n处理插入顺序，使得父亲比儿子先插入。\r\n\r\n第二部分就是一个树的拓扑序，处理是容易的，下文再讲。\r\n考虑第一部分。\r\n这种对有包含关系区间 的\r\nDP（或者说对类似这种“括号树”的 DP),其实就是区间 \\(DP\\) ，如果区间 \\([l,r]\\) 是一个节点，我们枚举断点 \\(k\\)\r\n相当于枚举这个节点最靠左的儿子。而在本题中，我们其实只要记录区间长度（或者说区间内有几对括号）即可。\r\n有个经典结论是，把 ( 看作 1,把 ) 看作\r\n-1,那么一个括号串能够匹配，当且仅当这个串的所有前缀和都非负且左右括号数目相等。\r\n那我们不妨把这个前缀和的最小值记录进 \\(DP\\) 状态，容易发现这个值 \\(\\le 0\\)。\r\n设 \\(f[i][s]\\) 表示序列长度为 \\(i\\)，最小前缀和为 \\(-s\\) 的方案数（另一种解释是在序列两边添加\r\n\\(s\\) 对括号才能使其合法）\r\n，那么会有转移。\r\n$$\r\n\\[\\begin{cases}\r\nf[i][max(s1 - 1,0,s2)] \\gets \\sum_{k=0}^{i-1}f[k][s1] \\times f[i - k -\r\n1][s2] \\times pro \\times \\binom{i}{k + 1} \\\\\r\n\r\nf[i][max(s1 + 1,0,s2)] \\gets \\sum_{k=0}^{i-1} f[k][s1] \\times f[i - k -\r\n1][s2] \\times (1 - pro) \\times \\binom{i}{k+1}\r\n\\end{cases}\\]\r\n$$\r\n上文的 \\(pro\\) 是题目中的 \\(p\\)，\\(k\\)\r\n相当于枚举跟 \\(l\\)\r\n一起被插入的是哪个位置，相当于枚举树上最靠左的儿子，而组合数是为了安排插入的顺序。\r\n直接实现上述转移是 \\(\\Theta(n^4)\\)\r\n的，注意到问题可以被转化成 \\(h[max(x,y)] \\gets\r\nf[x] * g[y]\\) 这种形式，使用前缀和优化，分类讨论 \\(x &lt; y\\) 和 \\(x\r\n\\ge y\\) 转移即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e2 + 5,P = 998244353;inline int qpow(int a,int b) &#123; int res = 1;while(b) &#123;if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;&#125; return res;&#125;inline void Plus(int &amp;a,const int &amp;b) &#123; a += b;if(a &gt;= P) a -= P;&#125;int n,pro;int f[N][N];int fac[N],ifac[N];inline void init(int n)&#123;\tfac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tifac[1] = 1;\tfor(int i = 2;i &lt;= n;i++) ifac[i] = 1ll * (P - P / i) * ifac[P % i] % P;\tifac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) ifac[i] = 1ll * ifac[i - 1] * ifac[i] % P;&#125;inline int C(int n,int m) &#123; return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;&#125;int g[N],h[N];int main()&#123;\tcin &gt;&gt; n &gt;&gt; pro;\tinit(n);\tpro = 1ll * pro * qpow(10000,P - 2) % P;\tf[0][0] = 1;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tfor(int k = 0;k &lt; i;k++)\t\t&#123;\t\t\tint r = i - k - 1;\t\t\tmemset(g,0,sizeof g);\t\t\tmemset(h,0,sizeof h);\t\t\tfor(int s1 = 0;s1 &lt;= k;s1++)\t\t\t\tPlus(g[max(s1 - 1,0)],1ll * f[k][s1] * C(i,k + 1) % P * pro % P),\t\t\t\tPlus(g[s1 + 1],1ll * f[k][s1] * C(i,k + 1) % P * (P + 1 - pro) % P);\t\t\tfor(int s2 = 0;s2 &lt;= r;s2++)\t\t\t\th[s2] = f[r][s2];\t\t\tfor(int s1 = 1;s1 &lt;= i;s1++)\t\t\t\tPlus(g[s1],g[s1 - 1]);\t\t\tfor(int s2 = 1;s2 &lt;= i;s2++)\t\t\t\tPlus(h[s2],h[s2 - 1]);\t\t\tfor(int v = 0;v &lt;= i;v++)\t\t\t&#123;\t\t\t\tint res = 1ll * g[v] * f[r][v] % P;\t\t\t\tif(v &gt; 0) Plus(res,1ll * (g[v] - g[v - 1] + P) % P * h[v - 1] % P);\t\t\t\tPlus(f[i][v],res);\t\t\t&#125;\t\t&#125;\t&#125;\tint ans = f[n][0];\tfor(int i = 3;i &lt; 2 * n;i += 2)\t\tans = 1ll * ans * qpow(i,P - 2) % P;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n其实不是很难的一道题。可以用来练习计数，提升竞技状态。\r\n但这场 E 好垃圾啊（\r\n","tags":["counting"]},{"title":"CF1792F2 题解（以及一种分治 FFT）","url":"/posts/1707382016/","content":"这题推出平方的转移式不难，但是进一步优化需要技巧。\r\n\r\n首先把 ”不全红“ 和”不全蓝“的限制去掉。\r\n其次，对于一个完全图，它如果不 红边连通，蓝边连通。\r\n这个证明是容易的，假设一个完全图有两个点集 \\(A,B\\)，\\(A\\) 与 \\(B\\) 之间没有红边，那么对于任意 \\(a \\in A\\)，\\(b\r\n\\in B\\)，\\((a,b)\\)\r\n之间都会有一条蓝边，那么这个图显然会被蓝边连通。\r\n那我们只需要保证红蓝不同时连通即可。\r\n设 \\(f_n\\) 表示一个 \\(n\\) 个点的完全图由红边连通的方案数，那么\r\n\\(ans = 2f_n - 2\\)。\r\n考虑转移，既然这张图蓝边不连通，那么我们枚举 \\(1\\) 号点所在的蓝边连通块大小，设为 \\(i\\)，那么会有 \\(\\binom{n - 1}{i-1}\\)\r\n种方案选出这个连通块，块内的方案数是 \\(f_i\\)，块外的方案数是 \\(f_{n-i}\\)\r\n，块内与块外之间的边必须都是红边，故系数为 \\(1\\)。另外，如果 \\(n - i &gt; 1\\)，方案数还要乘 \\(2\\)，因为块外的图既可以红连通，也可以蓝连通。\r\n直接转移即可通过 F1。\r\n考虑优化转移的复杂度，把转移式写出来。 \\[\r\nf_i = 2\\sum_{j=1}^{i-2} \\binom{i-1}{j-1}f_jf_{i-j} +\r\nf_1f_{i-1}\\binom{i-1}{i-2} \\\\\r\n\\] 写得好看一些： \\[\r\nf_i = 2\\sum_{j=1}^{i-1} \\binom{i-1}{j-1}f_jf_{i-j} - (i -1)f_{i-1}\r\n\\] 令 \\[\r\nf&#39;_i = \\sum_{j=1}^{i-1} \\binom{i-1}{j-1}f_jf_{i-j}\r\n\\] 那么 \\(f_i = 2f&#39;_i - (i -\r\n1)f_{i-1}\\)。\r\n把组合数拆开： \\[\r\n\\dfrac{f&#39;_i}{(i-1)!} = \\sum_{j=1}^{i-1}\r\n\\dfrac{f_j}{(j-1)!}\\dfrac{f_{i-j}}{(i-j)!}\r\n\\] 设 \\(F_i = \\dfrac{f_i}{(i-1)!},G_i =\r\n\\dfrac{f_i}{i!}\\)。\r\n那么 \\(f&#39;_i =\r\n\\sum_{j=1}^{i-1}F_jG_{i-j}\\)\r\n这看上去就像分治 FFT 的式子，但我们发现 \\(F\\) 和 \\(G\\) 都需要由卷积的结果推出，而一般的分治\r\nFFT 中，\\(G\\)\r\n这个位置放的是个已知序列。\r\n考虑一般的分治 FFT,我们是用 \\(F_{[l,mid]}\\) 与 \\(G_{[1,r-l]}\\)\r\n进行卷积，并将结果加到右区间对应的位置。\r\n考虑这个方法什么时候会出问题，这种情况会出现当且仅当 \\(r - l &gt; mid\\) ，即 \\(2r - 2l &gt; l + r\\)，即 \\(r &gt; 3l\\)。\r\n这种情况只会在 \\(l = 1\\)\r\n时出现，因为在分治树上第一次往右走时，就有 \\(r\r\n&lt; 2l\\)，此后 \\(l\\)\r\n不降，\\(r\\)\r\n不增，自然也不会出问题。\r\n考虑把分治 FFT 的贡献拆成三部分： \\[\r\n\\sum_{j=i-mid}^{mid} F_jG_{i-j} + \\sum_{j=mid+1}^{i-1}F_jG_{i-j} +\r\n\\sum_{j=1}^{i-mid-1}F_jG_{i-j}\r\n\\] 第一部分的贡献可以在 \\([1,r]\\)\r\n那里就算完了，第二部分和第三部分的贡献形式是相同的，可以在 \\(l \\ne 1\\) 的区间里一起计算这两类贡献。\r\n具体的可以看代码，时间复杂度 \\(\\Theta(n\r\n\\log ^2n)\\)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5,P = 998244353,GG = 3;inline int Add(const int &amp;a,const int &amp;b) &#123; return (a + b &gt;= P) ? (a + b - P) : (a + b);&#125;inline int Sub(const int &amp;a,const int &amp;b) &#123; return (a &lt; b) ? (a - b + P) : (a - b);&#125;inline int qpow(int a,int b) &#123; int res = 1;while(b) &#123;if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;&#125; return res;&#125;const int Gi = qpow(GG,P - 2);int n;int Gs[N],Gs2[N],rev[N];inline int GetLen(int x)&#123;\tint len = 1;\twhile(len &lt;= x) len &lt;&lt;= 1;\treturn len;&#125;inline void calc_rev(int len)&#123;\tfor(int i = 0;i &lt; len;i++)\t&#123;\t\trev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1;\t\tif(i &amp; 1) rev[i] |= len &gt;&gt; 1;\t&#125;&#125;int fac[N],ifac[N];inline void init(int len)&#123;\tfor(int i = 1;i &lt; len;i &lt;&lt;= 1)\t&#123;\t\tGs[i] = Gs2[i] = 1;\t\tGs[i + 1] = qpow(GG,(P - 1) / (i &lt;&lt; 1));\t\tGs2[i + 1] = qpow(Gi,(P - 1) / (i &lt;&lt; 1));\t\tfor(int j = 2;j &lt; i;j++)\t\t\tGs[i + j] = 1ll * Gs[i + j - 1] * Gs[i + 1] % P,\t\t\tGs2[i + j] = 1ll * Gs2[i + j - 1] * Gs2[i + 1] % P;\t&#125;\tfac[0] = 1;\tfor(int i = 1;i &lt;= len;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tifac[1] = 1;\tfor(int i = 2;i &lt;= len;i++) ifac[i] = 1ll * ifac[P % i] * (P - P / i) % P;\tifac[0] = 1;\tfor(int i = 1;i &lt;= len;i++) ifac[i] = 1ll * ifac[i - 1] * ifac[i] % P;&#125;inline void NTT(int *F,int len,int type)&#123;\tfor(int i = 0;i &lt; len;i++)\t\tif(i &lt; rev[i]) swap(F[i],F[rev[i]]);\tfor(int k = 1;k &lt; len;k &lt;&lt;= 1)\t\tfor(int j = 0;j &lt; len;j += k + k)\t\t\tfor(int i = 0;i &lt; k;i++)\t\t\t&#123;\t\t\t\tint cur = type == 1 ? Gs[k | i] : Gs2[k | i];\t\t\t\tint u = F[i | j],v = 1ll * cur * F[i | j | k] % P;\t\t\t\tF[i | j] = Add(u,v);\t\t\t\tF[i | j | k] = Sub(u,v);\t\t\t&#125;\tif(type == -1)\t\tfor(int i = 0,Inv = qpow(len,P - 2);i &lt; len;i++)\t\t\tF[i] = 1ll * F[i] * Inv % P;&#125;int A[N],B[N];int f[N],F[N],G[N];void cdq(int l,int r)&#123;\tif(l == r)\t&#123;\t\tif(l &gt; 1)\t\t&#123;\t\t\tf[l] = 2ll * f[l] * fac[l - 1] % P;\t\t\tf[l] = Sub(f[l],1ll * (l - 1) * f[l - 1] % P);\t\t\tF[l] = 1ll * f[l] * ifac[l - 1] % P;\t\t\tG[l] = 1ll * f[l] * ifac[l] % P;\t\t&#125;\t\treturn;\t&#125;\tint mid = l + r &gt;&gt; 1;\tcdq(l,mid);\tif(l == 1)\t&#123;\t\tint len = GetLen((mid - l + 1) + (mid - l + 1)); // 第一部分\t\tfor(int i = 0;i &lt; len;i++) A[i] = B[i] = 0;\t\tfor(int i = 0;i &lt;= mid - l;i++)\t\t\tA[i] = F[i + 1],B[i] = G[i + 1];\t\tcalc_rev(len);\t\tNTT(A,len,1);NTT(B,len,1);\t\tfor(int i = 0;i &lt; len;i++) A[i] = 1ll * A[i] * B[i] % P;\t\tNTT(A,len,-1);\t\tfor(int i = mid + 1;i &lt;= r;i++)\t\t\tf[i] = Add(f[i],A[i - 2]);\t&#125;\telse // 第二部分和第三部分\t&#123;\t\tint len = GetLen((r - l + 1) + (mid - l + 1));\t\tfor(int i = 0;i &lt; len;i++) A[i] = B[i] = 0;\t\tfor(int i = 0;i &lt; r - l;i++)\t\t\tA[i] = F[i + 1];\t\tfor(int i = 0;i &lt;= mid - l;i++)\t\t\tB[i] = G[i + l];\t\tcalc_rev(len);\t\tNTT(A,len,1);NTT(B,len,1);\t\tfor(int i = 0;i &lt; len;i++) A[i] = 1ll * A[i] * B[i] % P;\t\tNTT(A,len,-1);\t\tfor(int i = mid + 1;i &lt;= r;i++)\t\t\tf[i] = Add(f[i],A[i - l - 1]);\t\tfor(int i = 0;i &lt; len;i++) A[i] = B[i] = 0;\t\tfor(int i = 0;i &lt; r - l;i++)\t\t\tA[i] = G[i + 1];\t\tfor(int i = 0;i &lt;= mid - l;i++)\t\t\tB[i] = F[i + l];\t\tcalc_rev(len);\t\tNTT(A,len,1);NTT(B,len,1);\t\tfor(int i = 0;i &lt; len;i++) A[i] = 1ll * A[i] * B[i] % P;\t\tNTT(A,len,-1);\t\tfor(int i = mid + 1;i &lt;= r;i++)\t\t\tf[i] = Add(f[i],A[i - l - 1]);\t&#125;\tcdq(mid + 1,r);&#125;int main()&#123;\tcin &gt;&gt; n;\tf[1] = F[1] = G[1] = 1;\tint len = GetLen(n * 2);\tinit(len);\tcdq(1,n);\tcout &lt;&lt; ((f[n] - 1) * 2ll) % P &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["counting","poly"]},{"title":"ARC136E 题解","url":"/posts/4041047875/","content":"一开始把图想错了，想了 40 分钟。后来图画对了，但还是没想出来。\r\n正解的思想值得借鉴学习，不会挺正常的。\r\n对于稠密图的分析，可以先从特殊点、特殊边、特殊限制入手，从而掌握一类与这种点有关的性质。\r\n\r\n题意：给出一张有向图 \\(G\\)，每个点有点权 \\(A_i\\)，\\(G\\) 中有边 \\(i\r\n\\to j\\) 当且仅当 \\(i &lt; j \\and\r\n\\gcd(i,j) &gt; 1\\) ，求 \\(G\\)\r\n权值和最大的反链的权值和。\r\n\\(1 \\le n \\le 10^6,1 \\le A_i \\le\r\n10^9\\)。\r\n这张图看着十分鬼畜，边非常多。\r\n正解是从 \\(2\\) 这个特殊数入手。\r\n我们发现所有的偶数都能够互相到达，即最多选一个偶数。\r\n接下来考虑那些奇数怎么选。\r\n那么我们就要研究 \\(i,j(i &lt; j)\\)\r\n奇偶性确定的时候，\\(i\\) 如何到达 \\(j\\)。\r\n假设 \\(i\\) 是奇数，\\(j\\) 是偶数。\r\n那么 \\(i\\)\r\n可以先尝试一步变成偶数，然后直达 \\(j\\)。\r\n设 \\(p(x)\\) 为 \\(x\\) 的最小质因子，那么 \\(i + p(x)\\) 显然是 \\(i\\)\r\n能往前走到的最小的数，同时它显然是一个偶数！\r\n那么我们就可以得到此时 \\(i\\) 能到达\r\n\\(j\\) 的充要条件：\\(i + p(i) \\le j\\)。\r\n类似的，如果 \\(i,j\\) 都是奇数，那\r\n\\(i\\) 可达 \\(j\\) 当且仅当 \\(i\r\n+ p(i) \\le j - p(j)\\)。\r\n如果 \\(i\\) 为偶数，\\(j\\) 为奇数，则条件为 \\(i \\le j - p(j)\\)。\r\n有了以上性质，就可以解决原问题了。\r\n假如我们选一个偶数 \\(t\\)，那么剩下的奇数 \\(i\\) 要满足下列两个条件中的一个：\r\n\r\n\\(i &lt; t\\) 且 \\(i + p(i) &gt; t\\)\r\n\\(i &gt; t\\) 且 \\(i - p(i) &lt; t\\)\r\n\r\n对于每个 \\(t\\)，我们都能用树状数组维护出满足条件的\r\n\\(A_i\\) 之和。\r\n考虑全是奇数的情况，此时需要 \\(\\min i +\r\np(i) &gt; \\max j - p(j)\\)，可以枚举中间的一个分界点统计答案。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;namespace FastIO &#123;\t#define iL (1 &lt;&lt; 20)\tchar ibuf[iL],*iS = ibuf + iL,*iT = ibuf + iL;\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf,1,iL,stdin),iS == iT ? EOF : *iS++) : *iS++)\ttemplate&lt;typename T&gt;\tinline void read(T &amp;a)\t&#123;\t\tchar ch;int sign = 0;\t\tfor(ch = gc();!isdigit(ch);ch = gc())\t\t\tif(ch == &#x27;-&#x27;) sign = 1;\t\ta = ch &amp; 15;\t\tfor(ch = gc();isdigit(ch);ch = gc())\t\t\ta = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch &amp; 15);\t\tif(sign) a = -a;\t&#125;\tchar Out[iL],*iter = Out;\t#define flush() fwrite(Out,1,iter - Out,stdout),iter = Out\ttemplate&lt;typename T&gt;\tinline void write(T x,char end = &#x27;\\n&#x27;)\t&#123;\t\tint c[35],l = 0;if(x &lt; 0) *iter++ = &#x27;-&#x27;,x = -x;\t\tdo c[++l] = x % 10,x /= 10; while(x);\t\twhile(l) *iter++ = c[l--] + &#x27;0&#x27;;\t\t*iter++ = end;flush();\t&#125;\t#undef iL \t#undef gc \t#undef flush&#125;using namespace FastIO;const int N = 1e6 + 5;typedef long long ll;int n,a[N],p[N];struct BIT&#123;\tll tr[N &lt;&lt; 1];\t#define lowbit(x) (x&amp;(-x))\tinline void upd(int x,int v) &#123; for(int i = x;i &lt;= n + n;i += lowbit(i)) tr[i] += v;&#125;\tinline ll Sum(int x) &#123; ll res = 0;for(int i = x;i;i ^= lowbit(i)) res += tr[i];return res;&#125;&#125;;BIT T1,T2;ll dif[N &lt;&lt; 1];int main()&#123;\tread(n);\tfor(int i = 1;i &lt;= n;i++) read(a[i]);\tfor(int i = 2;i &lt;= n;i++)\t&#123;\t\tif(p[i]) continue;\t\tfor(int j = i;j &lt;= n;j += i)\t\t\tif(!p[j]) p[j] = i;\t&#125;\tfor(int i = 3;i &lt;= n;i += 2)\t\tT1.upd(i - p[i] + 1,a[i]);\tll ans = 0;\tfor(int i = 2;i &lt;= n;i++)\t\tif(i &amp; 1) T1.upd(i - p[i] + 1,-a[i]),T2.upd(i + p[i],a[i]);\t\telse ans = max(ans,a[i] + T2.Sum(n + n) - T2.Sum(i) + T1.Sum(i));\tfor(int i = 3;i &lt;= n;i += 2) dif[i - p[i] + 1] += a[i],dif[i + p[i]] -= a[i];\tfor(int i = 1;i &lt;= n + n;i++) dif[i] += dif[i - 1],ans = max(ans,dif[i]);\twrite(ans + a[1]);\treturn 0;&#125;\r\n","tags":["thinking"]},{"title":"AGC038E 题解","url":"/posts/1354329816/","content":"这完全是能力范围内的题。日常做题时还是要多想一想，多尝试尝试，多用几种不同的解法，因为考场上没有看题解的机会。\r\n\r\n首先这题看上去就很 \\(\\min-\\max\\)\r\n容斥，先套上去试一下。\r\n\\[ E(\\max(S)) = \\sum_{T \\subseteq S,T \\ne\r\n\\varnothing} (-1)^{|T|-1} E(\\min(T))\\]。\r\n考虑一个 \\(E(\\min(T))\\)\r\n该怎么算。\r\n首先，\\(T\\) 内的问题无法完全与 \\(T\\)\r\n外的独立开来，因为每次操作是在所有数之间进行的，这会涉及到一个条件概率的问题。\r\n这里有一个比较巧妙的转化，即 第一次到达停止状态的时间是\r\n所有到达停止状态之前的状态的概率乘上停留在该状态的期望时间\r\n之和（我们熟知的等式 \\(E(x) = \\sum_{i\r\n\\ge 0} P(X &gt; i)\\) 就是在所有状态的期望停留时间均为 \\(1\\) 时的特例）。\r\n证明并不难，也与 \\(E(x) = \\sum_{i \\ge 0}\r\nP(X &gt; i)\\)\r\n的证明基本一致。（不过这一点倒是增进了我对这个式子的理解）。\r\n那么每个状态的期望停留时间怎么算？\r\n考虑什么时候会“停留”，即我们一次操作选到了集合 \\(T\\) 之外的点。\r\n显然这个量只与 \\(\\sum_{i \\in T}\r\na_i\\) 有关。\r\n更具体地，设 \\(P\\) 表示集合 \\(T\\) 中某个状态的期望停留时间，设 \\(S = \\sum_{i=1}^na_i\\)，那么会有 \\(P = \\dfrac{S - \\sum_{i \\in T} a_i }{S}P +\r\n1\\) ，即 \\(P = \\dfrac{S}{\\sum_{i \\in\r\nT}a_i}\\)。\r\n考察另外一个部分，即到达某个状态的概率，设 \\(c_i \\in [0,b_i)\\) 表示 \\(i (i \\in T)\\) 在该状态中的出现次数。\r\n那么概率就是 \\[\r\n\\binom{\\sum c}{c_1,c_2,\\dots,c_{|T|}}\\prod_{i \\in T}\r\n(\\dfrac{A_i}{\\sum_{j \\in T}A_j})^{c_i}\r\n\\] 设 \\(A = \\sum_{i \\in T} a_i,C =\r\n\\sum_{i \\in T} c_i\\)。\r\n那么将上式化简可得 \\(\\dfrac{C!}{A^C}\\prod\r\n\\dfrac{A_i^{c_i}}{c_i!}\\)。\r\n代入 \\(\\min-\\max\\)\r\n的式子，那么原式可化为 \\[\r\n\\sum_{T \\subseteq S,T \\ne \\varnothing} (-1)^{|T|-1}\r\n\\dfrac{\\sum_{i=1}^na_i}{A} \\dfrac{C!}{A^C} \\prod_{i \\in T}\r\n\\dfrac{A_i^{c_i}}{c_i!}\r\n\\]\r\n中间两个分式只与 \\(A\\) 和 \\(C\\) 有关，而后面的 \\(\\prod\\) 显然可以 DP。\r\n设 \\(f_{i,j,k}\\) 表示考察前 \\(i\\) 个数，\\(A =\r\nj\\) 且 \\(C = k\\) 的 \\((-1)^{|T|-1}\\prod_{i \\in T}\r\n\\dfrac{A_i^{c_i}}{c_i!}\\) 之和，转移如下：\r\n\\[ f_{i,j,k} = f_{i-1,j,k} - \\sum_{c &lt;\r\nb_i} f_{i-1,j-a_i,k-c}\\dfrac{A_i^c}{c!}\\]。\r\n因为第二维是个背包状物，故直接枚举 \\(c\\) 就可以做到 \\(\\Theta(AB^2)\\) 了。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4e2 + 5,P = 998244353;int n;int a[N],b[N];int fac[N],ifac[N];int f[N][N][N];inline void Plus(int &amp;x,const int &amp;y) &#123; x += y;if(x &gt;= P) x -= P;&#125;inline void Minus(int &amp;x,const int &amp;y) &#123; x -= y;if(x &lt; 0) x += P;&#125;inline int qpow(int a,int b) &#123; int res = 1;while(b) &#123;if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;&#125; return res;&#125;inline void init(int n)&#123;\tfac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tifac[1] = 1;\tfor(int i = 2;i &lt;= n;i++) ifac[i] = 1ll * (P - P / i) * ifac[P % i] % P;\tifac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) ifac[i] = 1ll * ifac[i - 1] * ifac[i] % P;&#125;int sumA = 0,sumB = 0;int main()&#123;\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i] &gt;&gt; b[i],sumA += a[i],sumB += b[i];\tinit(sumB);\tint sum = 0;\tf[0][0][0] = P - 1;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tfor(int j = a[i];j &lt;= sumA;j++)\t\t&#123;\t\t\tfor(int k = 0;k &lt;= sum;k++)\t\t\t\tfor(int c = 0,now = 1;c &lt; b[i];++c)\t\t\t\t&#123;\t\t\t\t\tMinus(f[i][j][k + c],1ll * f[i - 1][j - a[i]][k] * now % P * ifac[c] % P);\t\t\t\t\tnow = 1ll * now * a[i] % P;\t\t\t\t\t&#125;\t\t&#125;\t\tsum += b[i];\t\tfor(int j = 0;j &lt;= sumA;j++)\t\t\tfor(int k = 0;k &lt;= sum;k++)\t\t\t\tPlus(f[i][j][k],f[i - 1][j][k]);\t&#125;\tint ans = 0;\tfor(int sa = 0;sa &lt;= sumA;sa++)\t\tfor(int sc = 0;sc &lt;= sumB;sc++)\t\t\tPlus(ans,1ll * fac[sc] * sumA % P * qpow(qpow(sa,P - 2),sc+1) % P * f[n][sa][sc] % P);\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["counting","min-max 容斥"]},{"title":"一类带负圈的最小费用流","url":"/posts/3143109410/","content":"之前复习网络流的时候好像没有复习扎实，把这玩意漏掉了。\r\n事实证明，“就看看而不写代码”确实挺容易忘的。\r\n\r\n注意：下文所讨论的流都允许一个与 \\(S,T\\) 不相连的环出现。\r\n下文的四元组 \\((u,v,w,c)\\)\r\n表示一条从 \\(u\\) 到 \\(v\\)，流量为 \\(w\\)，费用为 \\(c\\) 的边。\r\n一般不带负圈的最小费用流，大家使用自己喜欢的方式就跑过去了。\r\n但是带负圈的最小费用流，会给最短路算法带来极大的困难，导致增广出现问题。\r\n我们就需要一个办法，把图里的负权边都去掉。\r\n注意到我们在建网络流图的时候，会对称地建一条反着的边，费用为原边权的相反数，表示退流。\r\n那么我们在这里，能不能先把负权边都流满，然后借助反向的正权边来完成”退流“工作呢？\r\n显然是可以的。\r\n对于一条负权边 \\((u,v,w,c)\\)\r\n，我们先把该边流满，将答案预先加上 \\(w \\times\r\nc\\)，然后建出反向边 \\((v,u,w,-c)\\)，用以退流。\r\n但这种做法还有一个问题，即所有负权边满流的网络，不一定满足流量平衡的限制。\r\n设原图源汇为 \\(S,T\\)，我们新建虚拟源点、虚拟汇点 \\(S&#39;,T&#39;\\)，用 \\(S&#39;,T&#39;\\)\r\n跑遍网络流，来满足流量平衡的限制。\r\n具体地，假设我们处理了一条负权边 \\((u,v,w,c)\\)，那么 \\(u\\) 点就应该多流入 \\(w\\) 的流量，\\(v\\) 点应该多流出 \\(w\\) 的流量，我们通过连边 \\((u,T&#39;,w,0),(S&#39;,v,w,0)\\)\r\n来表达这两个限制，因为最后基于 \\(S&#39;,T&#39;\\)\r\n跑出来的网络流是流量平衡的，我们把这里连的虚拟边删掉，就正好满足 \\(u\\) 点多流入 \\(w\\)，\\(v\\)\r\n点多流出 \\(w\\)。\r\n所以，对于一条负权边，我们会将其拆为三条边 \\((u,v,w,c),(S&#39;,v,w,0),(u,T&#39;,w,0)\\)。然后我们先以\r\n\\(S&#39;\\) 为源点，\\(T&#39;\\)\r\n为汇点，跑一遍网络流。在残量网络上，忽略与 \\(S&#39;\\) 和 \\(T&#39;\\) 相邻的边，再以 \\(S\\) 和 \\(T\\)\r\n为源汇，跑一遍网络流，将两遍网络流得到的答案相加即可。\r\n需要注意的是，就算原图中没有源汇，这个方法也是可行的，此时这个问题被叫做最小费用循环流（或者说最小费用可行流）。\r\n此时，在原问题中，我们一次会增广一个环，假设这个环除了某条负权边\r\n\\((u,v,w,c)\\) 外，剩下的边费用为 \\(p\\)。\r\n如果 \\(c + p &lt;\r\n0\\)，那么这个负环需要增广，在新图上，有 \\(p &lt; -c\\)\r\n那么我们会倾向与走剩下的那条路径，也就是不退流。反之，因为是正环，所以我们会倾向于不增广，在新图上就是走这条\r\n\\((v,u,w,-c)\\) ，把流退掉。\r\n这样可以从另一个方面理解其正确性。\r\n需要注意的是，在求解循环流的时候，需要注意原题面有没有限制流量上界。有的话，在通过\r\n\\(S&#39;,T&#39;\\)\r\n增广时就要加以限制。\r\n事实上，如果读者对上下界网络流较为熟悉，应该能看出来，这就是对上下界网络流的一种应用。\r\n附上模板题代码：\r\n洛谷 P7173\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e2 + 5;typedef long long ll;const ll llinf = 0x3f3f3f3f3f3f3f3f;int n,m,S,T;int num[N];namespace Flow&#123;\tconst int N = 2e3 + 5,M = 2e6 + 5;\tint fir[N],nxt[M],to[M],w[M],cost[M],ect = 1;\tinline void addedge(int u1,int v1,int w1,int c1)\t &#123; nxt[++ect] = fir[u1];fir[u1] = ect;to[ect] = v1;w[ect] = w1;cost[ect] = c1;&#125;\tinline void ins(int u1,int v1,int w1,int c1) &#123; addedge(u1,v1,w1,c1);addedge(v1,u1,0,-c1);&#125;\tll dis[N],h[N];\tbool vst[N];\tint tot;\tinline void Clr(int _n)\t&#123;\t\ttot = _n;ect = 1;\t\tfor(int i = 1;i &lt;= tot;i++) fir[i] = 0;\t&#125;\tvoid spfa(int S,int T)\t&#123;\t\tfor(int i = 1;i &lt;= tot;i++) dis[i] = llinf,vst[i] = 0;\t\tqueue&lt;int&gt; Q;\t\tQ.push(S);dis[S] = 0;vst[S] = 1;\t\twhile(!Q.empty())\t\t&#123;\t\t\tint x = Q.front();Q.pop();vst[x] = 0;\t\t\tfor(int i = fir[x],y;y = to[i],i;i = nxt[i])\t\t\t\tif(w[i] &amp;&amp; dis[y] &gt; dis[x] + cost[i])\t\t\t\t&#123;\t\t\t\t\tdis[y] = dis[x] + cost[i];\t\t\t\t\tif(!vst[y]) Q.push(y),vst[y] = true;\t\t\t\t&#125; \t\t&#125;\t\tfor(int i = 1;i &lt;= tot;i++) h[i] = dis[i];\t&#125;\tint pn[N],pe[N],flow[N];\tstruct node&#123;\t\tint id;ll dis;\t\tnode()&#123;&#125;\t\tnode(const int _id,const ll _dis):id(_id),dis(_dis)&#123;&#125;\t\tbool operator &lt; (const node &amp;rhs) const &#123; return dis &gt; rhs.dis;&#125;\t&#125;;\tbool Dijkstra(int S,int T,int F = 1e9)\t&#123;\t\tfor(int i = 1;i &lt;= tot;i++)\t\t\tpe[i] = pn[i] = vst[i] = 0,dis[i] = llinf;\t\tpriority_queue&lt;node&gt; Q;\t\tflow[S] = F;Q.emplace(S,dis[S] = 0);\t\twhile(!Q.empty())\t\t&#123;\t\t\tint x = Q.top().id;Q.pop();\t\t\tif(vst[x]) continue;\t\t\tvst[x] = true;\t\t\tfor(int i = fir[x],y,ww;y = to[i],ww = cost[i] + h[x] - h[y],i;i = nxt[i])\t\t\t\tif(w[i] &amp;&amp; dis[y] &gt; dis[x] + ww)\t\t\t\t&#123;\t\t\t\t\tdis[y] = dis[x] + ww;\t\t\t\t\tpn[y] = x;pe[y] = i;flow[y] = min(flow[x],w[i]);\t\t\t\t\tQ.emplace(y,dis[y]);\t\t\t\t&#125;\t\t&#125;\t\treturn dis[T] &lt; llinf;\t&#125;\tpair&lt;ll,ll&gt; MCMF(int S,int T)\t&#123;\t\tll F = 0,res = 0;\t\tspfa(S,T);\t\twhile(Dijkstra(S,T))\t\t&#123;\t\t\tfor(int i = 1;i &lt;= tot;i++) if(vst[i]) h[i] += dis[i];\t\t\tint now = T;\t\t\tres += flow[T] * h[T];\t\t\twhile(now != S)\t\t\t\tw[pe[now]] -= flow[T],w[pe[now] ^ 1] += flow[T],now = pn[now];\t\t\tF += flow[T];\t\t&#125;\t\treturn make_pair(F,res);\t&#125;&#125;ll ans = 0;int main()&#123;\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;\tFlow::Clr(n + 2);\tfor(int i = 1;i &lt;= m;i++)\t&#123;\t\tint x,y,f,c;\t\tcin &gt;&gt; x &gt;&gt; y &gt;&gt; f &gt;&gt; c;\t\tif(c &gt;= 0)\t\t\tFlow::ins(x,y,f,c);\t\telse\t\t&#123;\t\t\tnum[x] -= f;num[y] += f;\t\t\tFlow::ins(y,x,f,-c);\t\t\tans += 1ll * c * f;\t\t&#125;\t&#125;\tint SS = n + 1,TT = n + 2;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tif(num[i] &gt; 0) Flow::ins(SS,i,num[i],0);\t\tif(num[i] &lt; 0) Flow::ins(i,TT,-num[i],0);\t&#125;\tans += Flow::MCMF(SS,TT).second;\tpair&lt;ll,ll&gt; res = Flow::MCMF(S,T);\tcout &lt;&lt; res.first &lt;&lt; &#x27; &#x27; &lt;&lt; res.second + ans &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["graph theory","flow"]},{"title":"CF1575C 题解","url":"/posts/3953954419/","content":"赛时想着用卷积处理散块，但不知道如何避免重复统计的问题，赛后看到题解做法大受震撼，故记录一下。有时一个观察能帮你省掉很多东西。\r\n\r\n我们先考虑固定右端点 \\(r\\)\r\n，计算所有左端点的答案。\r\n一个关键但显然的观察是，\\(r\\) 和\r\n\\(r + m\\)\r\n的答案是相同的，这意味着我们只需计算 \\(1 \\le l\r\n\\le nm,1 \\le r \\le n\\) 的答案，最后把答案乘 \\(m\\) 即可。\r\n设 \\(sum(p) = \\sum_{i=1}^p b_i\\)\r\n，即 \\(b\\) 序列的前缀和。如果 \\(nm\\) 不大的话，我们大可以预处理出 \\(cnt[i]\\) 表示满足 \\(sum(p) \\bmod k = i\\) 的 \\(p\\) 的个数。然后扫描 \\(r\\) ，每次先让 \\(cnt[sum(r)]\\) 减 \\(1\\)，再提取出 \\(cnt[sum(r) + sum(n)]\\) 作为 \\(r\\) 的答案，再将 \\(cnt[sum(r) + sum(n)]\\) 加 \\(1\\) 。容易发现，上述过程正确地统计了所有\r\n\\(l &lt; r\\) 和 \\(l &gt; r\\) 的子段，可以手算验证。\r\n我们发现，上述做法的瓶颈在于，如何快速地预处理 \\(cnt\\)。\r\n如果 \\(sum(n) \\bmod k =\r\n0\\)，处理起来比较容易。\r\n否则，我们希望对于每个 \\(1 \\le l \\le\r\nn\\)，我们能把 \\(sum(l),sum(l + n),\\dots\r\nsum(l + (m - 1)n)\\) 的贡献一起加入到 \\(cnt\\) 中，即需要对于 \\(t \\in [0,m)\\) ，令 \\(cnt[(sum(l) + t \\cdot sum(n)) \\bmod k]\\)\r\n自增 \\(1\\)。事实上，考虑一张图，对于每个点 \\(i\\)，连边 \\((i,(i\r\n+ sum(n)) \\bmod k)\\) ，最后会形成一个长度为 \\(k\\) 的环（因为 \\(k\\)\r\n是质数），那么我们的操作相当于对环上连续的一段进行区间加。维护差分数组即可做到\r\n\\(\\Theta(n + k)\\)。\r\n事实上，对于 \\(k\\)\r\n不是质数的情况，上述做法也是可行的，只不过可能会形成若干个环，我们要对每个环分开考虑。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5,P = 1e9 + 7;int n,m,k,sum[N];int cnt[N];int Id[N]; // 环上各点的编号int dif[N]; // 差分数组int main()&#123;\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\tfor(int i = 1;i &lt;= n;i++)\t\tcin &gt;&gt; sum[i],(sum[i] += sum[i - 1]) %= k;\tint sall = 1ll * sum[n] * m % k;\tint sn = sum[n];\tif(!sn)\t&#123;\t\tint res = 0;\t\tfor(int i = 1;i &lt;= n;i++) (res += cnt[sum[i]]++) %= P;\t\tint ans = (1ll * ((res &lt;&lt; 1ll) + n) % P * m % P * m % P - (1ll * n * m % P) + P + 1) % P;\t\tcout &lt;&lt; ans &lt;&lt; endl;\t\treturn 0;\t&#125;\tId[0] = 1;\tfor(int i = sn,j = 2;i;i = (i + sn) % k,++j)\t\tId[i] = j;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tint vl = sum[i],vr = (sum[i] + 1ll * m * sn % k) % k; // [vl,vr)\t\tvl = Id[vl];vr = Id[vr];\t\t(dif[1] += m / k) %= P;\t\tif(vl &lt;= vr) dif[vl]++,dif[vr]--;\t\telse dif[vl]++,dif[1]++,dif[vr]--;\t&#125;\tfor(int i = 1;i &lt;= k;i++)\t\t(dif[i] += dif[i - 1]) %= P;\t// for(int i = 1;i &lt;= n;i++) printf(&quot;%d &quot;,sum[i]);printf(&quot;\\n&quot;);\t// for(int i = 0;i &lt; k;i++) printf(&quot;%d &quot;,Id[i]);printf(&quot;\\n&quot;);\t// for(int i = 1;i &lt;= k;i++) if(dif[i]) printf(&quot;%d,%d &quot;,i,dif[i]);printf(&quot;\\n&quot;);\tint ans = 0;\t//(dif[Id[sall]] += 1) %= P;\tfor(int r = 1;r &lt;= n;r++)\t&#123;\t\t\t(dif[Id[sum[r]]] += P - 1) %= P;\t\t(ans += dif[Id[(sum[r] + sall) % k]]) %= P;\t\t(dif[Id[(sum[r] + sall) % k]] += 1) %= P;\t&#125;\tans = 1ll * ans * m % P;\tif(!sall) ans = (ans + 1) % P;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["counting"]},{"title":"CF1770G 题解（分治 NTT 在格路计数中的应用）","url":"/posts/2722203261/","content":"之前没有接触过这方面的应用（没想到分治 NTT\r\n这么强大），故记录一下。\r\n\r\n首先我们考虑一个格路计数模型，即从 \\((0,0)\\) 出发，向右或向上走，要走到 \\((n,m)\\) ，但第 \\(i\\) 列只存在行数不大于 \\(c_i\\) 的点，\\(c_i\\) 单调不降，且 \\(c_n = m\\) ，求路径条数。\r\n上述的网格是个阶梯状的图形，用分治 NTT\r\n解决阶梯网格的格路计数是很经典的应用（虽然此前我从来没听说过）。\r\n首先考虑 \\(n^2\\) DP，这是简单的，即\r\n\\(dp_{i,j} \\to dp_{i+1,j},dp_{i,j} \\to\r\ndp_{i,j+1}\\)。\r\n但是直接这么做很难优化，本质上是因为这个 DP\r\n没有明显的阶段性，即同一个 \\(i\\)\r\n内的所有 \\(j\\) 都会互相转移。\r\n我们修改 DP 状态，第一维记录 \\(x +\r\ny\\)，第二维记录 \\(y\\)\r\n，那么就会有 \\(dp_{k,j} \\to dp_{k +\r\n1,j},dp_{k,j} \\to dp_{k+1,j+1}\\)。\r\n为了避免在 \\(k &gt; n\\) 的时候还会有\r\n\\(j \\ge k - n\\) 的限制，考虑从 \\((n,0)\\)\r\n开始沿左上-右下方向把阶梯网格劈成两半，计算从 \\((0,0)\\) 和 \\((n,m)\\) 走到这条斜对角上的点 （\\(i + j = n\\)）\r\n的方案数，容易发现这两个问题是对称的。\r\n综合上述分析，我们将问题转化为，从 \\((0,0)\\)\r\n出发，每次可以向右或向右上走一步，且在第 \\(i\\) 列只存在行数不大于 \\(c_i\\)\r\n的点，走到最后一列每一个点的方案数。容易证明转化完后的 \\(c_i\\)\r\n仍然是不降的，且满足一个优秀的性质：\\(c_{x +\r\n1} - c_x \\le 1\\)。\r\n事实上，转化后的 \\(c_i\\) 就是 \\(x + y = i\\)\r\n的点的个数，就算这个阶梯形网格是个 \\(n \\times\r\nm\\) 的矩形，\\(c_{i + 1} - c_i\\)\r\n也不超过 \\(1\\)。\r\n经过上述的转化之后，问题终于有了明显的分层，可以考虑优化转移了。\r\n考虑一个 \\(dp_l\\) 对 \\(dp_r\\) 的贡献，设 \\(x = c_r - (r - l)\\)，我们发现，对于 \\(j \\le x\\)，\\(dp_{l,j}\\) 转移到 \\(dp_r\\) 时不会受到 \\(c\\) 的限制（因为 \\(c_{i + 1} - c_i \\le 1\\)）。\r\n\r\n（图源自 @Alex_Wei，对于 \\(j \\le x\\)\r\n的部分，它就算一路往上冲，也不会超过上图的红线。）\r\n那么从 \\(dp_{l,j_1}(j_1 \\le x)\\)\r\n转移到 \\(dp_{r,j_2}\\)\r\n的系数算起来就很容易了，就是 \\(\\binom{r -\r\nl}{j_2 - j_1}\\)。\r\n这是一个很明显的卷积形式，我们设 \\(F_i =\r\ndp_{l,i},G_i = dp_{r,i},H_i = \\binom{r - l}{i}\\)，那么我们将\r\n\\(F_{0 \\dots x}\\) 与 \\(H_{0 \\dots r - l}\\) 进行卷积，\r\n将这一部分贡献加到 \\(G_{0 \\dots c_r}\\)\r\n上。\r\n对于 \\(j &gt; x\\) 的 \\(dp_{l,j}\\)，我们尝试将区间分为 \\([l,mid]\\) 和 \\((mid,r]\\) 递归处理，即先将左区间的贡献加到\r\n\\(dp_{mid}\\) 上，再用 \\(dp_{mid}\\) 的一部分去更新 \\(dp_r\\)。\r\n把这两部分的贡献加起来，所有 \\(k \\in\r\n[l,r)\\) 的 \\(dp_k\\) 对 \\(dp_r\\) 的贡献就计算完毕了。\r\n考虑实现这么一个算法流程：\r\n设 \\(Solve(l,r,\\Delta,F)\\)\r\n表示当前还没确定 \\(dp\\) 值的区间为\r\n\\((l,r]\\)，传入多项式的第 \\(i\\) 项表示 \\(dp_{l,i + \\Delta}\\)，返回多项式的第 \\(i\\) 项表示 \\(dp_{r,i + \\Delta}\\) 。这也可以看作是让所有\r\n\\(i \\in [l,r]\\) 的 \\(c_i\\) 全部减去 \\(\\Delta\\)，传入的 \\(F_i = dp_{l,i}\\)，返回的 \\(G_i =\r\ndp_{r,i}\\)。下文将采用这种视角进行叙述。\r\n设 \\(x = c_r - (r - l)\\)，对于 \\(j \\le x\\)，将 \\(F_{0 \\dots x}\\) 与 \\(H_{0 \\dots r - l}\\) 卷积，将得到的结果加到\r\n\\(G_{0 \\dots c_r}\\) 上面。\r\n对于 \\(j &gt; x\\)，分治下放，设\r\n\\(F&#39; = F_{x + 1 \\dots\r\nc_l}\\)，那么顺次执行 \\(F&#39; \\gets\r\nSolve(l,mid,\\Delta + x + 1,F&#39;),F&#39; \\gets Solve(mid,r,\\Delta + x +\r\n1,F&#39;)\\)。\r\n将最后得到的 \\(F&#39;\\) 也加到 \\(G_{0 \\dots c_r}\\) 上面。然后返回 \\(G\\) 即可。\r\n对于边界，\\(r - l = 1\\)\r\n的处理是平凡的。\r\n分析复杂度。对于下传的 \\(F&#39;\\)，其长度显然不超过 \\(c_r - x = r - l\\)，也就是说，对于 \\(Solve(l,r,\\Delta,F)\\)，\\(F\\)\r\n的长度不会超过当前分治区间的父区间的长度，即 \\(2(r - l)\\)。设 \\(n,m\\) 同阶，则该算法复杂度与一般的分治 NTT\r\n相同，为 \\(\\Theta(n \\log ^2 n)\\)。\r\n\r\n终于可以说回原题了。\r\n题意：给出一个括号串 \\(S\\) ，设\r\n\\(k\\)\r\n为最少需要删去的字符数使得原串是个合法括号串，求删去 \\(k\\) 个字符后原串合法的方案数，对 \\(998244353\\) 取模。\r\n\\(1 \\le |S| \\le 5 \\times\r\n10^5\\)。\r\n首先，我们要删去的字符一定形如 ))))((\r\n，即一段右括号再加上一段左括号。\r\n我们考虑找到这个分界点。\r\n把左括号看成 \\(1\\),右括号看成 \\(-1\\)。考察这个序列的前缀和。\r\n我们一定一个位置为 \\(\\text{Special}\\)\r\n的，当且仅当它对应的数是前缀最小值。因为 \\(\\text{Special}\\)\r\n位置的数一定是在它之前的位置的数的最小值减 \\(1\\)，所以每遇上一个 \\(\\text{Special}\\)\r\n位置，我们就需要在这个位置或其之前删掉一个右括号。\r\n那我们就将最后一个 \\(\\text{Special}\\)\r\n位置，当作上述的分界线，在这个位置左边，我们只删右括号；在这个位置右边，我们只删左括号。\r\n这两个部分是本质相同的，下文以删右括号的部分为例。\r\n那么我们对于每个前缀，选中的右括号数一定不小于 \\(\\text{Special}\\) 位置的数量。\r\n那么我们可以设 \\(dp_{i,j} (j \\ge\r\n0)\\) 表示前 \\(i\\)\r\n个右括号 ，选中的右括号数减去 \\(\\text{Special}\\) 位置的数量为 \\(j\\) 的方案数。\r\n如果 \\(i + 1\\) 是个 \\(\\text{Special}\\) 位置，转移到 \\(dp_{i + 1,j/j - 1}\\)，否则转移到 \\(dp_{i + 1,j/j+1}\\)。\r\n这看上去就挺格路计数的，可以套用上面的做法。因为限制只有 \\(j \\ge 0\\)，我们甚至不需要记录 \\(\\Delta\\)。\r\n当然，还是稍有变形。具体地，记录 \\([l,r]\\) 中 \\(\\text{Special}\\) 位置的个数 \\(cnt\\)。那么对于 \\(j \\ge cnt\\)，\\(dp_{l - 1,j}\\) 转移到 \\(dp_{r,j + p - cnt}\\) 就不受 \\(j \\ge 0\\) 限制的影响，转移系数为 \\(\\binom{r - l + 1}{p}\\) 。\r\n对于 \\(j &lt; cnt\\)\r\n的部分，递归下放去做即可，下放的多项式长度不会超过 \\(r - l + 1\\)，故复杂度为 \\(\\Theta(n \\log ^2 n)\\)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1 &lt;&lt; 20,P = 998244353,G = 3;inline int Add(int a,int b) &#123; return (a + b &gt;= P) ? (a + b - P) : (a + b);&#125;inline int Sub(int a,int b) &#123; return (a &lt; b) ? (a - b + P) : (a - b);&#125;  inline int qpow(int a,int b) &#123; int res = 1;while(b) &#123;if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;&#125; return res;&#125;const int Gi = qpow(G,P - 2);int n;char s[N];int Gs[N],Gs2[N];int rev[N];inline int GetLen(int x)&#123;\tint len = 1;\twhile(len &lt;= x) len &lt;&lt;= 1;\treturn len;&#125;inline void calc_rev(int len)&#123;\tfor(int i = 0;i &lt; len;i++)\t&#123;\t\trev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1;\t\tif(i &amp; 1) rev[i] |= len &gt;&gt; 1;\t&#125;&#125;int fac[N],ifac[N];inline void init(int len)&#123;\tfor(int i = 1;i &lt; len;i &lt;&lt;= 1)\t&#123;\t\tGs[i] = Gs2[i] = 1;\t\tGs[i + 1] = qpow(G,(P - 1) / (i &lt;&lt; 1));\t\tGs2[i + 1] = qpow(Gi,(P - 1) / (i &lt;&lt; 1));\t\tfor(int j = 2;j &lt; i;j++)\t\t\tGs[i + j] = 1ll * Gs[i + j - 1] * Gs[i + 1] % P,\t\t\tGs2[i + j] = 1ll * Gs2[i + j - 1] * Gs2[i + 1] % P;\t&#125;\tfac[0] = 1;\tfor(int i = 1;i &lt; len;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tifac[1] = 1;\tfor(int i = 2;i &lt; len;i++) ifac[i] = 1ll * ifac[P % i] * (P - P / i) % P;\tifac[0] = 1;\tfor(int i = 1;i &lt; len;i++) ifac[i] = 1ll * ifac[i - 1] * ifac[i] % P;&#125;inline int Binom(int n,int m) &#123; if(n &lt; 0 || m &lt; 0 || n &lt; m) return 0;return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;&#125;inline void NTT(vector&lt;int&gt; &amp;F,int len,int type)&#123;\tassert(F.size() &lt;= len);\tF.resize(len);\tfor(int i = 0;i &lt; len;i++)\t\tif(i &lt; rev[i]) swap(F[i],F[rev[i]]);\tfor(int k = 1;k &lt; len;k &lt;&lt;= 1)\t\tfor(int j = 0;j &lt; len;j += k + k)\t\t\tfor(int i = 0;i &lt; k;i++)\t\t\t&#123;\t\t\t\tint cur = type == 1 ? Gs[k | i] : Gs2[k | i];\t\t\t\tint u = F[i | j],v = 1ll * cur * F[i | j | k] % P;\t\t\t\tF[i | j] = Add(u,v);\t\t\t\tF[i | j | k] = Sub(u,v);\t\t\t&#125;\tif(type == -1)\t\tfor(int i = 0,Inv = qpow(len,P - 2);i &lt; len;i++)\t\t\tF[i] = 1ll * F[i] * Inv % P;&#125;vector&lt;int&gt; t; // 存储每个要删的括号的标记状态void Solve(int l,int r,vector&lt;int&gt; &amp;f)&#123;\tif(l == r)\t&#123;\t\tif(!t[l])\t\t&#123;\t\t\tf.push_back(0);\t\t\tfor(int i = f.size() - 1;i &gt;= 1;i--)\t\t\t\tf[i] = Add(f[i],f[i - 1]);\t\t&#125;\t\telse for(int i = 0;i &lt; f.size() - 1;i++) f[i] = Add(f[i],f[i + 1]);\t\treturn;\t&#125;\tint mid = l + r &gt;&gt; 1,len = r - l + 1,cnt = 0;\tfor(int i = l;i &lt;= r;i++)\t\tcnt += t[i];\tvector&lt;int&gt; res(f.size() + (len - cnt),0);\tif(f.size() &gt; cnt)\t&#123;\t\tvector&lt;int&gt; A(f.size() - cnt,0),B(len + 1,0);\t\tfor(int i = 0;i &lt; f.size() - cnt;i++)\t\t\tA[i] = f[i + cnt];\t\tfor(int i = 0;i &lt;= len;i++)\t\t\tB[i] = Binom(len,i);\t\tint L = GetLen(f.size() + len - cnt);\t\tcalc_rev(L);\t\tNTT(A,L,1);NTT(B,L,1);\t\tfor(int i = 0;i &lt; L;i++) A[i] = 1ll * A[i] * B[i] % P;\t\tNTT(A,L,-1);\t\tfor(int i = 0;i &lt; res.size();i++) res[i] = A[i];\t&#125;\tvector&lt;int&gt; ff0(min((int)f.size(),cnt),0);\tfor(int i = 0;i &lt; ff0.size();i++) ff0[i] = f[i];\tSolve(l,mid,ff0);Solve(mid + 1,r,ff0);\tfor(int i = 0;i &lt; ff0.size();i++) res[i] = Add(res[i],ff0[i]);\tf = res;&#125;int DoIt()&#123;\tif(t.empty()) return 1;\tvector&lt;int&gt; f(1,1);\tSolve(0,t.size() - 1,f);\treturn f[0];&#125;int main()&#123;\tscanf(&quot;%s&quot;,s + 1);\tn = strlen(s + 1);\tint cur = 0,lst = 0;\tinit(GetLen(n * 2 + 2));\tfor(int i = 1;i &lt;= n;i++)\t\tif(s[i] == &#x27;(&#x27;) ++cur;\t\telse &#123; if(!cur) lst = i;else --cur;&#125;\tcur = 0;\tfor(int i = 1;i &lt;= lst;i++)\t\tif(s[i] == &#x27;(&#x27;) ++cur;\t\telse &#123; if(!cur) t.push_back(1);else t.push_back(0),--cur;&#125;\tint ans = DoIt();\tvector&lt;int&gt;().swap(t);cur = 0;\tfor(int i = n;i &gt; lst;i--)\t\tif(s[i] == &#x27;)&#x27;) ++cur;\t\telse &#123; if(!cur) t.push_back(1);else t.push_back(0),--cur;&#125;\tans = 1ll * ans * DoIt() % P;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n这道题加深了我对分治 NTT 的理解。\r\n","tags":["counting","poly"]},{"title":"CF1172F 题解","url":"/posts/2012520028/","content":"这题还是想岔了一些，也有可能是图画错了，有些性质观察得并不是很彻底。和题解无限接近了属于是（\r\n\r\n对于一个区间 \\([l,r]\\)\r\n，显然，对于初始数 \\(t\\)，设 \\(f(t)\\) 表示最终值那么 \\(f(t)\\) 是一个关于 \\(t\\) 的分段函数，且最多 \\(r - l + 2\\) 段，因为只会减 \\(0 \\sim (r - l + 1)\\) 个 \\(p\\)。\r\n对于一段数列，设 \\(c_x\\)\r\n表示初始数最少是多少，使得做完这个数列之后减去了 \\(x\\) 个 \\(p\\)。\r\n在序列上的问题， \\(n\\) 又高达 \\(10^6\\)，当然首选线段树。\r\n考虑怎么合并 \\([l,mid]\\) 和 \\((mid,r]\\) 的 \\(c\\) 数组。\r\n当然是用左边的 \\(c_x\\) 和右边的\r\n\\(c_y\\) 来更新 \\(c_{x+y}\\)。\r\n下文设 \\([l,mid]\\) 的和为 \\(Sl\\)。\r\n考虑更新的条件，我们要确保对于一个在 \\([c_x,c_{x+1})\\)\r\n中的数，其在做完左边之后还大于等于 \\(c_y\\)。\r\n那么就有条件 \\(c_{x +1} - 1 + Sl - xp \\ge\r\nc_y\\)。\r\n那么更新的时候，从 \\(mid\\) 反推回\r\n\\(l\\)，就得到转移式 \\(c_{x+y} \\gets \\min\\{c_{x+y},\\max\\{c_x,c_y + xp -\r\nSl\\}\\}\\)。\r\n直接这么做的话，合并两个区间的复杂度是平方的，不如暴力。\r\n事实上，对于这种 \\(h_{x+y} \\gets\r\n\\min\\{h_{x+y},\\max\\{f_x,g_y\\}\\}\\)\r\n的转移，是可以考虑双指针优化的。（当然，要求 \\(f,g,h\\) 均单调）\r\n考察双指针的可行性，首先，\\(c\\)\r\n肯定是单调递增的。\r\n我们再说明，对于 \\(x + y\\)\r\n相同的转移，我们取 \\(x\\)\r\n最小的一定不劣。\r\n即证明 \\((x,y)\\) 不劣于 \\((x+1,y-1)\\)。\r\n首先有 \\(c_{x+1} - 1 + Sl - xp \\ge\r\nc_{y}\\)，即 \\(c_{y} - Sl + xp &lt;\r\nc_{x+1}\\)。\r\n且有 \\(c_x &lt; c_{x+1}\\)。\r\n所以 \\(\\max\\{c_x,c_y + xp - Sl\\} &lt;\r\nc_{x+1}\\)。\r\n显然会有 \\(\\max\\{c_x,c_y + xp - Sl\\} &lt;\r\n\\max\\{c_{x+1},c_{y-1} + (x+1)p - Sl\\}\\)。\r\n但有这点还是不够，为了能够用指针维护决策点，我们还需说明，\\(c_{x+1} - 1 + Sl - xp\\) 是关于 \\(x\\) 单调递增的，也就是 \\(c_{x+1} - c_x \\ge p\\)。\r\n由于 \\(c_x\\) 表示最小的初始值，所以\r\n\\(c_x\\) 经过一段区间后，最大值必定是\r\n\\(0\\)，否则我们可以将初始值调小一点，所以我们需要再增加至少\r\n\\(p\\) 才可以再减掉一个 \\(p\\)。\r\n那么，我们只需维护一个指针 \\(pos\\)，表示当前最大的满足条件的 \\(y\\)，在 \\(x\\) 自增时，\\(pos\\) 对应移动，用走到的那些 \\(y\\) 转移即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5,Sz = N &lt;&lt; 2;typedef long long ll;const ll INF = 0x3f3f3f3f3f3f3f3f;template&lt;typename T&gt; inline void ckmin(T &amp;x,const T &amp;y) &#123; if(x &gt; y) x = y;&#125;template&lt;typename T&gt; inline void ckmax(T &amp;x,const T &amp;y) &#123; if(x &lt; y) x = y;&#125;int n,m,p,a[N];struct node&#123;\tint l,r,len;\tll sum;\tvector&lt;ll&gt; c;&#125;;node tr[Sz];#define ls k &lt;&lt; 1#define rs k &lt;&lt; 1 | 1inline void pushup(int k)&#123;\ttr[k].sum = tr[ls].sum + tr[rs].sum;\tfor(int x = 0,y = 0;x &lt;= tr[ls].len;x++)\t&#123;\t\tif(y &gt; tr[rs].len) --y;\t\tfor(;y &lt;= tr[rs].len;++y)\t\t&#123;\t\t\tll val = tr[rs].c[y] + 1ll * x * p - tr[ls].sum;\t\t\tll lim = tr[ls].c[x + 1] - 1 - 1ll * x * p + tr[ls].sum;\t\t\tif(lim &lt; tr[rs].c[y]) &#123;if(y) --y;break; /* 当前 y 不合法，要回退一个*/&#125;\t\t\tckmin(tr[k].c[x + y],max(tr[ls].c[x],val));\t\t&#125;\t&#125;&#125;void build(int k,int l,int r)&#123;\ttr[k].l = l;tr[k].r = r;\ttr[k].len = r - l + 1;\tfor(int i = 1;i &lt;= tr[k].len + 2;i++) tr[k].c.push_back(INF);\ttr[k].c[0] = -INF;\tif(l == r) &#123; tr[k].sum = a[l];tr[k].c[1] = p - a[l];return;&#125;\tint mid = l + r &gt;&gt; 1;\tbuild(k &lt;&lt; 1,l,mid);\tbuild(k &lt;&lt; 1 | 1,mid + 1,r);\tpushup(k);\t// printf(&quot;[%d,%d]: &quot;,l,r);\t// for(auto i : tr[k].c) printf(&quot;%d &quot;,i);\t// printf(&quot;\\n&quot;);&#125;ll Now; // 全局变量，初始时为 0,遇到一个区间，就让 now = f(l,r,now)，最后拼凑出询问区间的答案。void Query(int k,int l,int r,int x,int y)&#123;\tif(l &gt; y || r &lt; x) return;\tif(x &lt;= l &amp;&amp; r &lt;= y) \t&#123;\t\tint pos = upper_bound(tr[k].c.begin(),tr[k].c.end(),Now) - tr[k].c.begin() - 1;\t\tNow = Now - 1ll * pos * p + tr[k].sum;\t\treturn;\t&#125;\tint mid = l + r &gt;&gt; 1;\tQuery(k &lt;&lt; 1,l,mid,x,y);\tQuery(k &lt;&lt; 1 | 1,mid + 1,r,x,y);&#125;int main()&#123;\tios::sync_with_stdio(false);\tcin.tie(0);cout.tie(0);\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; p;\tfor(int i = 1;i &lt;= n;i++)\t\tcin &gt;&gt; a[i];\tbuild(1,1,n);\tfor(int i = 1;i &lt;= m;i++)\t&#123;\t\tint l,r;\t\tcin &gt;&gt; l &gt;&gt; r;\t\tNow = 0;\t\tQuery(1,1,n,l,r);\t\tcout &lt;&lt; Now &lt;&lt; endl;\t&#125;\treturn 0;&#125;\r\n","tags":["DS"]},{"title":"ARC135E 题解","url":"/posts/3377480582/","content":"不知道如何评价题。\r\n\r\n题意：\r\n给出两个数 \\(n,x\\)，构造序列 \\(A\\)，使其满足下列限制：\r\n\r\n\\(A_1 = x\\)。\r\n\\(A_i &lt; A_{i+1}\\)。\r\n\\(A_i\\) 是 \\(i\\) 的倍数。\r\n\r\n在此基础上，使得 \\(\\sum A_i\\)\r\n最小，输出答案对 \\(998244353\\)\r\n取模的值。\r\n\\(T\\) 组数据。\\(1 \\le T \\le 10,1 \\le n,x \\le\r\n10^{18}\\)。\r\n显然，策略是让每个 \\(A_i\\)\r\n都尽量小。\r\n那么设 \\(B_i = A_i / i\\)，就有 \\(B_{i+1} = \\lfloor \\dfrac{A_i}{i+1} \\rfloor + 1 =\r\n\\lfloor \\dfrac{iB_i}{i+1}\\rfloor + 1 = B_i + 1 +\r\n\\lfloor{\\dfrac{-B_i}{i+1}}\\rfloor = B_i + 1 - \\lceil \\dfrac{B_i}{i+1}\r\n\\rceil\\)\r\n因为 \\(B_i\\) 约等于 \\(\\dfrac{X}{i}\\) ，设 \\(t = \\dfrac{B_i}{i+1}\\)，那么会有 \\(t(i+1)i = O(X)\\)。\r\n那么可以说明，在 \\(i &gt;\r\nX^{\\frac{1}{3}}\\) 的时候，\\(t = O(\r\nX^{\\frac{1}{3}})\\)。\r\n也就是说，\\(\\lceil \\dfrac{B_i}{i+1}\r\n\\rceil\\) 只有 \\(O(X^{\\frac{1}{3}})\\) 个本质不同的值！\r\n因为这玩意单调不增，所以最终会呈现若干个连续段。\r\n然后我想到这里不会算端点！\r\n考虑一个 \\(l\\)，设 \\(t = \\dfrac{B_l}{l+1}\\) ，我们想求出最大的\r\n\\(r\\) 满足 \\(x = \\lceil\\dfrac{B_l - (r - l)(x-1)}{r+1}\r\n\\rceil\\)\r\n化式子： \\[\r\n\\begin{aligned}\r\nx = \\lceil \\dfrac{B_l - (r + 1)(x - 1) + (l + 1)(x-1)}{r+1} \\rceil \\\\\r\n2x - 1 = \\lceil \\dfrac{B_l + (l+1)(x-1)}{r+1}\\rceil \\\\\r\nr + 1 = \\lfloor \\dfrac{B_l + (l+1)(x-1) - 1}{2x-2} \\rfloor\r\n\\end{aligned}\r\n\\]\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int P = 998244353,inv2 = (P + 1) / 2,inv6 = 166374059;typedef long long ll;ll n,nowb;inline ll cdiv(ll x,ll y) &#123; return (x + y - 1) / y;&#125;inline int S1(ll x) &#123; x %= P;return 1ll * x * (x + 1) % P * inv2 % P;&#125;inline int S2(ll x) &#123; x %= P;return 1ll * x * (x + 1) % P * (2 * x + 1) % P * inv6 % P;&#125;inline int calc(ll fr,ll d,ll l,ll r) // Bl = fr,Bi+1-Bi = d&#123;\tint res1 = 1ll * (fr % P) * (S1(r) - S1(l - 1) + P) % P;\tint res2 = 1ll * (d % P) * (S2(r) - S2(l - 1) + P) % P;\tint res3 = 1ll * (l % P) * (d % P) % P * (S1(r) - S1(l - 1) + P) % P;\treturn (1ll * res1 + res2 - res3 + P) % P;&#125;inline void Work()&#123;\tcin &gt;&gt; n &gt;&gt; nowb;\tint ans = 0;\tfor(ll l = 1,r;l &lt;= n;l = r + 1)\t&#123;\t\tll x = cdiv(nowb,l + 1);\t\tif(x == 1) r = n;\t\telse r = min(n,(nowb + (l + 1) * (x - 1) - 1) / (2 * x - 2) - 1);\t\t(ans += calc(nowb,1 - x,l,r)) %= P;\t\tnowb -= (r - l + 1) * (x - 1);\t&#125;\tcout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123;\tint T;\tcin &gt;&gt; T;\twhile(T--) Work();\treturn 0;&#125;\r\n事实上，上文中的 \"\\(B_i\\) 约等于\r\n\\(\\dfrac{X}{i}\\) \" 是可以严谨的给出一个\r\n上界的。\r\n因为 \\(A_i \\le X + \\sum_{j=2}^i j &lt; X +\r\n\\dfrac{1}{2}i(i+1)\\)\r\n所以 \\(B_i \\lt \\dfrac{X}{i} +\r\n\\dfrac{1}{2}(i+1)\\)。\r\n设 \\(L = X^{1/3}\\)。\r\n由此可以算出 \\(\\lceil \\dfrac{B_L}{L+1}\r\n\\rceil - 1\\) 处于 \\(O(L)\\)\r\n级别，即在 \\(i &gt; L\\) 的时候，\\(B_i - B_{i+1}\\) 的取值也只有 \\(O(L)\\) 个。\r\n于是总段数就是 \\(O(L)\\) 的了。\r\n","tags":["greedy"]},{"title":"ARC117E 题解","url":"/posts/3813915453/","content":"这题让我没什么头绪。想到过使用前缀和来转换，但 \\(\\pm 1\\)\r\n的变化量看上去非常难以处理。最后发现是一个从未见过的 DP 模型，果然 ARC\r\n题还是有学习价值的（前提是找得到好题）。\r\n\r\n题意：计数满足下列条件的长度为 \\(2n\\) 的序列 \\(a_1,a_2,\\dots,a_{2n}\\)：\r\n\r\n恰好包含 \\(n\\) 个 \\(+1\\) 和 \\(n\\) 个 \\(-1\\)。\r\n恰好有 \\(K\\) 对 \\((l,r) (1 \\le l \\le r \\le n)\\) 满足 \\(a_l + a_{l+1} + \\dots + a_r = 0\\)\r\n\r\n\\(1 \\le n \\le 30,1 \\le K \\le\r\nn^2\\)。\r\n求出 \\(a\\) 的前缀和 \\(S\\)，设 \\(O_i\\) 表示有多少个 \\(S\\) 等于 \\(i\\)，那么上述条件等价于：\\(S_0 = S_{2n} = 0,\\sum_i \\binom{O_i}{2} =\r\nK\\)。\r\n另一方面，\\(S_i - S_{i + 1} = \\pm\r\n1\\)。\r\n注意到这个 \\(K\\)\r\n的约束是关于每种值独立的，我们尝试设计关于值的 DP。\r\n要把值的限制和相差 \\(\\pm 1\\)\r\n的限制统一起来，我们尝试 DP 这个序列 S 的笛卡尔树。\r\n如下图：\r\n\r\n我们在这个笛卡尔树上，从上到下，一层一层的\r\nDP,每次填完一层的所有数。\r\n设 \\(dp_{i,j,k,c}\\) 表示一共填了\r\n\\(i\\) 个数，已经填的数在 \\(S\\) 序列上形成 \\(j\\) 个连续段，一共填了 \\(k\\) 层，当前的 \\(\\sum \\binom{O_i}{2} = c\\) 的方案数。\r\n考虑最后怎么求答案，因为最后强制 \\(S_0 =\r\nS_{2n} = 0\\)，我们考虑把 \\(S \\lt\r\n0\\) 和 \\(S \\ge 0\\)\r\n的部分拼接起来。\r\n注意到这两种情况是对称的，我们都可以用这个 DP 状态来表示。\r\n设 \\(g_{i,j,c} = \\sum_k\r\ndp_{i,j,k,c}\\)。\r\n具体地，因为拼的时候肯定是一段 \\(S \\ge\r\n0\\) 和一段 \\(S &lt; 0\\)\r\n交错，那么我们枚举 \\(S \\ge 0\\) 的个数\r\n\\(i\\)，段数 \\(j\\)，这一部分的 \\(\\sum_i \\binom{O_i}{2} =\r\nc\\)，那么最后的答案就是 \\[\r\n\\sum_{i,j,c} g_{i,j,c}g_{2n + 1 - i,j - 1,K - c}\r\n\\] 进一步地，我们发现 DP 中的 \\(k\\) 是没用的，可以去掉。\r\n我们考虑新一层加入了 \\(x\\)\r\n个数的影响。\r\n会出现一下三种情况：\r\n\r\n某两段之间的间隙被连接，需要占用一个位置，并把两个段合并成一个\r\n某个段间隙没有被连接，因为 \\(S\\)\r\n的变化连续，必须在这个间隙的两段贴两个数来拓展\r\n加入一个新的“山谷”\r\n\r\n重点在于考虑段数的变化。\r\n当前有 \\(j\\) 个连续段，就有 \\(j + 1\\)\r\n个空隙，每个空隙中都必须填数（因为我们是从上到下来填的数，每次填的是当前序列中的最小值，而我们限制了序列两端是\r\n\\(0\\)，所以两端的空隙也必须填数；另一方面，因为\r\n\\(S\\)\r\n的变化是连续的，所以中间的空隙不填数就不合法了）\r\n由上面三种情况整合可得，在单一个中间空隙中填入了 \\(a\\) 个数，会给总段数带来 \\(a - 2\\) 的变化量。两端则是 \\(a - 1\\)。\r\n整理式子可得新的连续段数为 \\(x -\r\nj\\)。\r\n考虑转移系数，相当于在 \\(j +1\\)\r\n个盒子里放 \\(x\\)\r\n个球，每个盒子都不为空，插板可得系数为 \\(\\binom{x - 1}{j}\\)\r\n综上所述，有转移 \\(dp_{i + x,x - j,c +\r\n\\binom{x}{2}} \\gets \\binom{x - 1}{j} dp_{i,j,c}\\)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 65;typedef long long ll;int n,k;ll C[N][N];ll dp[N][N][N * N];int main()&#123;\tcin &gt;&gt; n &gt;&gt; k;\tC[0][0] = 1;\tfor(int i = 1;i &lt;= n + 1;i++)\t&#123;\t\tC[i][0] = C[i][i] = 1;\t\tfor(int j = 1;j &lt; i;j++)\t\t\tC[i][j] = C[i - 1][j - 1] + C[i - 1][j];\t&#125;\tfor(int x = 0;x &lt;= n + 1;x++)\t\tif(x * (x - 1) / 2 &lt;= k)\t\t\tdp[x][x][x * (x - 1) / 2] = 1;\tfor(int i = 1;i &lt;= 2 * n + 1;i++)\t\tfor(int c = 0;c &lt;= k;c++)\t\t\tfor(int j = 1;j &lt;= min(n + 1,i);j++)\t\t\t&#123;\t\t\t\tll val = dp[i][j][c];\t\t\t\tif(val)\t\t\t\t&#123;\t\t\t\t\tfor(int x = j + 1;x &lt;= n + 1;x++)\t\t\t\t\t&#123;\t\t\t\t\t\tint nxt_c = c + x * (x - 1) / 2;\t\t\t\t\t\tif(i + x &gt; 2 * n + 1 || nxt_c &gt; k) continue;\t\t\t\t\t\tdp[i + x][x - j][nxt_c] += C[x - 1][j] * val;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\tll ans = 0;\tfor(int i = 0;i &lt;= 2 * n + 1;i++)\t\tfor(int j = 1;j &lt;= n + 1;j++)\t\t\tfor(int c = 0;c &lt;= k;c++)\t\t\t\tans += dp[i][j][c] * dp[2 * n + 1 - i][j - 1][k - c];\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["counting"]},{"title":"杭州中超联赛战前培训（上）","url":"/posts/2844372658/","content":"2022.11.29\r\n今天前两题其实都不算难，但因为打着打着想下班了，就只写了 T1 和 T3\r\n的一点分，没有认真思考 T2。\r\n\r\nT1 是个简单题：\r\n给出 \\(m\\) 条限制 \\((x,y)\\)，要求计数长度为 \\(n\\) 的排列 \\(p_1,p_2,\\dots,p_n\\) 使得对于每个限制 \\((x,y)\\) 均有 \\(p_x = y\\) 或 \\(p_y = x\\)。\\(\\Theta(n \\log n)\\)\r\n放在置换环上考虑，一个限制相当于一条无向边。\r\n显然有点度数大于 \\(2\\)\r\n就无解。有一个自环连接其他点也无解。\r\n否则每个联通块有四种情况：\r\n\r\n自环，舍去\r\n孤立点，需要被插入置换环\r\n一个整环，显然它不能对其他的点有影响，故将最后的答案 \\(\\times 2\\) 即可\r\n一条链，将其定向之后同孤立点没什么区别。\r\n\r\n唯一的例外是一个长度为 \\(2\\)\r\n的链单独成环的时候，对这条链定向没有意义。\r\n设有 \\(s_1\\) 条长度 \\(\\ge 3\\) 的链，\\(s_2\\) 条长度为 \\(2\\) 的链，\\(s_3\\) 个孤立点。\r\n则枚举恰好有 \\(i\\) 个长度为 \\(2\\) 的链单独成环，则剩下的 \\(s_2 - i\\) 个都不能单独成环。\r\n内层相当于一个错排，一共有 \\(s_1+s_2+s_3-i\\) 个点，其中 \\(1\\) 到 \\(s_2 -\r\ni\\) 不能单独成环。可以容斥。 d\r\n把式子写在一起推一推可以得出一个卷积做法，这里就不细讲了。（考场做法，但因为找环的\r\ndfs 写错了挂成 20)\r\n考虑先假设所有长度为 \\(2\\) 的链都有\r\n\\(2\\) 的系数，那么一个长度为 \\(2\\) 的链单独成环就有 \\(\\dfrac{1}{2}\\) 的系数。\r\n大家应该还记得，容斥是使用二项式定理证明的。\r\n我们容斥“一个东西不出现的方案数“，实际上是在说它的权值是\r\n0,此时容斥系数是 \\(-1\\)。\r\n现在出现一个东西的权是 \\(\\dfrac{1}{2}\\)，那容斥系数就是 \\(\\dfrac{1}{2} - 1 = -\\dfrac{1}{2}\\)。\r\n所以直接钦定有 \\(i\\)\r\n个二元链成自环，容斥系数就是 \\((\\dfrac{-1}{2})^i\\)。\r\nT2 是个拆贡献线段树题，到时候补。\r\nT3 是个套路题。\r\n输入 \\(n\\) 个字符串 \\(s_1,s_2,\\dots,s_n\\)。\r\n有一个初始为空的字符串 \\(T\\)，每次在后面等概率加入一个小写字母，当所有\r\n\\(s_i\\) 均在 \\(T\\) 中出现至少一次时，停止加入字符。\r\n问 \\(T\\) 的期望长度。\r\n\\(1 \\le n \\le 15,1 \\le \\sum |s_i| \\le\r\n10^5\\)\r\n设 \\(X_i\\) 表示 \\(s_i\\) 最早出现的时间。\r\n所求即为 \\(E(\\max(X_i))\\)。\r\n\\(\\min-\\max\\) 容斥一下，所求即为\r\n\\(E(\\min(X_i))\\)。\r\n这就是 [SDOI2017] 硬币游戏，我们把它重新推一遍。\r\n我们使用暴力的 \\(PGF\\) 推导。\r\n设 \\(F_i(x)\\) 表示 \\(s_i\\) 的 \\(PGF\\)，即 \\([x^t]F_i(x)\\) 表示 \\(X_i = t\\) 的概率。\r\n设 \\(G(x)\\)\r\n表示一直没有出现任何一个串的 \\(PGF\\)，即 \\([x^t]G(x)\\) 表示到了时间 \\(t\\) 还没有一个串出现的概率。\r\n首先 \\(G(1)\\)\r\n，即所有时间都没出现的概率之和，其实就是第一次有串出现的时间的期望，可以参考等式\r\n\\(E(X) = \\sum_{i \\ge 1} iP(X = i) = \\sum_{i\r\n\\ge 0} P(X &gt; i)\\) 进行理解。\r\n考虑列出 \\(F_i\\) 与 \\(G\\) 的关系式。\r\n首先有\r\n\\[ \\sum_{i=1}^n F_i(x) + G(x) = xG(x) +\r\n1\\]\r\n具体地，就是考虑 \\(g_i = f_{i +1} +\r\ng_{i+1}\\)，即当前没结束，下一步可能结束或没结束。\r\n再者，对于每个 \\(s_i\\)，不管当前的\r\n\\(T\\) 是什么，只要往后拼一个 \\(s_i\\)，必然会结束。\r\n唯一的问题是，我们可能还没有把一个 \\(s_i\\) 拼完，事情就结束了。\r\n也就是说，我们可能拼了一个 \\(s_i\\)\r\n的前缀，然后跟原来 \\(T\\)\r\n的某个后缀形成了一个 \\(s_j\\)，就贡献到了“直接往后拼一个 \\(s_i\\)\" 的方案当中去。\r\n设 \\(|s_i| = L\\)，则对于每个 \\(i\\)，有方程：\r\n\\[\r\nG(x)(\\dfrac{1}{|\\Sigma|})^mx^m = \\sum_{j=1}^n\\sum_{k=1}\r\n[s_i[1,\\dots,k]  =s_j[|s_j|-k+1,\\dots,|s_j|]]F_j(x) x^{m -\r\nk}(\\dfrac{1}{|\\Sigma|})^{m-k}\r\n\\]\r\n其中 \\(\\Sigma\\) 是字符集，这里\\(|\\Sigma| = 26\\)。\r\n将 \\(x = 1\\) 代入上面 \\(n + 1\\) 个式子，即可得到关于 \\(F_i(1)\\) 和 \\(G(1)\\) 的 \\(n +\r\n1\\) 个方程，高斯消元解方程即可。\r\n注意第二个式子的系数需要在一开始就处理好，因为我们要解 \\(2^n\\) 遍方程。\r\n时间复杂度为 \\(\\Theta(2^nn^3 + n\\sum\r\n|s_i|)\\) 或 \\(\\Theta(2^nn^3 + n^2\r\n\\sum|s_i|)\\) ，取决于预处理复杂度。 ## 2022.11.30\r\n得分：100+100+30=230,大众分。\r\n写一下第三题。\r\n给出一个 \\(n\\) 个点的无向环，第\r\n\\(i\\) 个点同第 \\((i + 1) \\bmod n\\) 个点之间，有一条权值为\r\n\\(w_i\\) 的无向边。（\\(0 \\le i \\le n - 1\\)）。\r\n再给出 \\(m\\) 条无向边 \\((u_i,v_i,w_i)\\) 。\r\n特殊条件：如果把这张图画在一个平面上，这 \\(m\\)\r\n条无向边不会在端点以外的地方相交，即开区间 \\((u_i,v_i)\\) 和 \\((u_j,v_j)\\) \\((i\r\n\\ne j)\\) 要么互相包含，要么无交。\r\n设 \\(\\operatorname{dis}(i,j)\\) 表示\r\n\\(i\\) 到 \\(j\\) 的最短路。\r\n求 \\(\\sum_{i=1}^n\\sum_{j=i+1}^n\r\n\\operatorname{dis}(i,j)\\)。\r\n\\(n,m \\le 2 \\times 10^5\\)。\r\n在平面图上的点对相关问题，考虑分治。\r\n取出一条不在环上的边 \\((x,y)\\)\r\n，整张图就被分成了两个部分，设两个部分的点集为 \\(L,R\\)。\r\n考虑对于 \\(u \\in L,v \\in R\\)\r\n统计贡献。\r\n因为 \\(u\\) 到 \\(v\\) 的最短路必定经过 \\(x,y\\) 中的至少一个，故 \\(dis(u,v) =\r\n\\min(dis(u,x)+dis(v,x),dis(u,y)+dis(v,y))\\)\r\n\\(dis(*,x)\\) 和 \\(dis(*,y)\\) 可以用 Dijkstra 跑出来。\r\n我们要求 \\(\\min\\)，考虑把贡献分类，即考虑什么时候\r\n\\(dis(u,x) + dis(v,x) \\le\r\ndis(u,y)+dis(v,y)\\)。\r\n移项变成 \\(dis(u,x) - dis(u,y) \\le dis(v,y)\r\n- dis(v,x)\\)\r\n左边就只和 \\(u\\) 有关，右边就只和\r\n\\(v\\) 有关。\r\n可以把 \\(dis(u,x) - dis(u,y)(u \\in\r\nL)\\) 和 \\(dis(v,y) - dis(v,x) (v \\in\r\nR)\\) 放入同一个数组中进行排序。然后从前往后扫描就可统计贡献。\r\n考虑如何向下递归。\r\n直接向下递归是不行的，因为对于 \\(u,v \\in\r\nL\\)，\\(u\\) 到 \\(v\\) 的最短路仍然可能经过 \\(R\\) 中的点。\r\n但我们注意到，这仍然会经过 \\(x\\) 和\r\n\\(y\\)。\r\n所以我们向下递归时，把 \\(x\\) 到\r\n\\(y\\) 的权值赋为 \\(dis(x,y)\\)，就包含了这种情况。\r\n但是，直接这样递归的复杂度是错的。\r\n因为我们的分治基于题目给出的 \\(m\\)\r\n条边，如果这 \\(m\\)\r\n条边分出来的两半都不太均匀，那么复杂度就会上去。\r\n一个策略是把这 \\(m\\)\r\n条边补成一个三角剖分（补上的边的边权设为 \\(\\infty\\))，然后每次找到使 \\(\\max(|L|,|R|)\\) 最小的 \\((x,y)\\)，递归下去，复杂度就是对的。\r\n证明的话，把环上的点均匀地放到一个圆上，找到一个包含圆心的三角形\r\n，这个三角形会把原图的点分成三个部分 \\(A,B,C\\)，有 \\(|A|+|B|+|C| = n + 3\\)。\r\n显然会有 \\(\\max(|A|,|B|,|C|) \\ge\r\n\\frac{n}{3}+1\\)，因为三角形包含圆心，也会有 \\(\\max(|A|,|B|,|C|) \\le \\frac{n}{2}+1\\)。\r\n所以我们找 \\(L,R\\)\r\n的时候，总能找到一对 \\(L,R\\) 满足 \\(\\frac{n}{3}+1 \\le |L| \\le\r\n\\frac{n}{2}+1\\)，所以你能找到一对 \\(L,R\\) 满足 \\(\\max(|L|,|R|) \\le \\frac{2}{3}n\\)\r\n最坏的情况下，\\(T(n) = T(\\frac{1}{3}n) +\r\nT(\\frac{2}{3}n) + O(n \\log n)\\)。可以分析出总复杂度为 \\(\\Theta(n \\log ^2 n)\\)。\r\n至于如何把现有的 \\(m\\)\r\n条边补成一个三角剖分。考虑找出一个度数为 \\(0\\) 的点（即不与这 \\(m\\) 条边的任何一条相连)，设其为 \\(x\\)，然后考察其左边和右边的点 \\(l,r\\)，如果 \\(l\\) 与 \\(r\\) 之间没有连边，就连上。\r\n这样，\\(l,r,x\\)\r\n就会形成一个三角形，且贴在环的边上，我们大可以把点 \\(x\\) 删掉，把 \\(l,r\\) 之间的的那条非环边变为新的环边（即将\r\n\\(l,r\\) 的度数都减 \\(1\\)），然后重复上述过程。可以类似拓扑排序，用队列维护当前度数为\r\n\\(0\\)\r\n的点。并用双向链表维护删点即可。\r\n代码如下：\r\nfor(int i = 0;i &lt; m;i++)&#123;\tE[e[i].x].insert(e[i].y),\tE[e[i].y].insert(e[i].x);\t++deg[e[i].x];++deg[e[i].y];&#125;\tqueue&lt;int&gt; Q;\tfor(int i = 0;i &lt; n;i++)\t\tif(!deg[i]) Q.push(i);\tfor(int i = 0;i &lt; n;i++)\t\tL[i] = i - 1,R[i] = i + 1;\tL[0] = n - 1;R[n - 1] = 0;\twhile(!Q.empty())\t&#123;\t\tint x = Q.front();Q.pop();\t\tint lef = L[x],righ = R[x];\t\tR[lef] = righ;L[righ] = lef;\t\tif(lef &gt; righ) swap(lef,righ);\t\tif(lef == righ || (lef == 0 &amp;&amp; righ == n - 1) || righ - lef == 1) continue;\t\tif(!E[lef].count(righ))\t\t&#123;\t\t\tE[lef].insert(righ);E[righ].insert(lef);\t\t\te.push_back(Edge(lef,righ,inf));\t\t&#125;\t\telse\t\t&#123;\t\t\tif((--deg[lef]) == 0) Q.push(lef);\t\t\tif((--deg[righ]) == 0) Q.push(righ);\t\t&#125;\t&#125;\r\n2022.12.1\r\n得分：0+85+0，T2 因为有一个地方写挂痛失 \\(15\\) 分，差点就签到成功了。\r\n11.30 的 T3 是赛时写完 T2 之后改的。\r\n2022.12.2-2022.12.6\r\n模拟赛没有什么可改的题，但讲课的课件还是有很多不错的题的。\r\n会随缘更新一些学到的东西。\r\n1. 多项式点值平移\r\n对于一个 \\(n\\) 次多项式 \\(f\\)，给出 \\(f(0),f(1),\\dots,f(n)\\) ，现在需要求出 \\(f(m),f(m+1),\\dots,f(m+n)\\)。对 \\(998244353\\) 取模。\r\n\\(1 \\le n \\le 1.6 \\times 10^5,n \\lt m \\le\r\n10^8\\)。\r\n考察拉格朗日插值的式子：\r\n\\[\r\n\\begin{aligned}\r\nf(m + t) = \\sum_{i=0}^{n}f(i)\\prod_{j != i}\\dfrac{m + t - j}{i-j} \\\\\r\n= \\sum_{i=0}^{n} \\dfrac{f(i)(-1)^{n-i}}{i!(n-i)!} \\prod_{j != i}\r\n(m+t-j)! \\\\\r\n= \\dfrac{(m+t)!}{(m-n+t-1)!}\\sum_{i=0}^n\r\n\\dfrac{f(i)(-1)^{n-i}}{i!(n-i)!} \\dfrac{1}{m+t-i} \\\\\r\n\\end{aligned}\r\n\\]\r\n后半部分显然是个卷积的形式，唯一的不足是后面的求和上界是 \\(n\\) 而不是 \\(t\\)。\r\n因为 \\(t\\) 可能小于 \\(n\\),我们要化成卷积的形式，最方便的当然是取某个序列的第\r\n\\(n + t\\)\r\n项作为答案，虽然我们还不知道这个序列是什么。\r\n进一步地，我们把 \\(\\dfrac{1}{m+i}\\)\r\n这个序列也类似地平移 \\(n\\)\r\n位,具体地，我们设\r\n$$\r\n\\[\\begin{aligned}\r\nA_i = \\dfrac{f(i)(-1)^{n-i}}{i!(n-i)!} (i \\in [0,n]) \\\\\r\n\r\nB_i = \\dfrac{1}{m-n+i} (i \\in [0,2n]) \\\\\r\n\\end{aligned}\\]\r\n$$\r\n然后令 \\(C = A * B\\)，取 \\(C_{n+t}\\) 就是 \\(f(m+t)\\) 的后面那个 \\(\\sum\\)。\r\n一遍卷积即可，时间复杂度 \\(\\Theta(n \\log\r\nn)\\)。\r\n2. P5469 机器人\r\n从初三的暑假到高一上学期，计数水平确乎是有提升的，也有可能是思路变得更加敏捷，总而言之，看懂机器人了。\r\n题意：\r\n从左到右有一排长度为 \\(n\\)\r\n的柱子，设柱子 \\(i\\) 的高度为 \\(h_i\\)。有两种机器人，P\r\n型机器人和 Q 型机器人。\r\nP\r\n型机器人从某个柱子出发，会一直向左走，直到走到尽头或者下一个柱子的高度大于起点柱子。\r\nQ\r\n型机器人从某个柱子出发，会一直向右走，直到走到尽头或者下一个柱子的高度大于等于起点柱子。\r\n如果 \\(\\forall s \\in\r\n[1,n]\\)，把两个机器人放在 \\(s\\)\r\n处，让他们走，他们走过的格子数量之差的绝对值不超过 \\(2\\)。那么这个 \\(h_i\\) 序列就被称作合法的。\r\n现在限定 \\(h_i \\in\r\n[A_i,B_i]\\)（\\(A,B\\)\r\n给定）计数有多少个合法的 \\(h_i\\)。对\r\n\\(10^9 + 7\\) 取模。\r\n\\(n \\le 300,1 \\le A_i \\le B_i \\le\r\n10^9\\)。\r\n题目中的机器人在走到第一个大于/大于等于起点的位置就会停止，我们不妨考虑，如果把起点设在整个数列最靠右的最大值会发生什么。设这个位置为\r\n\\(t\\)。\r\n显然，P 型机器人会一直向左，Q\r\n型机器人会一直向右，直到走到端点，而在 \\(t\\)\r\n的左边或右边，机器人无论怎么走都无法跨过 \\(t\\)。\r\n所以我们借助这个最大值，把一个区间拆成了两个子区间，和一个断点的决策。（这是十分重要的思想，通过特殊点的表现来拆分问题）\r\n于是考虑设计一个 \\(dp[l][r]\\)\r\n表示区间 \\([l,r]\\)\r\n的答案，转移枚举最大值的位置，因为其与两边距离之差不超过 \\(2\\)，有效的转移不多，在 \\(n \\le 300\\) 时只有 \\(2518\\) 个有效区间。\r\n但枚举最大值本身还会带来限制，子区间的最大值必须小于或小于等于枚举的端点\r\n所以我们还要记录一维 \\(v\\)\r\n表示当前转区间的最大值，状态就是 \\(dp[l][r][v]\\)，设其前缀和为 \\(sum[l][r][v] = \\sum_{i=1}^v\r\ndp[l][r][v]\\)\r\n那么转移就是 \\[\r\n\\begin{aligned}\r\ndp[l][r][v] &amp;= \\sum_{\\text{$t$ is vaild} } ((\\sum_{i=1}^{v}dp[l][t -\r\n1][i]) \\times (\\sum_{i=1}^{v-1} dp[t + 1][r][i]))[a_t \\le v \\le b_t] \\\\\r\n&amp;= \\sum_{\\text{$t$ is vaild}} sum[l][t - 1][v] \\times sum[t +\r\n1][r][v - 1][a_t \\le v \\le b_t]\r\n\\end{aligned}\r\n\\] 但 \\(v\\)\r\n有可能很大，如果直接实现这个东西，显然是无法满分的。\r\n我们思考 \\(a = 1,b = 10^9\\)\r\n那档部分分，现在相当于 \\(v\\)\r\n的取值不受限制。\r\n考虑一个 \\(l = r\\) 的区间，它满足\r\n\\(dp[l][r][v] = 1\\)，其前缀和满足 \\(sum[l][r][v] = v\\)\r\n考虑一个 \\(l + 1 = r\\)\r\n的区间，他就是如上的两个 \\(sum\\)\r\n点乘的结果，显然是个二次函数。\r\n归纳地，设 \\(F_{l,r}(x) =\r\nsum[l][r][x]\\) 是一个关于 \\(x\\)\r\n的函数，我们可以证明这是个次数不超过 \\(r - l +\r\n1\\) 次的多项式，对着 \\(dp\\)\r\n方程考虑即可得证。\r\n也就是说，我们只要算出了 \\(sum[1][n][x]\\) 在 \\(x = 0,1,\\dots,n\\)\r\n的取值，就能通过插值算法得出 \\(sum[1][n][10^9]\\)。\r\n我们转而考虑正解，此时 \\(a,b\\)\r\n不一样，哪怕是 \\(i\\) 固定，每个 \\(v\\) 都有可能可以被取或者不能被取，这取决于\r\n\\(a\\) 和 \\(b\\) 的限制。\r\n这意味着答案不再是个多项式。\r\n但我们考虑把 \\(a,b\\)\r\n按照数轴上离散化的方法处理。\r\n那么对于两个特殊值 \\(vals_i,vals_{i+1}\\) 形成的区间 \\([vals_i,vals_{i+1})\\) 中的 \\(v\\) ，在 \\(i\\)\r\n一定时决策都是一样的，要么取，要么不取，这样答案就是一个多项式，能不能取的决策无非是多乘一项，少乘一项的区别。\r\n值得注意的是，我们在 \\([vals_i,vals_{i+1})\\) 的值域中考虑 \"\\(dp[l][r][v]\\) 的前缀和\" 时，它仍然是从\r\n\\(1\\) 开始求和的，而非 \\(vals_i\\)，所以我们需要一个位置来保存在更小的值域区间内\r\n\\(dp[l][r][v]\\)\r\n的前缀和，这在代码里体现为 \\(dp[l][r][0]\\)。\r\n3.P4654 [CEOI2017] Mousetrap\r\n有题号就不放题意了。\r\n虽然看着是个博弈题，但跟博弈其实关系不大，我们只需通过一定的方法，刻画这两个人在不同局面下的决策即可。\r\n我们考虑把陷阱点作为根，那么老鼠就是要向上一直跳，然后跳到根。\r\n容易发现，如果老鼠跳着跳着，转头向下，进入了某棵子树，那他就只能在某个叶子处等待收编，因为管理员不清理他就上不去，而且老鼠能动就必须要动。\r\n所以，管理员大可以把他想堵的边都堵住了之后，再来把老鼠通往陷阱的路径清扫干净。\r\n而老鼠进入子树再出来的代价只同他在哪棵子树有关。\r\n故可以设 \\(f[x]\\) 表示老鼠进入了\r\n\\(x\\)\r\n子树后再把他赶出来的最小代价。\r\n老鼠在点 \\(x\\) 时，他显然会走 \\(f[y]\\) 最大的儿子 \\(y\\)。\r\n但管理员显然会堵上这个儿子，所以老鼠会走 \\(f[y]\\) 次大的儿子。\r\n设 \\(num_x\\) 表示 \\(x\\) 的儿子个数，则 \\[\r\nf[x] = \\operatorname{2ndmax}_{y \\in son(x)}(f[y]) + num_x\r\n\\] 有 \\(num_x - 1\\)\r\n个儿子要堵上，有 \\(1\\)\r\n个儿子在最后要疏通，所以代价是 \\(num_x\\)。\r\n但是，对于一次博弈，老鼠可以先向上跳一点，再一头扎进一棵子树。\r\n但老鼠会钻进哪棵子树？\r\n这个影响因素其实很多，并不是简单的把所有代价取 \\(\\max\\) 就是最优解的。\r\n我们考虑二分答案，设当前有 \\(k\\)\r\n个可用操作。\r\n那么假设你老鼠打算在 \\(x\\)\r\n点，一头扎进某个子树 \\(y\\)。\r\n设把 \\(x\\)\r\n以上的路径的邻域全部堵住的代价是 \\(sum[x]\\)。\r\n则对于 \\(sum[x] + f[y] \\le k\\)\r\n的子树，其实我们是不需要堵住他的，但大于则需要，这本身又会花费一个操作（从这个角度来看，答案确实需要二分，不能直接求，因为决策比想象中复杂）\r\n另一方面，假设点 \\(x\\) 一共有 \\(cnt\\) 个 \\(sum[x]\r\n+ f[y] \\gt k\\) 的子树，那么在老鼠到达点 \\(x\\) 之前，这些树就要全部堵上。\r\n把这两个条件判断之后，就可以充要地判定 \\(k\\) 次操作是否可以收编老鼠。\r\n然后这题就做完了。\r\n4.P4202 [NOI2008] 奥运物流\r\n有题号就不放题意了。\r\n先考虑如何计算 \\(R(i)\\)\r\n如果原图是一个环，那么 有 \\(R(i) = C_i +\r\nkR(i \\bmod n + 1)\\)\r\n手动消元可得 \\(R(1) = \\dfrac{\\sum_{i}C_i\r\nk^{i-1}}{1-k^n}\\)。\r\n另一方面，如果原图是个内向树，容易推出 \\(R(1) = \\sum_i C_i k^{dep(i)}\\)\r\n综合以上两点可以得到 \\(R(1) = \\dfrac{\\sum_i\r\nC_i k^{dis(i \\to 1)}}{1-k^{len}}\\)\r\n具体地，可以先把环外的内向树都递推上来，再放到环上考虑，即可证明这一点。\r\n显然，我们改一个点的后继，最优的方法是直接改到 \\(1\\) 号节点。\r\n考察原来的式子，我们可以决定的是 \\(dis(i\r\n\\to 1)\\) 和环长 \\(len\\)。\r\n我们不妨枚举环长，那么此时的环就是可以确定的，就是 \\(1\\) 号点后面若干个点。\r\n我们大可以把 \\(1\\)\r\n号点的出边忽略，它对答案没有影响。\r\n接下来变成内向树上的问题。\r\n我们设 \\(dp[u][m][d]\\) 表示在 \\(u\\) 子树内，用了 \\(m\\) 次修改机会，点 \\(u\\) 的深度现在为 \\(d\\) 的最优答案。\r\n树上背包转移即可。\r\n5. CF1119F Niyaz and Small\r\nDegrees\r\n有题号就不放题意了。\r\n我们考虑单个答案怎么求。\r\n容易想到设 \\(f[x][0],f[x][1]\\) 表示\r\n\\(x\\) 与 \\(fa[x]\\) 之间的边割或不割。dp\r\n时，先把这些状态的值都设成 \\(\\sum_{y}\r\n\\min(f[y][1] + w,f[y][0])\\)\r\n，但这个和式对应的方案不一定是合法的，也就是说，我们要把一些 \\(dp[y][1] + w &gt; dp[y][0]\\) 的儿子 \\(y\\) ，由不割 \\((y,x)\\) 强行变为割掉 \\((y,x)\\)\r\n，并将答案加上对应的增量。我们可以开个堆，来取出增量前若干小的儿子 \\(y\\) 做这个事情，这样就可以 \\(\\Theta(n^2 \\log n)\\) 完成这次树形 dp。\r\n我们考虑，随着度数限制 \\(D\\)\r\n的增大，问题的规模是在变小的，具体地，对于 \\(deg[x]\\) 已经不超过 \\(D\\) 的点 \\(x\\)，我们树形 \\(dp\\)\r\n时其实没必要经过它，我们只关心它和它某个邻居之间的那条边要不要被割，我们可以把它当成一个孤立点，并把它的信息放到邻域上。\r\n具体地，有如下代码：\r\ninline void Destroy(int x)&#123;\tfor(auto it : G[x])\t&#123;\t\tint y = it.first,w = it.second;\t\tif(deg[y] &lt;= D) break;\t\tH[y].push(w);\t&#125;&#125;\r\n接下来我们对度数大于等于 \\(D\\)\r\n的点，做如上的树形 dp 即可。\r\n事实上，这样的复杂度就是 \\(\\Theta(n \\log\r\nn)\\)。\r\n具体地，可以考虑等式 \\(\\sum_{i=1}^n \\sum_{D\r\n= 0}^{n - 1} [deg_i \\gt D] = \\sum_{i=1}^n deg_i = 2n-2\\)。\r\n在代码实现上，我们把所有邻居按度数从大到小排序，遍历到 \\(\\le D\\) 的点就直接 break 而非 continue\r\n。\r\n在 dp\r\n的时候，我们维护大根堆，当堆的大小超过限制时就把堆顶删去，这样可以时刻保证堆的大小不超过\r\n\\(deg[x] -\r\nD\\)，此时我们的堆中会删除一些值，但删完之后，我们也必须把它加回来，因为这里面包含了一些孤立点的信息。\r\n这些都是为了保证复杂度而需要注意的细节。\r\n","tags":["游记"]},{"title":"洛谷 P8340 山河重整 题解","url":"/posts/313682301/","content":"一道很有启发意义的数数题。\r\n\r\n看到这题之后，当然是首先从 \\(O(n^2)\\) 开始想起。\r\n如果我们从小到大地决策某个数是否被加入，那么现在已经被加入的数字，在值域上能表示的一定是一段前缀，即一个形如\r\n\\([1,r]\\) 的区间，那么可以设计状态\r\n\\(dp_{i,r}\\) 表示加入了前 \\(i\\) 个数，当前能表示的区间为 \\([1,r]\\) 的方案数。\r\n在加入数 \\(i + 1\\)\r\n之后，能表示的区间变为 \\([1,r] \\cup [i + 1,r +\r\ni + 1]\\)，转移合法当且仅当 \\(r \\ge\r\ni\\)，也就是说，对于 \\(r \\ge i\\)\r\n的 \\(dp_{i,r}\\)，其可以转移到 \\(dp_{i+1,r+i+1}\\)。\r\n分析上述的 \\(dp\\)\r\n过程，可以得到一个很重要的结论，即 \\(\\forall i\r\n\\in [0,n),\\sum_{j \\in S,j \\le i} \\gt i\\)。这个结论跟上述 dp\r\n的转移式是等价的。\r\n对每个 \\(i\\)\r\n都要求其合法是比较困难的，我们不如计数不合法的方案数。\r\n因为不合法的位置可能有很多，一个计数的套路是考察第一个不合法的位置。\r\n设考虑位置 \\([1,i]\\) 且位置 \\(i\\) 为第一个不合法位置的方案数为 \\(f_i\\)。\r\n也就是说，满足 \\([1,i]\\)\r\n均可被拼出，但 \\(i + 1\\)\r\n无法被拼出。\r\n通过上面的结论，我们可以知道 \\([1,i]\\) 中被选中的数的和恰好为 \\(i\\)。\r\n为了保证 \\(i\\)\r\n是第一个不合法的位置，我们可以用满足上述条件的所有方案，减去第一个不合法位置为\r\n\\(j(j &lt; i)\\) 的方案数。\r\n形式化地说，\\(f_i = g_i -\r\n\\sum_{j=1}^{i-1}f_j \\times \\operatorname{val}(j,i)\\)，其中 \\(\\operatorname{val}(j,i)\\)\r\n是转移的系数，因为根据 \\(f_j\\)\r\n的意义，\\(j + 1\\) 不能填数，且 \\(1 \\sim j\\) 中的数和为 \\(j\\)，那么 \\(val(j,i)\\) 就是在 \\([j+2,i]\\) 中选数，使这些数的和为 \\(i - j\\) 的方案数。\r\n先考虑 \\(g_i\\) 怎么求，显然，它是\r\n\\(i\\) 的\r\n互异拆分数，也就是将 \\(i\\) 拆分为若干个不同的数的和的方案数。\r\n回顾互异拆分数的经典做法，我们知道，\\(n\\) 只会被拆为最多 \\(\\sqrt{2n}\\) 个数，我们可以据此设计 DP。\r\n将 \\(n\\) 拆成若干个数 \\(p_1,p_2,\\dots,p_k\\) 的时候，我们会限制\r\n\\(p_1 &gt; p_2 &gt; \\dots &gt; p_k\\)\r\n来保证计数不重复，但这个限制本身很麻烦，我们考虑差分数组 \\(d_i = p_i - p_{i+1},d_k =\r\np_k\\)，那我们就只需要保证 \\(d_i &gt;\r\n0\\) 就可以了，而每个 \\(d_i\\)\r\n对全局的贡献就是 \\(d_i \\times\r\ni\\)。那么每个 \\(i\\)\r\n就相当于一个大小为 \\(i\\) 的物品，这个\r\nDP 则相当于完全背包（因为 \\(d_i\\)\r\n没有上界），因为 \\(i \\in\r\n[1,\\sqrt{2n}]\\)，我们对这些 \\(i\\) 跑完全背包即可求出拆分数。\r\n代码如下：\r\nf[0] = 1;int lim = sqrt(2 * n);for(int i = lim;i &gt;= 1;i--) // 倒序枚举 i，方便滚动数组&#123;\tfor(int j = n;j &gt; i;j--) f[j] = f[j - i];\tfor(int j = i;j &gt;= 1;j--) f[j] = 0;\tfor(int j = i;j &lt;= n;j++)        Plus(f[j],f[j - i]); // 完全背包&#125;\r\n回到上面的式子，我们考虑 \\(\\sum_{j=1}^{i-1}f_j \\times\r\n\\operatorname{val}(j,i)\\) 怎么处理，假设我们已经知道了 \\(f_j\\)，那么我们要解决的是 \\(\\operatorname{val}(j,i)\\)，也就是在 \\([j + 2,i]\\) 中选数，使得它们的和为 \\(i - j\\) 的方案数。\r\n假设我们已经确定了 \\(j + 2 \\sim i\\)\r\n中选多少个数，设其为 \\(c\\)，那么我们可以把这其中的所有数全部减去\r\n\\((j + 2)\\)，然后接着做互异拆分数的\r\nDP,事实上，我们只要把 \\(f_j\\)\r\n贡献到数组中 \\(j + (j + 2) \\times c\\)\r\n的位置，那么最后提取背包数组中位置 \\(i\\) 的值就可以得到这个 \\(j\\) 的贡献。\r\n因为我们是倒序枚举的 \\(i \\in\r\n[1,\\sqrt{2n}]\\)（注意这里的 \\(i\\) 是完全背包中的 \\(i\\)），所以枚举到某个数的时候，我们不妨假设其就是\r\n\\(c\\)\r\n，在后续的枚举中，我们会把其他的物品（也就是其他的 \\(d_i\\) 一步一步加入进去），DP\r\n完了之后，这个方案自然会被贡献到正确的位置。\r\n上述两段可以结合代码理解。\r\n另一个问题是，我们在求 \\(f_i\\)\r\n的时候，假设 \\(f_j \\in [1,i - 1]\\)\r\n已经被算出来了，那我们怎么实现这个算法呢？\r\n事实上，\\(f_j\\) 能贡献到 \\(f_i\\) ，说明 \\(j\r\n+ (j + 2) \\le i\\)，即 \\(j \\le\r\n\\dfrac{i}{2}\\)。也就是说，如果要求 \\([1,n]\\) 的 \\(f_i\\)，我们可以先递归求出 \\([1,\\dfrac{n}{2}]\\) 的 \\(f_i\\)，再用上述做法求出后半部分的 \\(f_i\\) 即可。\r\n代码如下：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;int n,P;inline void Plus(int &amp;x,const int &amp;y) &#123; x += y;if(x &gt;= P) x -= P;&#125;int f[N],t[N];void Solve(int n)&#123;\tif(n &lt;= 1) return;\tint lim = sqrt(2 * n);\tSolve(n &gt;&gt; 1);\tfor(int i = 0;i &lt;= n;i++) t[i] = 0;         \tfor(int i = lim;i &gt;= 1;i--)\t&#123;\t\tfor(int j = n;j &gt;= i;j--) t[j] = t[j - i];\t\tfor(int j = i - 1;j &gt;= 0;j--) t[j] = 0;\t\tfor(int j = 0;j + (j + 2) * i &lt;= n;j++)\t\t\tPlus(t[j + (j + 2) * i],f[j]);\t\tfor(int j = i;j &lt;= n;j++) Plus(t[j],t[j - i]);\t&#125;\tfor(int i = (n &gt;&gt; 1) + 1;i &lt;= n;i++)\t\tPlus(f[i],P - t[i]);&#125;int Pow2[N];int main()&#123;  \tPow2[0] = 1;\tfor(int i = 1;i &lt;= n;i++) Pow2[i] = (Pow2[i - 1] + Pow2[i - 1]) % P;\tf[0] = 1;int lim = sqrt(2 * n);\tfor(int i = lim;i &gt;= 1;i--)\t&#123;\t\tfor(int j = n;j &gt; i;j--) f[j] = f[j - i];\t\tfor(int j = i;j &gt;= 1;j--) f[j] = 0;\t\tfor(int j = i;j &lt;= n;j++)\t\t\tPlus(f[j],f[j - i]);\t&#125;\tSolve(n);\tint ans = 0;\tfor(int i = 0;i &lt; n;i++)\t\tans = (ans + 1ll * f[i] * Pow2[n - i - 1] % P) % P;\tans = (Pow2[n] + P - ans) % P;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["counting","sqrt"]},{"title":"洛谷 P3642 烟火表演 题解","url":"/posts/2791595810/","content":"本题就当是对 Slope trick 的入门了。\r\n\r\n首先考虑 \\(\\sum w\\) 不大的情况。\r\n设 \\(f_i(x)\\) 表示在 \\(i\\) 子树内，点燃时间为 \\(x\\) 的最小代价。\r\n那么考虑合并 \\(f_i\\) 和一个儿子\r\n\\(f_{son}\\) ，则有 \\(f_i(x) \\gets f_i(x) + \\min_{y \\le x} \\{f_{son}(y)\r\n+ |w - x + y|\\}\\) 。（\\(w\\) 是\r\n\\(i\\) 与 \\(son\\) 之间的边权）\r\n我们令 \\(G_{son}(x) = \\min_{y \\le x}\r\n\\{f_{son}(y) + |w - x + y|\\}\\)。\r\n可以证明，\\(f_i(x)\\) 是关于 \\(x\\)\r\n的下凸函数，且每一段的斜率均为整数。\r\n设 \\([L,R]\\) 表示 \\(f_{son}(x)\\) 斜率为 \\(0\\) 的那一段的左右端点的横坐标，那么 \\(G_{son}(x)\\) 变化如下： \\[\r\nG_{son}(x) = \\begin{cases} f_{son}(x) + w ,x \\lt L \\\\\r\nf_{son}(L) + w - (x - L),L \\le x \\lt L + w \\\\\r\nf_{son}(L),L + w \\le x \\lt R + w \\\\\r\nf_{son}(x) + (x - R) - w,x \\ge R + w \\\\\r\n\\end{cases}\r\n\\] 具体分析如下：\r\n对于第一种情况：因为在 \\(x &lt; L\\)\r\n处 ，\\(f_{son}(x)\\) 的斜率小于等于\r\n\\(-1\\)，即修改 \\(son\\) 以下的边的代价 \\(\\ge 1\\)，那肯定不如直接修改 \\(w\\) （代价恰为 \\(1\\)），所以在这里直接把 \\(w\\) 修改到 \\(0\\)，然后取出在 \\(x\\) 点的函数值。\r\n对于第二种情况：函数在 \\(f_{son}(L)\\)\r\n处取到最小值，我们跟第一种情况的理由一样，能够修改 \\(w\\) 就别修改 \\(f_{son}(x)\\) 中的 \\(x\\) ，所以 \\(f_{son(x)}\\) 中的 \\(x\\) 一定 \\(\\ge\r\nL\\)，而为了让 \\(w\\)\r\n修改的代价尽量小，我们直接把 \\(w\\) 拉到\r\n\\(x - L\\) 。这样就是最优的了。\r\n第三种情况较为简单，第四种情况与第一种类似，就不再赘述。\r\n对于这种斜率为整数的下凸壳，我们可以通过维护拐点和最右边的直线来表示这个凸壳。\r\n\r\n就像上图，我们只需维护所有的红点和红线即可。\r\n我们默认每三个相邻拐点所表示的两条直线的斜率差都是 \\(1\\)，如果不是，那我们就多次加入同一个拐点。\r\n如何求一个点 \\(L\\) 的函数值 \\(f_{son}(L)\\) 呢？因为拐点的斜率差都是 \\(1\\)，我们用 \\(f(0)\\) 减去在 \\(L\\) 之前的所有拐点的横坐标即可。\r\n如何执行 \\(f_i(x) \\gets f_i(x) +\r\nG_{son}(x)\\)\r\n呢？还是因为拐点序列的性质，我们直接把二者的拐点序列按顺序拼接起来即可。\r\n现在我们有了这个凸壳模型，我们考虑上面的操作是如何把 \\(F_{son}(x)\\) 变为 \\(G_{son}(x)\\) 的。\r\n首先，把 \\(L\\) 左边的部分向上平移\r\n\\(w\\)，然后把 \\([L,R]\\) 这一部分整体向右平移 \\(w\\)，并在 \\([L,L\r\n+ w]\\) 处插入一条斜率为 \\(-1\\)\r\n的直线，把原函数 \\(&gt; R + w\\)\r\n的部分的斜率都变为 \\(1\\)。\r\n注意到函数的斜率最大值也只有 \\(1\\)，我们甚至不需要“维护那条红线”，处理所有的拐点即可。\r\n考虑这些操作怎么办：\r\n\r\n向上平移 \\(w\\)，这等价于 \\(f(0) \\gets f(0) + w\\)，而 \\(f(0)\\)\r\n不论是从这里来看，还是从定义上看，都显然是所有边权的和，所以这个很简单。\r\n把大于 \\(R + w\\) 的部分的斜率都变为\r\n\\(1\\)。这个可以在所有的 \\(G_{son}(x)\\) 都并入 \\(f_i(x)\\) 之后再行处理。注意到每个 \\(G_{son}(x)\\) 有且仅有一个斜率为正的拐点\r\n\\(R + w\\)，假设 \\(i\\) 的儿子有 \\(k_i\\) 个，那么合并完之后就有 \\(k_i\\) 个斜率为正的拐点，那么弹出 \\(k_i - 1\\) 个最大的拐点即可。\r\n把 \\([L,R]\\) 向右平移一个 \\(w\\) ，这个只需要删除拐点 \\(L,R\\)，加入拐点 \\(L + w,R + w\\) 即可。\r\n插入一条斜率为 \\(-1\\)\r\n的直线，这个在第三项中其实就已经处理完了。\r\n\r\n以上操作都可以用一个可合并的大根堆维护，写个左偏树即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6e5 + 5;typedef long long ll;struct node&#123;\tint lc,rc,dis;\tll val;&#125;tr[N];int Merge(int x,int y)&#123;\tif(!x || !y) return x + y;\tif(tr[x].val &lt; tr[y].val) swap(x,y);\ttr[x].rc = Merge(tr[x].rc,y);\tif(tr[tr[x].lc].dis &lt; tr[tr[x].rc].dis) swap(tr[x].lc,tr[x].rc);\ttr[x].dis = tr[tr[x].rc].dis + 1;\treturn x;&#125;inline int Pop(int x) &#123; return Merge(tr[x].lc,tr[x].rc);&#125;int rt[N];int n,m;int fa[N],C[N],sons[N];int main()&#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 2;i &lt;= n + m;i++)\t\tcin &gt;&gt; fa[i] &gt;&gt; C[i],++sons[fa[i]];\tll ans = 0;\tint tot = 0;\tfor(int i = n + m;i &gt; 1;i--)\t&#123;\t\tll l = 0,r = 0; // 维护斜率为 0 的那些线段\t\tif(i &lt;= n) // 非叶\t\t&#123;\t\t\twhile(--sons[i]) rt[i] = Pop(rt[i]);\t\t\tr = tr[rt[i]].val;rt[i] = Pop(rt[i]);\t\t\tl = tr[rt[i]].val;rt[i] = Pop(rt[i]);\t\t&#125;\t\ttr[++tot].val = l + C[i];\t\ttr[++tot].val = r + C[i];\t\trt[i] = Merge(rt[i],Merge(tot,tot - 1));\t\trt[fa[i]] = Merge(rt[fa[i]],rt[i]);\t&#125;\tfor(int i = 2;i &lt;= n + m;i++) ans += C[i]; // f(0)\twhile(sons[1]--) rt[1] = Pop(rt[1]);\twhile(rt[1]) ans -= tr[rt[1]].val,rt[1] = Pop(rt[1]);\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["DP","Slope trick"]},{"title":"CF1229F 题解","url":"/posts/2322247108/","content":"CF1229F 题解\r\n除了官方题解，我在百度上还没有搜到关于这题比较详细的描述，故写篇题解造福社会，希望对读者有益。\r\n题意：给出 \\(n\\) 个数 \\(a_i,l_i,r_i\\)，在一个环上均匀分布着 \\(n\\) 个点，每个点初始有 \\(a_i\\)\r\n张牌。你一次操作可以选择一个点，将其上的一张牌移到与其相邻的位置，花费\r\n\\(1\\)\r\n的代价。求最少的代价，使得调整完后，第 \\(i\\) 个点上的牌数在 \\([l_i,r_i]\\) 之间。\r\n\\(1 \\le n \\le 3.5 \\times\r\n10^4\\)。\r\n\r\n\r\n首先考虑断环为链。\r\n具体地，设 \\(x_i\\) 表示由 \\(i\\) 向 \\(i+1\\) 运送的牌数（\\(x_i\\) 可以为负，这等价于由 \\(i+1\\) 向 \\(i\\) 运送 \\(-x_i\\) 张牌），特别地，\\(x_n\\) 为由 \\(n\\) 向 \\(1\\) 运送的牌数。\r\n那么断环为链，就是钦定 \\(x_1\\)\r\n为一个特定的值 \\(m\\)，即把这条边的决策先做掉。\r\n那么向后做的时候，设 \\(f_i(t)\\)\r\n表示钦定 \\(x_i =\r\nt\\)，且第二张，第三张，...，第 \\(i -\r\n1\\) 张牌均已经满足条件的最小代价。\r\n考虑 \\(f_i(x)\\) 如何从 \\(f_{i-1}(y)\\) 转移过来。\r\n首先，会有限制：\\(a_i - x_i + x_{i - 1} \\in\r\n[l_i,r_i]\\)。\r\n即 \\(l_i - a_i + x_i \\le x_{i-1} \\le r_i -\r\na_i + x_i\\)。（特别地，\\(l_1-a_1 + x_1\r\n\\le x_n \\le r_1 - a_1 + x_1\\)）\r\n令 \\(dl_i = a_i - l_i,dr_i = r_i -\r\na_i\\)\r\n对应到 \\(f_i\\) 上就是 \\(f_i(x) = |x| + \\min_{y \\in [x -\r\ndl_i,x+dr_i]}f_{i-1}(y)\\)。\r\n用滑动窗口转移就可以把这个 DP 做到 \\(O(n^2)\\)。\r\n进一步优化的话，需要发现这个 \\(f_i(x)\\) 的性质，这也是为什么，我把 DP\r\n数组写成函数的形式，而非二维数组。\r\n考虑到，我们每次对 \\(f\\)\r\n的操作是：将每个点替换成包含它的一段区间的最小值，给 \\(f\\) 加上一个凸函数。\r\n容易归纳证明，对于任意 \\(i\\)，\\(f_i\\) 都是凸函数。\r\n既然看出来了是凸的，我们不妨考察斜率，我们发现一次 \\(f(x) += |x|\\) 的操作，会把一段的斜率减小\r\n\\(1\\)，另一段的斜率增大 \\(1\\)。总的来看，斜率总是会在 \\([-n,n]\\) 之间。\r\n那么可能的斜率数量也很有限。\r\n那么我们不妨从这一点入手来维护这个凸函数：维护这个函数的所有拐点。\r\n拐点是什么呢？就是你考虑到这个函数是凸的，且呈现明显的分段特征，每段内部是一条直线，且直线的斜率从左往右单调递增，我们维护的就是每一段的端点。\r\n我们接下来称这类凸函数为“折线”。\r\n类似下图：\r\n\r\n这是一个折线，其中红线代表拐点，即两段之间的分界点，数字代表每一段的斜率。\r\n我们发现，只要维护了拐点集合，那么两个拐点之间的斜率也可以推得，具体地，我们同时维护斜率\r\n\\(&lt;0\\) 和斜率 \\(&gt;0\\) 的拐点集合 \\(S,T\\)，那么每相邻三个拐点所对应的两段函数，斜率就会相差\r\n\\(1\\)，如果实际上这两段的斜率差 \\(&gt;1\\)，那么我们就重复加入一些拐点，使其满足上面的条件即可。（比如说，\\(S\\) 中最大拐点与次大拐点之间的直线斜率就是\r\n\\(-1\\)，再往左是 \\(-2\\)，以此类推）\r\n现在我们维护了拐点集合，考虑我们的操作对其产生的影响。\r\n再次整理我们的操作：\r\n\r\n令 \\(g_i(x)\\) 为 \\(\\min_{y \\in [x-dl_i,x+dr_i]}\r\nf_{i-1}(y)\\)，将 \\(f_i(x)\\)\r\n替换为 \\(g_i(x)\\)。\r\n令 \\(g_i(x)\\) 为 \\(f_i(x) + |x|\\)，将 \\(f_i(x)\\) 替换为 \\(g_i(x)\\)。\r\n取出 \\(f_n(x)\\) 的区间最小值（因为\r\n\\(x_n\\) 有个范围）\r\n\r\n设\\(f_i(x)\\) 中间那段斜率为 \\(0\\) 的段为 \\([L,R]\\)。\r\n考虑操作 \\(1\\)。\r\n对于 \\(x + dr_i &lt; L\\)，\\(g_i(x) = f_i(x + dr_i)\\)\r\n对于 \\(x - dl_i &gt; R\\)，\\(g_i(x) = f_i(x - dl_i)\\)。\r\n否则，\\(g_i(x) = f_i(L)\\)。\r\n画个图就可以知道，我们相当于把函数左半边向左平移 \\(dr\\)，把函数右半边向有平移 \\(dl\\)。对于中间那段斜率为 \\(0\\) 的，我们相当于将其伸长了。\r\n反应在拐点上，就是 \\(S\\)\r\n中的数同时减去 \\(dr\\)，\\(T\\) 中的数同时加上 \\(dl\\)。用两个数维护平移量即可。\r\n考虑操作 \\(2\\)。\r\n我们把 \\(|x|\\) 拆成两个函数：\\(\\max(x,0) + \\max(-x,0)\\)。\r\n这两个函数分别对应 \\(|x|\\)\r\n的左右半边，我们以 \\(max(-x,0)\\)\r\n为例，来讲述怎么处理。\r\n这相当于我们将一个折线加上一条斜率为 \\(-1\\) 的射线。\r\n分类讨论：\r\n\r\n如果 \\(0 \\le\r\nR\\)，那么画图可得，\\(T\\)\r\n中的直线没有任何变化，而对于 \\(S\\)\r\n中的点，如果其在 \\(0\\)\r\n的左边，那么它那里的直线斜率要 \\(-1\\)。因为一个拐点就表示了一次斜率的变化，我们直接将\r\n\\(0\\) 这个点加入 \\(S\\) 即可。\r\n否则，我们会发现，\\(T\\)\r\n中的一些直线的斜率会减 \\(1\\)\r\n，比如说，\\([L,R]\\) 这一段的斜率就从\r\n\\(0\\) 变成了 \\(-1\\)。我们发现，除开这一段以外，其它的在\r\n\\(0\\) 左边的直线斜率都减小了 \\(1\\)，但正负号没变。那我们把 \\(R\\) 从 \\(T\\) 中弹出，加入 \\(S\\) 中，并将 \\(0\\) 加入 \\(T\\) 中即可。\r\n\r\n加上 \\(\\max(x,0)\\) 是一样的。\r\n考虑操作 \\(3\\)：\r\n首先我们要知道 \\(f\\)\r\n的全局最小值，即斜率为 \\(0\\)\r\n的那一段的函数值，这个可以在操作 \\(2\\)\r\n中顺带维护出来。\r\n那么考虑询问区间 \\([l,r]\\) 和斜率为\r\n\\(0\\) 的区间 \\([L,R]\\) 的关系。\r\n如果它们有交，直接输出 \\(f_n(L)\\)\r\n即可。\r\n否则，假设 \\([l,r]\\) 在 \\([L,R]\\) 左边，容易发现 \\(f_n(l) \\ge f_n(r)\\)\r\n（因为这一段的斜率都小于 \\(0\\)）。\r\n考虑从 \\(r\\) 到 \\(L\\)\r\n中间的那些折线，因为我们已经维护了拐点集合，可以方便地将其提取出来，斜率也是可以算的。\r\n那直接从 \\(L\\) 一路推到 \\(r\\) 即可。\r\n\\(S\\) 和 \\(T\\) 都可以用两个堆维护，本人偷懒写了个\r\nset。\r\n具体可以看代码。\r\n\r\n好了，现在我们会了 \\(x_1\\)\r\n确定的情况了，那环怎么做呢？\r\n结论：设 \\(F(x_1)\\) 表示一个 \\(x_1\\) 所对应的最小代价，那么 \\(F(x_1)\\) 关于 \\(x_1\\) 也是凸的。\r\n证明大概分为两部分：\r\n\r\n证明如果 \\(x_i\\)\r\n的取值范围是实数，那么不改变最优解。\r\n证明：如果 \\(c_1,c_2,\\dots,c_n\\) 和\r\n\\(d_1,d_2,\\dots,d_n\\) 都是 \\(x_1,x_2,\\dots,x_n\\) 的一组最优解，那么\r\n\\(\\dfrac{c_1+d_1}{2},\\dfrac{c_2+d_2}{2},\\dots,\\dfrac{c_n+d_n}{2}\\)\r\n也是一组最优解。这可以推出 \\(\\dfrac{F(c_1) +\r\nF(d_1)}{2} \\ge F(\\dfrac{c_1+d_1}{2})\\)\r\n\r\n所以，我们对 \\(x_1\\)\r\n进行一个三分即可。\r\n本题总时间复杂度为 \\(\\Theta(n \\log n \\log\r\n(\\sum a_i))\\)\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3.5e4 + 5;typedef long long ll;int n,a[N],L[N],R[N];struct Heap&#123;\tmultiset&lt;ll&gt; S;\tll tag;\tinline void clear() &#123; S.clear();tag = 0;&#125;\tinline void insert(ll x) &#123; S.insert(x - tag);&#125;\tinline void erase(ll x) &#123; S.erase(S.find(x - tag));&#125;\tinline void shift(ll x) &#123; tag += x;&#125;\tinline ll Greatest() &#123; return tag + *S.rbegin();&#125;\tinline ll Lowest() &#123; return tag + *S.begin();&#125;\tinline int size() &#123; return S.size();&#125;&#125;;Heap ql,qr;long long ans = 0;inline void addL(ll x) // x - t&#123;\tif(x &lt;= qr.Lowest()) &#123;ql.insert(x);return;&#125;\tll tmp = qr.Lowest();\tqr.erase(tmp);ql.insert(tmp);qr.insert(x);\tans += x - ql.Greatest();&#125;inline void addR(ll x)&#123;\tif(x &gt;= ql.Greatest()) &#123; qr.insert(x);return;&#125;\tll tmp = ql.Greatest();\tql.erase(tmp);qr.insert(tmp);ql.insert(x);\tans += qr.Lowest() - x;&#125;inline ll GetVal(ll l,ll r) // 折线的区间最值&#123;\tif(l &lt;= qr.Lowest() &amp;&amp; ql.Greatest() &lt;= r) return ans;\tif(l &gt; qr.Lowest())\t&#123;\t\tlong long delta = 0;\t\tlong long lst = qr.Lowest();qr.erase(lst);qr.insert(l);\t\tint K = 1;\t\twhile(qr.size() &amp;&amp; qr.Lowest() &lt;= l)\t\t\tdelta += 1ll * K * (qr.Lowest() - lst),\t\t\tlst = qr.Lowest(),qr.erase(lst),++K;\t\treturn ans + delta;\t&#125;\tif(r &lt; ql.Greatest())\t&#123;\t\tlong long delta = 0;\t\tlong long lst = ql.Greatest();ql.erase(lst);ql.insert(r);\t\tint K = 1;\t\twhile(ql.size() &amp;&amp; ql.Greatest() &gt;= r)\t\t\tdelta += 1ll * K * (lst - ql.Greatest()),\t\t\tlst = ql.Greatest(),ql.erase(lst),++K;\t\treturn ans + delta;\t&#125;&#125;inline ll Solve(ll x1)&#123;\t// printf(&quot;x1:%lld\\n&quot;,x1);\tql.clear();qr.clear();ans = abs(x1);\tfor(int i = 1;i &lt;= n + 1;i++)\t\tql.insert(x1),qr.insert(x1);\tfor(int i = 2;i &lt;= n;i++)\t&#123;\t\tint dl = L[i] - a[i],dr = R[i] - a[i]; //[x - dl,x + dr]\t\tql.shift(-dr);qr.shift(-dl);\t\taddL(0);addR(0);\t&#125;\t// puts(&quot;done\\n&quot;);\t//  L_1 \\le a_1 - x_1 + x_n \\le R_1\tll nowl = L[1] - a[1] + x1,nowr = R[1] - a[1] + x1;\t// printf(&quot;%lld %lld %lld\\n&quot;,nowl,nowr,ans);\t// printf(&quot;ql: &quot;);\t// for(auto it : ql.S) printf(&quot;%lld &quot;,it + ql.tag);printf(&quot;\\n&quot;);\t// printf(&quot;qr: &quot;);\t// for(auto it : qr.S) printf(&quot;%lld &quot;,it + qr.tag);printf(&quot;\\n&quot;);\tll res = GetVal(nowl,nowr);\t// printf(&quot;res:%lld\\n&quot;,res);\treturn res; &#125;int main()&#123;\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++)\t\tcin &gt;&gt; a[i] &gt;&gt; L[i] &gt;&gt; R[i];\tll lef = -1e18,righ = 1e18;\twhile(righ - lef &gt; 5)\t&#123;\t\t\tll lmid = (lef + righ) &gt;&gt; 1,rmid = lmid + 1;\t\tif(Solve(lmid) &lt; Solve(rmid)) righ = rmid;\t\telse lef = lmid;\t&#125;\t\tll ans = 1e18;\tfor(ll i = lef;i &lt;= righ;i++)\t\tans = min(ans,Solve(i));\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n本题中，维护折线的技巧有一个好听的名字：Slope\r\ntrick，我们通过拐点集合，恰当地表示出了折线的信息，且让操作变得十分简单，虽然这个转化本身比较抽象。（\r\n类似的题目还有：CF713C，ABC217H，ARC123D\r\n","tags":["DP","Slope trick"]},{"title":"AGC006 DEF 题解","url":"/posts/2734878942/","content":"AGC006D\r\n题意：给出一个长度为 \\(2n - 1\\)\r\n的排列。构造一个 \\(n\\)\r\n层金字塔，最底层是该排列，其他层的数字按如下方式生成：方格 \\(b\\) 中填写的整数，是方格 \\(b\\)\r\n正下方，左下方和右下方方格中所写整数的中位数。\\(n \\le 2 \\times 10^5\\)。\r\n\r\n现在请求出第一层的数字。\r\n\r\n看到题之后一眼二分答案，然后找性质失败。\r\n事实证明当时做的时候还是太浮躁了。如果二分答案完了之后，有两个连续的\r\n\\(0\\) 或两个连续的 \\(1\\)，那么它们肯定不会被别的东西给抹掉，只有可能因为到达边界而自行消除。\r\n所以我们找到距离中点最近的相邻的一对 \\(0/1\\) 即可。\r\n事实上，不会出现最近的 \\(00\\)\r\n和最近的 \\(11\\)\r\n离中点距离相同的情况，读者可以自证。\r\n如果找不到，说明原序列一定是 \\(01\\)\r\n相间，判断是容易的。\r\nAGC006E\r\n题意：给出 \\(3\\) 行 \\(n\\) 列的初始矩阵，第 \\(i\\) 行第 \\(j\\) 列的数为 \\(i\r\n+ 3j -3\\)。\r\n我们有一个这样的操作：选择一个 \\(3 \\times\r\n3\\) 的子矩阵，将这个子矩阵旋转 \\(180^{\\circ}\\) （具体见下面的图）。\r\n现在给出一个 \\(3\\) 行 \\(n\\)\r\n列的矩阵，问能否若干次操作使初始矩阵变成目标矩阵。\r\n\r\n没有找到什么基本性质。/kk\r\n首先，每一列的状态只可能是 \\(123\\)\r\n或者 \\(321\\)\r\n之类的，连续三个递增或递减的数。因为每次操作只会颠倒某些列，并移动某些列的位置。先把这个判掉。\r\n那么每一列的状态就可以编码成一个数 \\(a_i\\)，一次操作相当于让 \\(a_i,a_{i+1},a_{i+2}\\)\r\n变成它们的相反数，并交换 \\(a_i,a_{i+2}\\)。目标是让 \\(a_i = i\\)。\r\n我们发现奇数位置和偶数位置是相对独立的。如果交换了两个奇数位置，那么奇数位置的负号个数的奇偶性不会改变，而偶数位置的会改变\r\n\\(1\\)。\r\n而为了让绝对值从小到大排序，我们对奇数位置的交换次数必须和奇数位置的逆序对数同奇偶。\r\n那么这就说明：奇数位置的逆序对数和偶数位置的负号个数，奇偶性应该是相同的。同理，偶数位置的逆序对数和奇数位置的负号个数的奇偶性应该是相同的。\r\n这是一个必要条件。充分性的话，因为我们能用若干次操作把 \\(a_i\\) 和 \\(a_{i+2}\\)\r\n同时变成它们的相反数，并不改变其他数，所以先按绝对值进行排序，然后用这种操作把负号都做掉即可。\r\n这个“若干次操作”可以参看洛谷题解。\r\nAGC006F\r\n题意：给出一张有向图 \\(G\\)。\r\n不断重复如下操作：取出三个点 \\(x,y,z\\)，如果 \\((x,y)\\) 有边，\\((y,z)\\) 有边，\\((z,x)\\) 没有边，那么连边 \\((z,x)\\)。\r\n请计算没有边可以添加的时候的边数。\r\n做的时候在手玩树形图，看出来了跟层有关，但根本想不到如何推广。\r\n首先对每个连通块单独考虑，然后尝试三染色。\r\n这个三染色是怎么染色呢，我们希望对于边 \\((x,y)\\)，都有 \\(col_y \\equiv col_x + 1\r\n\\pmod{3}\\)，所以我们连边 \\((x,y,1)\\)，\\((y,x,-1)\\)，然后进行 dfs 即可。\r\n考虑三染色失败了怎么办，这个时候任意两点之间都会有连边，答案为点数的平方，证明就是考虑\r\ndfs 树上一条使其失败的返祖边。\r\n如果成功了，但三种颜色没有用满，那么不会出现 \\(x \\to y,y\\to z\\)\r\n这种东西，故答案为原先的边数。\r\n否则可以猜出答案为 \\(cnt_0cnt_1+cnt_1cnt_2+cnt_2cnt_0\\)，即异色点之间有单向边。接下来考虑证明。\r\n肯定存在一条链 \\(u\\to v \\to w\\) 满足\r\n\\(col_u = 0,col_v = 1,col_w = 2\\)。\r\n归纳构造，假设图 \\(G\\)\r\n已经满足上述结论，考虑新加入一条边 \\(u \\to\r\np\\) 的情况。\r\n接下来设 \\(\\{0/1/2\\}\\) 表示 \\(col = 0/1/2\\) 的点的集合。\r\n由于 \\(\\{2\\} \\to u,u \\to p\\)，所以\r\n\\(p \\to \\{2\\}\\)。\r\n由于 \\(p \\to \\{2\\},\\{2\\} \\to\r\n\\{0\\}\\)，所以 \\(\\{0\\} \\to\r\np\\)。\r\n可以发现无法存在其他的边，得证。\r\n因为 \\(u,v,w\\) 是本质相同的，\\(u \\to p\\) 和 \\(p\r\n\\to u\\) 也是本质相同的，故其他情况不再赘述。\r\n直接算答案即可。属于是想到了“染色”就能做大部分甚至做完的题。\r\n","tags":["AGC 板刷记录"]},{"title":"ARC064D 题解","url":"/posts/891700191/","content":"这题一眼望过去，用不了什么现成的科技，最朴素的思路就是，考虑每个串会被算几次。\r\n\r\n事实上，一个串会被算多次，也意味着有两个回文串互相循环同构。\r\n循环同构也会出现所谓“重复”的情况，这与一个串的最小整周期有关。\r\n如果一个回文串的最小整周期为 \\(x\\)，那么只有 \\(x\\) 个串是“可能有用的”\r\n故我们先考虑一个周期内的问题。\r\n回文串有两种：\\(AA^r\\) 和 \\(AcA^r\\) (\\(A^r\\) 表示 \\(A\\) 的翻转，\\(c\\) 表示一个字符)\r\n对于 \\(AA^r\\)\r\n，与其循环同构的回文串只有 \\(A^rA\\)\r\n对于 \\(AcA^r\\)，没有与其循环同构的回文串。（这就是我没有发现的地方）\r\n所以如果 \\(x\\)\r\n是偶数，一个回文串会带来 \\(\\frac{x}{2}\\) 的贡献，否则带来 \\(x\\) 的贡献。\r\n接下来考虑如何算周期为 \\(x\\)\r\n的回文串个数。\r\n先可以算周期是 \\(x\\)\r\n约数的回文串个数，为 \\(K^{\\lceil \\frac{x}{2}\r\n\\rceil}\\)，再用其约数的答案来减即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6000,P = 1e9 + 7;inline int qpow(int a,int b) &#123; int res = 1;while(b) &#123;if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;&#125; return res;&#125;int factor[N],f[N],tot,n,k;int main()&#123;\tscanf(&quot;%d%d&quot;,&amp;n,&amp;k);\tfor(int i = 1;i * i &lt;= n;i++)\t&#123;\t\tif(n % i) continue;\t\tfactor[++tot] = i;\t\tif(i * i != n) factor[++tot] = n / i;\t&#125;\tsort(factor + 1,factor + tot + 1);\tint ans = 0;\tfor(int i = 1;i &lt;= tot;i++)\t&#123;\t\tf[i] = qpow(k,(factor[i] + 1) &gt;&gt; 1);\t\tfor(int j = 1;j &lt; i;j++)\t\t\tif(factor[i] % factor[j] == 0) (f[i] += P - f[j]) %= P;\t\tans = (ans + 1ll * ((factor[i] &amp; 1) ? factor[i] : factor[i] / 2) * f[i] % P) % P;\t&#125;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["counting","string theory"]},{"title":"ARC146E 题解","url":"/posts/302081082/","content":"因为之前做过水淹笛卡尔树的题（ARC117E），一眼看出了 DP\r\n状态，后面就不会了，题解告诉我第二维有效状态不超过 \\(5\\)\r\n个，人有点麻。也是没有仔细思考的缘故。\r\n\r\n按值域从小到大 DP，每次考虑插入 \\(A_i\\) 个 \\(i\\)。\r\n假设已经插入的数形成了 \\(j\\)\r\n个连续段，显然，除了最左和最右的连续段，剩下的段的两端都是 \\(i - 1\\)（不然就无法满足相邻位置差为 \\(1\\)）\r\n这提示我们最左边和最右边有一些特殊性。\r\n事实上，如果最左边是 \\(i -\r\n1\\)，那么当前的 \\(i\\)\r\n还可以插到左边，否则不行。右边同理。\r\n那么我们设 \\(dp_{i,j,u,v}\\)\r\n表示当前做到 \\(i\\)，一共形成了 \\(j\\) 个连续段，最左边是不是 \\(i\\)，最右边是不是 \\(i\\)。\r\n转移有两个方面，第一是 \\(j\\)\r\n的变化，第二是转移系数。\r\n如果我们想在最左和最右都填上 \\(i\\)\r\n的话，我们首先会把 \\(2j\\) 个 \\(i\\) 填在每个连续段的两侧，然后剩余的 \\(A_i -2j\\) 个 \\(i\\) 会贡献 \\(A_i\r\n- 2j\\) 个连续段，总段数就是 \\(A_i -\r\nj\\)。\r\n如果想在某几侧不填上 \\(i\\)\r\n的话，道理是一样的，将结果 \\(+1\\) 或\r\n\\(+2\\) 即可。\r\n考察转移系数，还是以 \\(u = v = 1\\)\r\n为例，这时一共会有 \\(j + 1\\)\r\n个空隙，每个空隙都必须有数，这就是个插板法，方案数为 \\(\\binom{A_i - 1}{j}\\)。\r\n直接这么做，看上去可以达到平方复杂度，但是，我们发现 \\(j\\)\r\n的变化方法较为单一，它只有可能在每轮中由 \\(j\\) 变为 \\(A_i -\r\nj\\)，或在 \\(u\\) 或 \\(v\\) 变化时加上 \\(1\\) 或者 \\(2\\)。\r\n我们处理出 \\(cur_i\\) 表示如果前\r\n\\(i\\)\r\n轮，每轮都在两边放数，会有几个连续段（显然有 \\(cur_i = a_i - cur_{i-1}\\)）。\r\n那么 \\(j\\) 的取值只会在 \\(cur_i\\) 附近，取 \\([cur_i - 2,cur_i + 4]\\) 即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5,P = 998244353;inline void Plus(int &amp;x,const int &amp;y) &#123; x += y;if(x &gt;= P) x -= P;&#125;int n,a[N],cur[N];int dp[N][7][2][2];int fac[N],ifac[N];inline void init(int n)&#123;\tfac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) fac[i] = 1ll * fac[i - 1] * i % P;\tifac[1] = 1;\tfor(int i = 2;i &lt;= n;i++) ifac[i] = 1ll * ifac[P % i] * (P - P / i) % P;\tifac[0] = 1;\tfor(int i = 1;i &lt;= n;i++) ifac[i] = 1ll * ifac[i - 1] * ifac[i] % P;&#125;inline int C(int n,int m) &#123; if(n &lt; 0 || m &lt; 0 || n &lt; m) return 0;return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;&#125;int main()&#123;\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++)\t\tcin &gt;&gt; a[i];\tcur[1] = a[1];\tdp[1][2][1][1] = 1;\tinit(2e5);\tfor(int i = 2;i &lt;= n;i++)\t&#123;\t\tcur[i] = a[i] - cur[i - 1]; // 如果两边都不放 i,会有多少对相邻的 i\t\tfor(int j = 0;j &lt;= 6;j++)\t\t\tfor(int u = 0;u &lt;= 1;u++)\t\t\tfor(int v = 0;v &lt;= 1;v++)\t\t\tif(dp[i - 1][j][u][v])\t\t\t&#123;\t\t\t\tfor(int p = 0;p &lt;= u;p++)\t\t\t\tfor(int q = 0;q &lt;= v;q++)\t\t\t\t&#123;\t\t\t\t\tint val = dp[i - 1][j][u][v],c = cur[i - 1] + j - 2; // c 表示实际有多少对相邻的 i\t\t\t\t\tif(p == 0 &amp;&amp; q == 0)\t\t\t\t\t\tPlus(dp[i][6 - j][p][q],1ll * val * C(a[i] - 1,c - 2) % P); // 4 - j : a - 原段数 + 2\t\t\t\t\tif(p == 1 &amp;&amp; q == 1 &amp;&amp; j &lt;= 4)\t\t\t\t\t\tPlus(dp[i][4 - j][p][q],1ll * val * C(a[i] - 1,c) % P); // 2 - j: a - 原段数\t\t\t\t\tif(p + q == 1 &amp;&amp; j &lt;= 5)\t\t\t\t\t\tPlus(dp[i][5 - j][p][q],1ll * val * C(a[i] - 1,c - 1) % P);\t\t\t\t&#125;\t\t\t&#125;\t\tfor(int j = 0;j &lt;= 6;j++)\t\t\tfor(int u = 0;u &lt;= 1;u++)\t\t\t\tfor(int v = 0;v &lt;= 1;v++)\t\t\t\t\tprintf(&quot;f[%d][%d][%d][%d]=%d\\n&quot;,i,cur[i] + j - 2,u,v,dp[i][j][u][v]);\t&#125;\tint ans = 0;\tfor(int i = 0;i &lt;= 6;i++)\t\tfor(int u = 0;u &lt;= 1;u++)\t\t\tfor(int v = 0;v &lt;= 1;v++)\t\t\t\tif(cur[n] + i - 2 == 1)\t\t\t\t\tPlus(ans,dp[n][i][u][v]);\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["counting"]},{"title":"AGC007 DEF 题解","url":"/posts/950516913/","content":"AGC007D\r\n简单题，虽然对数轴上游走的题还是不太会。\r\n\r\n一眼看出了状态，转移懒得编了（以后还是要编转移，现在编转移的能力有些弱）。\r\n容易发现，路径一定是先往前走一段，再折回一段，再往前走，走了一段再折，再走。\r\n说白了，一个点要么被经过一次，要么被经过三次。\r\n那么设 \\(f[i]\\) 表示收到前 \\(i\\) 个糖果的最小时间，此时人一定在 \\(x_i\\)。\r\n那么枚举位置 \\(j\\)，\\(j + 1 \\sim i\\)\r\n中的点被一次折返收完，那么有转移 \\(f[i] =\r\n\\min\\{f[j] + (x[i] - x[j]) + \\max(2(x[i]-x[j+1]),T)\\}\\)\r\n写出这个转移式子之后，优化非常简单，分类讨论那个 \\(\\max\\) 取到谁即可。因为 \\(x\\) 和 \\(f\\) 均不降，转移容易。\r\nAGC007E\r\n好题。\r\n题意：给出一棵二叉树，每个节点只有 \\(2\\) 或 \\(0\\) 个儿子。\r\n要求你从 \\(1\\) 走回 \\(1\\)，每天你可以从二叉树的一个叶子走到另一个叶子，或从\r\n\\(1\\) 走到某个叶子，或从某个叶子走到\r\n\\(1\\)。要求你经过二叉树上的所有叶子，且每条边被经过恰好两次。\r\n你的花费是最大的，从叶子到叶子的那一天经过的边的权值和，求最小花费。\r\n\\(n \\le 2 \\times 10^5\\)。\r\n首先二分答案，然后设 \\(bool\\) 状态\r\n\\(f_{x,a,b}\\) 表示从 \\(x\\) 开始游走，能否在第一天走过不超过 \\(a\\) 的距离，在第二天走过不超过 \\(b\\) 的距离。\r\n那么有转移 \\(f_{x,a,b} = OR_{k_1,k_2,k_1 +\r\nk_2 \\le mid} f_{ls,a,k_1} \\&amp; f_{rs,k_2,b}\\)\r\n交换 \\(ls,rs\\)\r\n后再转移一遍即可。\r\n当时只是觉得，这个转移形式有点双指针，然后想着能不能只记录一维，觉得挺假就没往下想了。\r\n事实证明，确实需要双指针。\r\n首先，对于同为 \\(true\\) 的状态 \\(f_{l_1,r_1}\\) 和 \\(f_{l_2,r_2}\\) ，如果 \\(l_1 \\le l_2,r_1 \\le\r\nr_2\\)，那么后者完全无用。\r\n所以你按 \\(l\\) 升序排序之后，\\(r\\) 一定是降序的。\r\n显然，对于每一个 \\(f_{ls,l_1,r_1}\\)\r\n都只需要考虑一个令 \\(r_2\\)\r\n最小且满足转移式的 \\(f_{rs,l_2,r_2}\\)。所以，每一个 \\(f_{ls}\\) 中的状态都只需要与一个对应的 \\(f_{rs}\\) 转移到 \\(f_x\\)\r\n中的唯一一个状态。所以，设左右子树的状态数分别为 \\(x,y\\)，那么一次转移只会增加最多 \\(2 \\times \\min\\{x,y\\}\\) 个状态（因为要把\r\n\\(ls,rs\\) 交换后再转移一遍，所以要乘个\r\n\\(2\\)）。\r\n根据启发式合并的复杂度分析，总状态数是 \\(\\Theta(n \\log n)\\) 的。\r\n找到每个状态对应的状态可以使用双指针，总时间复杂度是 \\(\\Theta(n \\log n \\log W)\\) 的。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = (1 &lt;&lt; 17) | 5;typedef long long ll;typedef pair&lt;ll,ll&gt; pll;#define FI first#define SE secondint n;int son[N][2],w[N][2];vector&lt;pll&gt; st[N]; // 状态集合void DP(int x,ll mid)&#123;\tst[x].clear();\tif(!son[x][0]) &#123;st[x].emplace_back(0,0);return;&#125;\tDP(son[x][0],mid);DP(son[x][1],mid);\tll tmp = mid - w[x][0] - w[x][1];\tvector&lt;pll&gt; vec;\tint num = 0;\tfor(int d = 0;d &lt; 2;d++)\t&#123;\t\tint lc = son[x][d],rc = son[x][d ^ 1];\t\tfor(int i = 0,j = 0;i &lt; st[lc].size();i++)\t\t&#123;\t\t\twhile(j + 1 &lt; st[rc].size() &amp;&amp; st[rc][j + 1].FI + st[lc][i].SE &lt;= tmp) ++j; //双指针\t\t\tif(j &gt;= st[rc].size() || st[lc][i].SE + st[rc][j].FI &gt; tmp) continue;\t\t\tvec.emplace_back(w[x][d] + st[lc][i].FI,w[x][d ^ 1] + st[rc][j].SE);\t\t&#125;\t\tif(d == 0) num = vec.size();\t&#125;\tinplace_merge(vec.begin(),vec.begin() + num,vec.end()); // 用归并来合并两个状态序列。用 sort 是 3 log 的。\tfor(int i = 0;i &lt; vec.size();i++) // 删去无用状态\t&#123;\t\tif(st[x].size() &amp;&amp; st[x].back().SE &lt;= vec[i].SE) continue;\t\tst[x].push_back(vec[i]);\t&#125;&#125;inline bool Check(ll mid)&#123;\tDP(1,mid);\treturn st[1].size() != 0;&#125;int main()&#123;\tcin &gt;&gt; n;\tll lef = 0,righ = 0;\tfor(int i = 2;i &lt;= n;i++)\t&#123;\t\tint fa,v;\t\tcin &gt;&gt; fa &gt;&gt; v;righ += v;\t\tif(!son[fa][0]) son[fa][0] = i,w[fa][0] = v;\t\telse son[fa][1] = i,w[fa][1] = v;\t&#125;\twhile(lef &lt; righ)\t&#123;\t\tll mid = lef + righ &gt;&gt;1;\t\tif(Check(mid)) righ = mid;\t\telse lef = mid + 1;\t&#125;\tcout &lt;&lt; lef &lt;&lt; endl;\treturn 0;&#125;\r\nAGC007F\r\n题意：\r\nShik 需要抄写一个字符串，一开始，纸面上有一个字符串 \\(S_0\\)，每次她写下字符串 \\(S_i\\) 的时候，\\(S_i[j]\\) 有可能与 \\(S_{i-1}[j]\\) 相同，也可能与 \\(S_{i}[j-1]\\) 相同。\r\nShik 希望抄写尽量少的字符串，就能使最后再纸上的字符串与 \\(T\\) 相同，具体地，她希望找到最小的整数\r\n\\(K\\)，使得存在一种方案让 \\(S_K = T\\)。\r\n\\(|S_0| = |T|,1 \\le |S_0| \\le\r\n10^6\\)。\r\n首先把图画出来，\\(S_0\\)\r\n中的一个字符肯定对应的是 \\(T\\)\r\n中的一段区间。每个字符相当于在平面上向右或向下走。\r\n当时的直觉是从后往前做，每个字符的匹配段都往右靠一定不劣，然后根据每个字符对应的区间设计\r\nDP。\r\n事实上，这样设计 DP 反倒会丢失路径信息。\r\n考虑我们在不改变每个字符所对应区间的情况下，把中间走过的路径尽量往右靠，那么一定不劣。\r\n而具体的策略就是：一直尽量右移，直到走到要覆盖的左边界，然后一直向下，最后横向覆盖。\r\n有图如下（来自 @command_block）：\r\n\r\n考虑从右往左，从一条折线变到另一条折线时的变化。\r\n假设当前 \\(S_i\\) 要到达 \\(T_j\\) （\\(j\\) 是区间左边界）\r\n那么那些横坐标大于等于 \\(j\\)\r\n的拐点要弹出。\r\n然后，原来所有的拐点都会往左下方平移一格（因为新折线要尽量贴近原来的折线）。\r\n最后，如果 \\(i \\ne j\\)\r\n，那么在横坐标为 \\(i\\)\r\n的地方会有一个拐点。\r\n（上述所有拐点均不包括最后一行）。\r\n我们可以用一个队列来维护拐点集合，队头是更加靠近目标串的，队尾是更加靠近\r\n\\(S_0\\) 的。\r\n上述操作都可以用队列维护。\r\n核心代码如下：\r\nwhile(down)&#123;\twhile(down &gt; 1 &amp;&amp; t[down - 1] == t[down]) --down;\twhile(up &gt;= 1 &amp;&amp; (up &gt; down || s[up] != t[down])) --up;\tif(!up) &#123; puts(&quot;-1&quot;);return 0;&#125;\twhile(!Q.empty() &amp;&amp; Q.front() - (int)Q.size() &gt;= down) // 这里减去 Q.size 是因为，每加入一个拐点，已有的拐点都会往左下方平移一格，这是本题所维护的折线的性质。\t\tQ.pop();\tif(up != down) Q.push(up);\tans = max(ans,(int)Q.size() + 1);\t--down;&#125;\r\n答案是队列大小 +1 的历史最大值。\r\n因为可以归纳证明，每条折线的拐点的横坐标都是连续的（即都位于连续的前几行）。\r\n大致是说，这对于最右的折线显然成立，而其它的折线都会尽量往右靠。\r\n一道思路比较清奇的题。\r\n","tags":["AGC 板刷记录"]},{"title":"P7213 题解","url":"/posts/2642165753/","content":"最近对计数题的训练还是让我很有收获的。能想出这题的主状态，说明我有了一定的计数水平。但最后因为懒于编转移看了题解，其实这并没有必要。以后还是要自己把转移讨论出来，哪怕漏了几类也没有关系。毕竟考场上，状态和转移都需要自己推。\r\n\r\n首先，有一个基本的观察：\r\n​\r\n每一次地震，对于最大的有两个位置的高度，靠右的那个位置一定会被保留下来，再也不会变化。\r\n“最大的”，”靠右“，诸如此类的字眼，提示我们从后往前考虑问题，并从值域入手设计状态。\r\n但现在还没有直接的思路，需要进一步观察。\r\n从后往前推，对于第 \\(2n\\)\r\n个位置，它显然可以活着。\r\n对于第 \\(2n - 1\\) 个位置，如果它和第\r\n\\(2n\\) 个位置都是 \\(1\\)，它就会寄，否则一定能活下来。\r\n对于第 \\(2n - 2\\) 个位置，如果它是\r\n\\(2\\) ，且后面有 \\(2,1\\)，或者它是 \\(1\\)，且后面也有 \\(1\\)，它就得寄，否则会活。\r\n（注意，上述的状态都是在某次地震后的状态，不一定是最初的）\r\n以此类推，我们发现：\r\n如果在某次地震后，高度为 \\(h\\)\r\n的柱子后面，高度为 \\(1,2,\\dots,h\\)\r\n的柱子都至少出现了一次，那这根柱子一定活不下来。\r\n进一步地说，我们从后往前扫到一个位置 \\(i\\)，如果 \\(h_i\\) 没有在后面的位置出现过，那么 \\(h_i\\) 就是当前位置的最终值，否则 \\(h_i\\) 会一直减到后面没有出现 \\(h_i\\)，减到 \\(0\\) 为止。\r\n事实上，这个“在后面没有出现”，你只需要考虑在后面的最终值中，\\(h_i\\)\r\n有没有出现，而不需要考虑“某次地震以后”，因为地震并不会缩小高度的集合，以前出现的高度，地震过后还是出现，这是显然的，而我们显然不会做多余的事情，因为基于最终值推导出的变化肯定需要执行。\r\n那么我们就只需要考察 这些柱子高度的最终值 以及\r\n形成这些最终值的方式\r\n（这看上去是句废话，但你会发现，通过上面的观察，考察后者变得简单了很多）。\r\n考察这些的柱子的最终值，它们会在值域上形成一些连续段，而与一个柱子的存亡有关的就是那个最低的连续段。\r\n那么我们就可以设出状态 \\(f[i][j]\\)\r\n表示考虑到了位置 \\([i,n]\\)，在最终值上，\\([1,j]\\) 的柱子都出现过，但 \\(j + 1\\) 未出现过的答案。\r\n有些读者可能会发现这个 \\(j\\)\r\n长得很像 MEX，事实上，这题的转移与 CF1608F MEX Counting\r\n的思想是相同的。我们接下来细说。\r\n在下文，我们假设值相同的两个柱子是有区别的，最后将答案除以 \\(2^n\\)。\r\n为方便描述，接下来设 \\(c_0\\) 表示\r\n\\([i + 1,n]\\)\r\n中钦定倒塌的柱子数量，\\(c_1\\) 表示\r\n\\([i + 1,n]\\)\r\n中钦定存留的柱子数量。\r\n如果 \\(i\\) 位置钦定倒塌：\r\n那么该位置的取值只能是 \\(1 \\sim\r\nj\\)，一共有 \\(2j\\)\r\n个数可以选择，而我们之前选 \\(1 \\sim j\\)\r\n的时候已经用掉了 \\(j\\) 个数，还有 \\(c_0\\) 个数用在了那 \\(c_0\\) 个倒掉的柱子上，故这一位的方案数是\r\n\\(j - c_0\\)，故有转移式 \\(f[i][j] \\gets f[i+1][j] \\times (j -\r\nc_0)\\)。\r\n如果 \\(i\\) 位置钦定存活：\r\n那么需要分类讨论：\r\n\r\n\\(i\\) 位置的最终值大于 \\(j + 1\\)，此时我们不能确定什么，所以使用\r\nCF1608F 中的”延迟贡献“思想，将这一个数留到后面再来确定，即转移 \\(f[i][j] \\gets f[i + 1][j]\\)。\r\n\\(i\\) 位置的最终值等于 \\(j +\r\n1\\)，那么我们所需要做的工作会复杂一些，我们可能要把值域上最小和次小的连续段拼起来。\r\n考虑从 \\(f[i + 1][j]\\) 转移到 \\(f[i][j + k]\\)。\r\n那么我们首先要确定 \\(i\\)\r\n位置初始值该填什么，显然，其只能从 \\((j + 2)\r\n\\sim (j + k)\\) 里面选（因为这些数都出现过 \\(1\\) 次了，在这里只有 \\(1\\) 的贡献），同时还可以选两个 \\(j + 1\\) ，总计 \\((k + 1)\\) 种选法。\r\n然后考虑确定 $(j + 2) (j + k) $\r\n的位置，我们当然只能在活着的柱子里选，目前只有 \\(c_1 - j\\)\r\n个活着的柱子等待决策的，故方案数为 \\(\\dbinom{c_1 - j}{k - 1}\\)。（这里就把情况\r\n\\(1\\)\r\n中的“延迟决策”放到了这一步进行计算）\r\n对于这 \\(k - 1\\)\r\n个数，我们还要确定其初始值的填法，我们考虑计数这个东西需要解决什么限制。\r\n我们需要在 \\(1 \\sim t\\) 这 \\(2t\\) 个数中选出 \\(t\\) 个数，使得其在地震完之后是一个长度为\r\n\\(t\\) 的排列。\r\n这个条件还是很复杂，考虑必要条件：对于每个 \\(i \\in [1,t]\\)，值 $ i$ 的元素的个数 \\(\\le i\\)。\r\n必要性显然，因为如果存在一个 \\(i\\)\r\n使得不超过 \\(i\\) 的元素个数 \\(&gt; i\\)，那必然有一个柱子可以滑到 \\(0\\)。\r\n然后我们发现这个条件是充分的，因为这样的序列肯定不劣于一个排列（排列会把每个限制都取到等号），而排列一定合法。\r\n基于上述条件，可以设计一个 \\(g[i][j]\\) 表示填了数 \\(1 \\sim i\\)，一共用了 \\(j\\) 个位置的方案数。枚举当前数填 \\(0/1/2\\) 个转移即可：\r\n\\[g[i][j] = g[i - 1][j] + 2j \\times g[i -\r\n1][j - 1] + j(j-1) \\times g[i - 1][j - 2]\\]\r\n汇总上述分析，得出转移式： \\[f[i][j + k]\r\n\\gets f[i][j] \\times (k + 1) \\times \\binom{c_1 - j}{k-1} \\times g[k -\r\n1][k - 1]\\]\r\n\r\n跑上述的 DP 即可。时间复杂度 \\(\\Theta(n^3)\\)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6e2 + 5,P = 1e9 + 7;inline void Plus(int &amp;x,const int &amp;y) &#123; x += y;if(x &gt;= P) x -= P;&#125;inline int qpow(int a,int b) &#123; int res = 1;while(b) &#123;if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;&#125; return res;&#125;bool alive[N &lt;&lt; 1];int f[N &lt;&lt; 1][N],g[N][N];int n;int C[N][N];inline int Binom(int n,int m) &#123; if(n &lt; 0 || m &lt; 0 || n &lt; m) return 0;return C[n][m];&#125;int main()&#123;\tcin &gt;&gt; n;\tfor(int i = 1,x;i &lt;= n;i++)\t\tcin &gt;&gt; x,alive[x] = true;\tC[0][0] = 1;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tC[i][0] = C[i][i] = 1;\t\tfor(int j = 1;j &lt; i;j++)\t\t\tC[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\t&#125;\tg[0][0] = 1;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tg[i][0] = 1;\t\tfor(int j = 1;j &lt;= i;j++)\t\t&#123;\t\t\tPlus(g[i][j],g[i - 1][j]);\t\t\tif(j) Plus(g[i][j],2ll * j * g[i - 1][j - 1] % P);\t\t\tif(j &gt; 1) Plus(g[i][j],1ll * j * (j - 1) * g[i - 1][j - 2] % P);\t\t&#125;\t&#125;\tint sum = 0;\tf[n * 2 + 1][0] = 1;\tfor(int i = n * 2;i &gt;= 1;i--)\t&#123;\t\tif(alive[i])\t\t&#123;\t\t\tfor(int j = 0;j &lt;= n;j++)\t\t\t&#123;\t\t\t\tPlus(f[i][j],f[i + 1][j]);\t\t\t\tfor(int k = 1;k &lt;= j;k++)\t\t\t\t\tPlus(f[i][j],1ll * f[i + 1][j - k] * Binom(sum - (j - k),k - 1) % P * (k + 1) % P * g[k - 1][k - 1] % P);\t\t\t&#125;\t\t\t++sum;\t\t&#125;\t\telse\t\t&#123;\t\t\t\tint ded = n * 2 - i - sum;\t\t\tfor(int j = 0;j &lt;= n;j++)\t\t\t\tif(j &gt;= ded)\t\t\t\tPlus(f[i][j],1ll * f[i + 1][j] * (j - ded) % P);\t\t&#125;\t&#125;\tint ans = 1ll * f[1][n] * qpow((P + 1) / 2,n) % P;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["counting"]},{"title":"AGC028D 题解","url":"/posts/1943078264/","content":"这题我和王队合力做，王队想到了第一个转化，我想到了第二个转化，但是并没有导出成型的做法，看来，关键时候的坚持确实十分重要。\r\n不要被难度标签所吓到。现在来看，我每次都能隐约想到正解的一些东西，但难出做法，很可能是对算法理解不够深入。\r\n但又该怎么提升呢？也许多做题是有用的。我也能感觉得出来，最近做的题质量有提升。希望这是好的开始。\r\n\r\n首先，这题在圆上和在序列上做是没有区别的，两条在圆上相交的线段在序列上也是相交的，反之亦然。\r\n那么，在序列上，线段相当于一段区间，而一堆有交的线段，看上去就像一个大区间。\r\n事实上，对于一个连通块，我们考察其最左边的点 \\(L\\) 和最右边的点 \\(R\\)，一个连通块显然对应一个区间。\r\n都观察到这里了，我居然想设计一个从前向后的 DP（\r\n看来思考的时候，在草稿纸上写清楚已有的结论至关重要。\r\n设 \\(dp[L][R]\\) 表示对应区间为 \\(L,R\\) 的连通块数，并附加限制：且 \\([L,R]\\) 中没有点向 \\([L,R]\\)\r\n之外连边（包括我们所计数的连通块，也包括这个连通块以外，但在 \\([L,R]\\) 中的点）。\r\n设 \\(g(x)\\) 表示 \\(x\\) 个点任意匹配的方案数，在 \\(x\\) 为偶数时，其为 \\(1 \\times 3 \\times \\dots (x - 1)\\)，在 \\(x\\) 为奇数时其为 \\(0\\)。\r\n设 \\(cnt[L][R]\\) 表示区间 \\([L,R]\\)\r\n内还未确定匹配的点数（就是输入中未涉及到的点）。\r\n首先，如果 \\(\\exists x \\in [L,R],match[x]\r\n\\notin [L,R]\\)，那么 \\(dp[L][R] =\r\n0\\)。\r\n如果读者熟悉图计数的话，会知道一个计数连通块的套路：总方案减去 “\\(1\\) 号点所在连通块大小小于总数”\r\n的方案。\r\n这里也是要计数连通块，我们也还是先让 \\(dp[L][R] = g(cnt[L][R])\\)。\r\n然后枚举 \\(L\\) 号点所在连通块不是\r\n\\([L,R]\\) 的方案数，即 \\(\\sum_{i = L}^{R - 1} dp[L][i] g(cnt[i +\r\n1][r])\\)\r\n综上所述，有转移式： \\(dp[L][R] =\r\ng(cnt[L][R]) - \\sum_{i = L}^{R-1} dp[L][i]g(cnt[i+1][r])\\)。\r\n最后的答案就是 \\(\\sum_{L \\le R} dp[L][R]\r\ng(n - 2K - cnt[L][R])\\)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6e3 + 5,P = 1e9 + 7;int n,K;int g[N],match[N];int dp[N][N],sum[N];inline int Cnt(int l,int r) &#123; return sum[r] - sum[l - 1];&#125;int main()&#123;\tcin &gt;&gt; n &gt;&gt; K;n &lt;&lt;= 1;\tfor(int i = 1;i &lt;= K;i++)\t&#123;\t\tint u,v;\t\tcin &gt;&gt; u &gt;&gt; v;\t\tmatch[u] = v;match[v] = u;\t&#125;\tfor(int i = 1;i &lt;= n;i++)\t\tsum[i] = sum[i - 1] + (!match[i]);\tg[0] = 1;\tfor(int i = 2;i &lt;= n;i += 2)\t\tg[i] = 1ll * g[i - 2] * (i - 1) % P;\tint ans = 0;\tfor(int len = 2;len &lt;= n;len += 2)\t\tfor(int i = 1;i + len - 1 &lt;= n;i++)\t\t&#123;\t\t\tint j = i + len - 1,flag = 1;\t\t\tfor(int x = i;x &lt;= j;x++)\t\t\t\tif(match[x] &amp;&amp; (match[x] &lt; i || match[x] &gt; j)) &#123; flag = 0;break;&#125;\t\t\tif(!flag) continue; \t\t\tdp[i][j] = g[Cnt(i,j)];\t\t\tfor(int k = i;k &lt; j;k++)\t\t\t\tdp[i][j] = (dp[i][j] + P - 1ll * dp[i][k] * g[Cnt(k + 1,j)] % P) % P;\t\t\tans = (ans + 1ll * dp[i][j] * g[n - 2 * K - Cnt(i,j)] % P) % P;\t\t&#125;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["counting"]},{"title":"ARC128E 题解","url":"/posts/3621638127/","content":"最近开的题都有些 atcoder,不过相比于看题解都看得一头雾水的\r\nARC127E,这题反而更加良心。\r\n已经想到了构造可行解的方法，但没有抽象出判断可行解的条件。看来卡在比较弱智的地方确实是个比较常见的事情。希望某天可以踢出这临门一脚。\r\n说到底还是在这方面没什么脑子（\r\n\r\n题意：请构造序列 \\(x\\)，满足元素\r\n\\(i\\) ($ 1 i n$) 在该序列中恰好出现\r\n\\(a_i\\) 次，且任意连续 \\(k\\)\r\n个元素都互不相同，或报告无解。有解则输出字典序最小的解。\r\n\\(1 \\le k \\le n \\le 500,1 \\le \\sum a_i \\le\r\n200000\\)。\r\n首先考虑如何判断有无解，尝试设计一个贪心。\r\n既然是贪心，那就先满足最紧的限制，即先考虑 \\(a_i\\) 较大的元素，那么有一个方法就是隔\r\n\\(k\\) 个位置放一个。\r\n然后容易想到对 \\(x\\) 序列每 \\(k\\)\r\n个分一块，那么最先考虑的元素当然是放在每一块的起始位置。设块数为 \\(c\\)，最后一块长度为 \\(g\\)（因为最后一块长度最小）。\r\n那么显然 \\(a_i \\le c\\)，且 \\(\\sum [a_i = c] \\le\r\ng\\)。（就是这一步没有抽象出来）。\r\n构造的方法是简单的，按 \\(a_i\\)\r\n从大到小考虑每个元素，然后每次选择空位最多的段插进去即可。\r\n然后基于此设计贪心使得字典序最小。\r\n然后可以猜出一个贪心，即每次找到前 \\(k -\r\n1\\) 个位置中未出现的最小的元素，如果此时 \\(\\sum [a_i = c] = g\\)，那就只能选 \\(a_i = c\\) 的元素，然后处理后面长度 \\(-1\\) 的子问题。\r\n证明正确性，我们就是要证明，只要初始序列有解，每个时刻就都能选一个数出来。\r\n反证法，考察第一个不合法的时刻。\r\n\r\n如果 \\(\\sum [a_i = c] =\r\ng\\)，因为无数可选，所以 \\(a_i =\r\nc\\) 的所有数都在前面 \\(k - 1\\)\r\n个位置出现过，而如果将前面 \\(k - 1\\)\r\n个数加入进来重新分块，那么此时 \\(g&#39; \\gets\r\ng - 1\\)，但仍然有 \\(g\\) 个 \\(a_i = c\\) 的数，那么会有 \\(\\sum [a&#39;_i = c&#39;] &gt;\r\ng&#39;\\)，但在合法条件下，这个策略肯定不会让这种事发生，故矛盾。\r\n如果 \\(\\sum [a_i = c] &lt;\r\ng\\)，此时选数没有限制，无数可选只可能是因为 \\(a_i &gt; 0\\) 的数只有至多 \\(k - 1\\) 个，设当前位置加上后面有 \\(S\\) 个空位，如果 \\(S \\ge k\\)，那么显然后面无解，而 \\(\\sum [a_i = c] &lt; g\\)\r\n保证了后面有解，故矛盾。所以 \\(S \\le k -\r\n1\\)，那么此时 \\(c = 1,g =\r\nS\\)，所有的 \\(a_i\\) 都会等于\r\n\\(c\\)，所以 \\(\\sum [a_i = c] = g\\)，矛盾。\r\n\r\n综上所述，上述贪心一定可以构造出解，时间复杂度 \\(\\Theta(n \\sum a_i)\\)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e2 + 5,M = 2e5 + 5;inline int Knum(int n,int k) &#123; return (n + k - 1) / k;&#125;inline int Klst(int n,int k) &#123; return n % k == 0 ? k : n % k;&#125;int n,k,len;int a[N];int ans[M];int ton[N];int main()&#123;\tcin &gt;&gt; n &gt;&gt; k;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i],len += a[i];\tint num = 0;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tif(a[i] &gt; Knum(len,k)) return puts(&quot;-1&quot;),0;\t\tnum += (a[i] == Knum(len,k));\t&#125;\tif(num &gt; Klst(len,k)) return puts(&quot;-1&quot;),0;\tfor(int i = 1;i &lt;= len;i++)\t&#123;\t\tmemset(ton,0,sizeof ton);\t\tfor(int j = max(1,i - k + 1);j &lt; i;j++) ton[ans[j]] = true;\t\tnum = 0;\t\tfor(int j = 1;j &lt;= n;j++) num += (a[j] == Knum(len - i + 1,k));\t\tfor(int j = 1;j &lt;= n;j++)\t\t\tif(!ton[j] &amp;&amp; ((num &lt; Klst(len - i + 1,k) &amp;&amp; a[j])|| (num == Klst(len - i + 1,k) &amp;&amp; a[j] == Knum(len - i + 1,k))))\t\t\t&#123;\t\t\t\tans[i] = j;\t\t\t\t--a[j];\t\t\t\tbreak;\t\t\t&#125;\t&#125;\tfor(int i = 1;i &lt;= len;i++)\t\tcout &lt;&lt; ans[i] &lt;&lt; &#x27; &#x27;;\treturn 0;&#125;\r\n","tags":["constructive algorithm","ARC 试题乱做"]},{"title":"P5161 题解","url":"/posts/140728207/","content":"这题属于是对字符串的复习，也是对“撒关键点” 的复习。\r\n\r\n提前计算长度为 \\(1\\) 的答案，即\r\n\\(\\dfrac{n(n-1)}{2}\\)。\r\n把原数组变为差分数组，原问题变为间隔至少为 \\(1\\) 的子串对个数。\r\n那么答案就是 \\(\\sum\\limits_{i &lt; j}\r\n\\min\\{\\operatorname{lcp}(i,j),j - i - 1\\}\\)。\r\n这个间隔至少为 \\(1\\)\r\n不好处理，我们不妨用 \\(\\sum_{i&lt;j}\r\n\\operatorname{lcp}(i,j)\\) ，减去相邻或相交的子串对数。\r\n这个 \\(\\sum_{i &lt; j}\r\n\\operatorname{lcp}(i,j)\\) 是好做的，用 SA 跑出 height\r\n之后用单调栈解决即可。\r\n考虑这个 \"相邻或相交的子串对数\" 实际上就是对于 \\(lcp(i,j) &gt; j - i - 1\\) 的 \\((i,j)\\)，求 \\(lcp(i,j) - (j - i - 1)\\) 的和。\r\n不妨枚举 \\(j - i = len\\)，考察 \\(\\operatorname{lcp(i,j)} \\ge len\\)\r\n的贡献。\r\n可以仿照 [NOI2016]\r\n优秀的拆分 的做法，在串上每隔 \\(len\\) 个位置撒一个关键点。\r\n那么对于这个 \\(\\operatorname{lcp}\\)，它就至少会经过一个关键点。\r\n不妨画图如下：\r\n\r\n图中 \\(k\\) 是一个关键点，红色的是\r\n\\(lcp\\) 所代表的串。我们计算 \\(i \\in [k - len + 1,k]\\) 的答案。\r\n容易发现，在 \\(k\\) 与 \\(k + len\\) 之后的红串，实际上就是 \\(lcs(k,k + len)\\)。\r\n我们令 \\(s = lcs(k,k + len),p = lcp(k,k +\r\nlen)\\)。\r\n设 \\(k - i =\r\nt\\)，也就是红串的前半段的长度。\r\n那么一个 \\(t\\) 带来的贡献就是 \\(s + t - (len - 1)\\)。\r\n考虑 \\(t\\) 的范围。\r\n显然会有 \\(t + 1 \\le\r\n\\min(p,len)\\)（要不然前半段就不等了）\r\n然后还会有 \\(t \\ge len -\r\n\\min(len,s)\\) （否则红串长度就小于 \\(len\\) 了）\r\n确定范围之后，上面要算的就是等差数列求和，直接计算即可。\r\n\\(lcp\\) 和 \\(lcs\\) 都可以用 SA 求。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3e5 + 5;map&lt;int,int&gt; mp;int n;int a[N];struct SA&#123;\tint sa[N],ton[N];\tint t1[N],t2[N];\tint s[N];\tinline bool Equ(int *r,int i,int j,int l) &#123; return r[i] == r[j] &amp;&amp; r[min(n + 1,i + l)] == r[min(n + 1,j + l)];&#125;\t#define For(i,a,b) for(int i = (a);i &lt;= (b);i++)\t#define Rof(i,a,b) for(int i = (a);i &gt;= (b);i--)\tinline void get_sa(int n,int m)\t&#123;\t\tint *x = t1,*y = t2,*t;\t\tFor(i,1,m) ton[i] = 0;\t\tFor(i,1,n) ton[x[i] = s[i]]++;\t\tFor(i,1,m) ton[i] += ton[i - 1];\t\tRof(i,n,1) sa[ton[x[i]]--] = i;\t\tfor(int j = 1,p;j &lt;= n;j *= 2,m = p)\t\t&#123;\t\t\tp = 0;\t\t\tFor(i,n - j + 1,n) y[++p] = i;\t\t\tFor(i,1,n) if(sa[i] &gt; j) y[++p] = sa[i] - j;\t\t\tFor(i,1,m) ton[i] = 0;\t\t\tFor(i,1,n) ton[x[i]]++;\t\t\tFor(i,1,m) ton[i] += ton[i - 1];\t\t\tRof(i,n,1) sa[ton[x[y[i]]]--] = y[i],y[i] = 0;\t\t\tt = x;x = y;y = t;p = 1;x[sa[1]] = 1;\t\t\tFor(i,2,n)\t\t\t\tx[sa[i]] = Equ(y,sa[i - 1],sa[i],j) ? p : (++p);\t\t\tif(p &gt;= n) break;\t\t&#125;\t&#125;\tint rk[N],height[N];\tint ST[19][N],lg[N];\tinline void Get_Hi()\t&#123;\t\tFor(i,1,n) rk[sa[i]] = i;\t\tint j = 0;\t\tFor(i,1,n)\t\t&#123;\t\t\tif(j) --j;\t\t\tif(rk[i] != 1)\t\t\twhile(s[i + j] == s[sa[rk[i] - 1] + j]) ++j;\t\t\theight[rk[i]] = j;\t\t&#125;\t\t\tlg[0] = -1;\t\tFor(i,1,n) lg[i] = lg[i &gt;&gt; 1] + 1;\t\tFor(i,1,n) ST[0][i] = height[i];\t\tFor(j,1,18)\t\tFor(i,1,n - (1 &lt;&lt; j) + 1)\t\t\tST[j][i] = min(ST[j - 1][i],ST[j - 1][i + (1 &lt;&lt; j - 1)]);\t&#125;\tinline int lcp(int x,int y)\t&#123;\t\tx = rk[x];y = rk[y];\t\tif(x &gt; y) swap(x,y);++x;\t\tint k = lg[y - x + 1];\t\treturn min(ST[k][x],ST[k][y-(1&lt;&lt;k)+1]);\t&#125;\t#undef For\t#undef Rof&#125;A,B;inline long long Sum(int l,int r) &#123; return 1ll * (l + r) * (r - l + 1) / 2;&#125; inline long long Calc(int s,int p,int len)&#123;\tint l = len - min(len,s);\tint r = min(len,p) - 1;\tif(l &lt;= r)\t\treturn Sum(l,r) + 1ll * (s - len + 1) * (r - l + 1);\telse return 0;&#125;long long f[N];int stk[N],top;int main()&#123;\tcin &gt;&gt; n;\tlong long ans = 1ll * n * (n - 1) / 2;\tfor(int i = 1;i &lt;= n;i++)\t\tcin &gt;&gt; a[i];\tfor(int i = 1;i &lt; n;i++) a[i] = a[i + 1] - a[i];\t--n;\tfor(int i = 1,tot = 0;i &lt;= n;i++)\t\tif(mp.find(a[i]) == mp.end()) a[i] = mp[a[i]] = ++tot;\t\telse a[i] = mp[a[i]];\tfor(int i = 1;i &lt;= n;i++)\t\tA.s[i] = a[i],B.s[i] = a[n - i + 1];\tA.get_sa(n,n);\tB.get_sa(n,n);\tA.s[n + 1] = B.s[n + 1] = 0;\tA.Get_Hi();\tB.Get_Hi();\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\twhile(top &amp;&amp; A.height[stk[top]] &gt;= A.height[i]) --top;\t\tif(top) f[i] = f[stk[top]] + 1ll * (i - stk[top]) * A.height[i];\t\telse f[i] = 1ll * i * A.height[i];\t\tans += f[i];\t\tstk[++top] = i;\t&#125;\tfor(int len = 1;len &lt;= n;len++)\t\tfor(int i = len;i + len &lt;= n;i += len)\t\t&#123;\t\t\tint j = i + len;\t\t\tans -= Calc(B.lcp(n - i + 1,n - j + 1),A.lcp(i,j),len);\t\t&#125;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["string theory","suffix array"]},{"title":"AGC037E 题解","url":"/posts/2399183113/","content":"人类智慧题，对于这种题确实不太会。接受现实，多加练习（\r\n\r\n这题一眼看过去没有什么思路或性质。需要字典序最小，我们只能从最小的字符开始考察，设其为\r\n\\(a\\)。\r\n我们的首要目标是在最后最大化最开头那段 \\(a\\) 的长度。\r\n如果在翻转之前，有一段 \\(a\\) 处在\r\n\\(S\\)\r\n的末尾，那么翻转过后，其会变成原来的两倍长，如果处在其它地方，你只能多得到一段长度相等的\r\n\\(a\\)。\r\n所以，对于 \\(k &gt; \\lceil \\log_2 n \\rceil\r\n+ 1\\) ，只需输出 \\(n\\) 个 \\(a\\) 即可。\r\n对于剩下的情况，我们可以用开头的一次操作把最长的 \\(a\\)\r\n放到串的末尾，然后不断倍长，在最后一次操作时把这段 \\(a\\) 放在结果串的开头。\r\n接下来我们要让 \\(a\\)\r\n后面的那一段的字典序最小。\r\n设那段最长的 \\(a\\) 为 \\(A\\)，它前面的串为 \\(B\\)。我们先用一次操作把 \\(BA\\) 提到 \\(S\\) 的最后，再一次操作后变为 \\(BAAB\\)，容易发现，新的串必然是 \\(BA^2\\) 的一段后缀，如此下去，最后的串必然是\r\n\\(A^{2^{k-1}}B^R\\)\r\n的一段前缀，我们只需找出字典序最小的 \\(B^R\\)。\r\n有意思的地方是，由于 \\(SS^R\\)\r\n为回文串，只要 \\(BA\\) 在 \\(S\\) 中出现，\\(AB^R\\) 一定会在 \\(S^R\\) 中出现，那么我们找字典序最小的 \\(AB^R\\) ，只需在 \\(SS^R\\) 中找到字典序最小的长度为 \\(n\\) 的子串即可。这个可以 \\(\\Theta(n^2)\\) 完成。\r\n上面的做法也统一了 \\(k = 1\\)\r\n的情况，最终的时间复杂度为 \\(\\Theta(n^2)\\)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e3 + 5;int n,k;char s[N &lt;&lt; 1];char ans[N];inline void Useans(int p)&#123;\tfor(int i = 1;i &lt;= n;i++)\t\tans[i] = s[p + i - 1];&#125;int fir;inline void Check(int p)&#123;\tif(!fir) Useans(p),fir = true;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tif(ans[i] &lt; s[i + p - 1]) return;\t\tif(ans[i] &gt; s[i + p - 1]) return Useans(p);\t&#125;&#125;int main()&#123;\tcin &gt;&gt; n &gt;&gt; k;\tcin &gt;&gt; (s + 1);\tif(k &gt;= 15)\t&#123;\t\tchar c = &#x27;z&#x27;;\t\tfor(int i = 1;i &lt;= n;i++) c = min(c,s[i]);\t\tfor(int i = 1;i &lt;= n;i++) putchar(&#x27;c&#x27;);\t\tputchar(&#x27;\\n&#x27;);\t\treturn 0;\t&#125;\tfor(int i = 1;i &lt;= n;i++) s[n * 2 + 1 - i] = s[i];\tfor(int i = 1;i &lt;= n + 1;i++) Check(i);\tint mx = 0;\tfor(int i = 1;i &lt;= n + 1;i++)\t\tif(ans[i] == ans[1]) ++mx;\t\telse break;\tint len = mx &lt;&lt; (k - 1);\tfor(int i = 1;i &lt;= len;i++) putchar(ans[1]);\tfor(int i = len + 1;i &lt;= n;i++) putchar(ans[i - len + mx]);\tputchar(&#x27;\\n&#x27;);\treturn 0;&#125;\r\n","tags":["string theory"]},{"title":"CF1063F 题解","url":"/posts/1321418465/","content":"这题我观察出了一些显然的性质，但还是没有做法。（\r\n做完之后，对 SAM 的运用倒是更加熟练了。那个 DP\r\n状态，虽然见过很多回这样的形式了，但还是没想到。\r\n\r\n为方便叙述，我们将原串翻转，限制变为 \\(t_i\\) 是 \\(t_{i+1}\\) 的真子串。\r\n性质 1\r\n\\(|t_i| =\r\ni\\)，即每加一个串，顶多在开头或结尾加一个字符，这是显然的，因为加得越多，后面的串越难合法。\r\n性质 2\r\n设 \\(f_i\\) 表示求解 \\(s[1 \\dots i]\\) 中的问题，且强制让 \\(t_k\\) 的右端点为 \\(i\\) 时最大的 \\(k\\)。（实际上就是 \\(t_k\\) 最大的长度）\r\n那么 \\((i -1) - f_{i - 1} + 1 \\le i - f_i +\r\n1\\) （这里比较的是两个 \\(t_k\\)\r\n的左端点的位置，事实上，\\(f_{i}\\)\r\n所代表的方案，每个串都删一个字符，就能变为 \\(f_{i-1}\\) 的方案，即 \\(f_{i - 1} \\ge f_i -\r\n1\\)，故上述性质显然成立。）\r\n这里的 \\(f_i\\) 实际上就是 DP\r\n状态，我们考虑维护 \\(t_k\\) 所代表的区间\r\n\\(s[l,r]\\)，由性质 \\(2\\) 可得 \\(l\\) 是不降的，这启示我们可以双指针。\r\n如何判断一个串 \\(s[l,r]\\)\r\n是否合法（即成为某个方案中的 \\(t_k\\)\r\n）呢？\r\n根据意义，我们要找到一个串 \\(s[l&#39;,r&#39;]\\) 满足 \\(r&#39; &lt; l\\) 且 \\(s[l&#39;,r&#39;]\\) 为 \\(s[l,r]\\) 去掉开头或结尾且 \\(s[l&#39;,r&#39;]\\) 合法。\r\n此外，若 \\(s[l,r]\\) 合法，则 \\(s[i,r]\\) 合法 \\((l \\le i \\le r)\\)。\r\n考虑使用一个 SAM 维护右端点 \\(&lt;\r\nl\\) 的合法串的贡献。设在 SAM 上 \\(s[l,r]\\) 所在的结点为 \\(p\\)。\r\n那么在双指针的过程中，执行如下算法：\r\n\r\n设 \\(g_p\\) 表示节点 \\(p\\) 所包含的最长合法子串的长度。\r\n当 \\(r \\gets r + 1\\) 时，检查当前的\r\n\\(s[l,r]\\) 是否合法，即 \\(s[l,r - 1]\\) 和 \\(s[l + 1,r]\\) 在 SAM 上的点的 \\(g\\) 的较大值是否 \\(\\ge r - l\\)。\r\n如果 \\(s[l,r]\\) 合法，那么令 \\(f_i = r - l + 1\\)，令 \\(N_i\\) 为该串在 SAM 上的节点 \\(p\\)。并回到第二步。\r\n如果 \\(s[l,r]\\)\r\n不合法，那么我们需要在 SAM 上更新 \\(g\\)\r\n的信息，这个时候 \\(N_i\\)\r\n就有用了，因为我们已经将 \\(l\\)\r\n开头的合法串信息存在了 \\(N_l\\)\r\n里。我们先让 \\(g_{N_l}\\) 与 \\(f_l\\) 取 \\(\\max\\)，再跳 \\(N_l\\) 的父亲 \\(t\\)，这个时候 \\(g_t\\) 应该变为 \\(len_t\\)。如果当前的 \\(g_t\\) 不为 \\(len_t\\)，就将其置为 \\(len_t\\)，否则可以直接 break，因为如果 \\(g_t = len_t\\)，\\(t\\) 的祖先 \\(a\\) 也必然满足 \\(g_a = len_a\\) 了。做完上述过程后，令 \\(l \\gets l + 1\\)，回到第三步。\r\n\r\n另外提一嘴，维护 \\(s[l,r]\\) 的节点\r\n\\(p\\)，只需要在 \\(r\\) 增大时让 \\(p\\) 沿着 DAWG 向下走一步，在 \\(l\\) 增大时，如果 \\(len_{fa_p} \\ge r - l + 1\\)，就令 \\(p = fa_p\\) 即可。\r\n#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5e5 + 5,Sz = N &lt;&lt; 1;int n;int ch[Sz][26],len[Sz],link[Sz],tot = 1,las = 1;int f[Sz];char s[N];int Nd[N],Ans[N];inline void extend(int c)&#123;\tint cur = ++tot,p = las;\tlen[cur] = len[p] + 1;\twhile(p &amp;&amp; !ch[p][c]) ch[p][c] = cur,p = link[p];\tif(!p) link[cur] = 1;\telse\t&#123;\t\tint q = ch[p][c];\t\tif(len[p] + 1 == len[q]) link[cur] = q;\t\telse\t\t&#123;\t\t\tint clone = ++tot;\t\t\tfor(int i = 0;i &lt; 26;i++)\t\t\t\tch[clone][i] = ch[q][i];\t\t\tlink[clone] = link[q];\t\t\tlen[clone] = len[p] + 1;\t\t\twhile(p &amp;&amp; ch[p][c] == q) ch[p][c] = clone,p = link[p];\t\t\tlink[cur] = link[q] = clone;\t\t&#125;\t&#125;\tlas = cur;&#125;inline void Upd(int p,int v)&#123;\tif(v &lt;= f[p]) return;\tf[p] = v;p = link[p];\twhile(p &amp;&amp; f[p] != len[p]) f[p] = len[p],p = link[p];&#125;int main()&#123;\tcin &gt;&gt; n;\tcin &gt;&gt; (s + 1);\tstd::reverse(s + 1,s + n + 1);\tfor(int i = 1;i &lt;= n;i++)\t\textend(s[i] - &#x27;a&#x27;);\tint l = 1,p = 1,ans = 0;\tfor(int r = 1;r &lt;= n;r++)\t&#123;\t\tint q = p;\t\tp = ch[p][s[r] - &#x27;a&#x27;];\t\twhile(l &lt; r)\t\t&#123;\t\t\tif(max(max(f[p],f[q]),f[link[p]]) &gt;= r - l) break;\t\t\tUpd(Nd[l],Ans[l]);++l;\t\t\tif(len[link[p]] &gt;= r - l + 1) p = link[p];\t\t\tif(len[link[q]] &gt;= r - l) q = link[q];\t\t&#125;\t\tNd[r] = p;Ans[r] = r - l + 1;\t\tans = max(ans,r - l + 1);\t&#125;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n关键在于这个 DP\r\n状态，非常巧妙地把题目中各类性质和对象统一了起来。\r\n","tags":["DP","string theory"]},{"title":"ARC121F 题解","url":"/posts/4126244439/","content":"本题一开始读错题了，把题目加强了好多。（\r\n本题有经典的去叶子归纳法，值得学习。\r\n\r\n考虑知道了标号之后怎么判断合法。\r\n考虑一个叶子和其连向父亲的边。\r\n如果边是 OR，点是 \\(1\\)，原问题一定有解。\r\n如果边是 OR，点是 \\(0\\)，或者边是\r\nAND，点是 \\(1\\)，那这个叶子对答案没有影响，可以直接舍弃。\r\n如果边是 AND，点是 \\(0\\)，要尽量早的把这个叶子缩掉，这样对后面的危害最小。\r\n把这个步骤由深往浅的归纳，就会发现，我们对一棵子树只需要记录两个信息：最终的权值，以及有没有一个连通块向外恰好连了一条\r\nOR 边 且最终权值为 \\(1\\) 。\r\n说白了就是记录在整个过程中，有没有出现 \"OR 1\" 型的叶子。\r\n设出状态 \\(f_{x,0/1/2}\\) 表示 \\(x\\) 子树的最终权值为 \\(0\\) / 为 \\(1\\) 且没有 \"OR 1\" 型叶子 / 有 \"OR 1\"\r\n型叶子。\r\n那么状态转移如下： \\[\r\n\\begin{aligned}\r\nf&#39;_{x,0} &amp;\\gets 2f_{x,0}f_{y,0} + f_{x,1}f_{y,0} +\r\nf_{x,0}f_{y,1} \\\\\r\nf&#39;_{x,1} &amp;\\gets f_{x,1}(f_{y,1} + f_{y,0}) \\\\\r\nf&#39;_{x,2} &amp;\\gets 2(f_{x,2}(f_{y,0} + f_{y,1} + f_{y,2}) +\r\nf_{y,2}(f_{x,0} + f_{x,1})) + f_{y,1}(f_{x,0} + f_{x,1}) \\\\\r\n\\end{aligned}\r\n\\] 第一行：\\(0\\) and \\(0\\)，\\(0\\)\r\nor \\(0\\)，\\(1\\) and \\(0\\)，\\(0\\)\r\nand \\(1\\)。\r\n第二行： 因为没有 \"OR 1\" 型叶子，\\(y\\) 子树必须是 \"AND 1\" 或者 \"OR 0\"，那么\r\n\\(x\\) 所属连通块权值必然为 \\(1\\)。\r\n第三行：前面是任意一侧有 \"OR 1\" 型叶子的情况，后面是 \\(y\\) 子树是 \"OR 1\" 型叶子的情况。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5,P = 998244353;inline int Add(int a,int b) &#123; return (a + b &gt;= P) ? (a + b - P) : (a + b);&#125;int n;vector&lt;int&gt; G[N];int f[N][3];void dp(int x,int fa)&#123;\tf[x][0] = f[x][1] = 1;\tfor(auto y : G[x])\t&#123;\t\tif(y == fa) continue;\t\tdp(y,x);\t\tint v0 = f[x][0],v1 = f[x][1],v2 = f[x][2];\t\tf[x][2] = Add(2ll * v2 * Add(f[y][2],Add(f[y][0],f[y][1])) % P,Add(2ll * f[y][2] * (v0 + v1) % P,1ll * f[y][1] * (v0 + v1) % P));\t\tf[x][0] = Add(Add(2ll * v0 * f[y][0] % P , 1ll * v0 * f[y][1] % P),1ll * v1 * f[y][0] % P);\t\tf[x][1] = 1ll * v1 * (f[y][1] + f[y][0]) % P;\t&#125;\t&#125;int main()&#123;\tcin &gt;&gt; n;\tfor(int i = 1;i &lt; n;i++)\t&#123;\t\tint x,y;\t\tcin &gt;&gt; x &gt;&gt; y;\t\tG[x].push_back(y);\t\tG[y].push_back(x);\t&#125;\tdp(1,0);\tcout &lt;&lt; Add(f[1][1],f[1][2]) &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["counting","tree"]},{"title":"ARC110E 题解","url":"/posts/2268255988/","content":"本题我是想到了个做法的，成功的过了第一个样例，后来与题解比对，发现我的做法考察的条件还是太弱了（\r\n\r\n容易发现，最后的每个字符都是由原串的一段区间操作得来的。\r\n把 A,B,C 的权值分别看成 \\(1,2,3\\)，那么一次操作相当于替换为异或和。\r\n考虑选出一段区间能干嘛：\r\n\r\n如果这段区间的异或和为 \\(0\\)，显然不能操作为单个字符。\r\n如果这段区间只有一种字符，显然啥都干不了。\r\n除开上述两种情况，归纳可得这段区间肯定能被操作成单个字符。我们称这类区间为\r\n“好段”\r\n\r\n（我之前的做法默认区间长度 \\(\\le\r\n4\\)，理所当然的寄了）\r\n然后就是利用常规的思维模式，考虑如何让原串 \\(S\\) 唯一映射到能被构造出来的串 \\(T\\)。\r\n首先 \\(T\\) 的异或和要等于 \\(S\\) 的异或和。\r\n其次，我们在找方案的时候，只考虑每个“好段”右端点最靠前的方案。\r\n有一个转移方法是，每次选一个最短的可行的段向后转移，如果 \\(T\\)\r\n的最后一个字符取完了但还有剩余，就把剩下的字符全部补在后面（显然这些字符异或和肯定为\r\n\\(0\\)）。\r\n为了说明正确性，我们要说明对于可以被构造的串 \\(T\\)，上述方法一定能够构造一个方案。\r\n我们取出串 \\(T\\)\r\n的任意一个方案，去掉第一个“好段”的最长的异或和 \\(0\\)\r\n的后缀，且保证去掉后第一段仍是“好段”，把这段后缀接在第二个”好段“的前方，以此类推，这样得到的方案就能被上面的转移方法所表示。\r\n那么我们设 \\(dp[i]\\) 表示处理了前\r\n\\(i\\) 个字符的方案数，预处理 \\(nxt[i][k]\\) 表示 \\(i\\) 位置往后最短的异或和为 \\(k\\) 的“好段”，据此转移即可。\r\n最后取出 \\(i + 1 \\sim n\\) 的异或和为\r\n\\(0\\) 的位置 \\(i\\)，将答案加上 \\(f[i]\\) 即可。\r\n注意整个串清一色要特判，这个时候补 \\(0\\) 操作是错的，但答案为 \\(1\\)。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5,P = 1e9 + 7;int n;char s[N];int f[N];int ton[4],nxt[N][4];int sum[N];int main()&#123;\tcin &gt;&gt; n &gt;&gt; (s + 1);\tint flg = 1;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tif(i &lt; n) flg &amp;= (s[i] == s[i + 1]);\t\tsum[i] = sum[i - 1] ^ (s[i] == &#x27;A&#x27; ? 1 : (s[i] == &#x27;B&#x27; ? 2 : 3));\t&#125;\tif(flg) return puts(&quot;1&quot;),0;\tfor(int i = 1;i &lt;= 3;i++)\t\tton[i] = n + 1;\tfor(int i = n;i &gt;= 0;i--)\t&#123;\t\tton[sum[i]] = i;\t\tfor(int k = 0;k &lt;= 3;k++)\t\t\tif(k != sum[i])\t\t\t\tnxt[i][sum[i] ^ k] = ton[k];\t\tnxt[i][sum[i] ^ sum[i + 1]] = i + 1;\t&#125;\tf[0] = 1;\tfor(int i = 0;i &lt; n;i++)\t\tfor(int k = 1;k &lt;= 3;k++)\t\t\t(f[nxt[i][k]] += f[i]) %= P;\tint ans = 0;\tfor(int i = 1;i &lt;= n;i++)\t\tif(sum[i] == sum[n])\t\t\t(ans += f[i]) %= P;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["DP"]},{"title":"CF388D 题解","url":"/posts/2809317364/","content":"题意：给出一个数 \\(K\\)，求最大元素\r\n\\(\\le K\\) 的线性空间数量，对 \\(10^9 + 7\\) 取模。\r\n\r\n计数线性空间，我们有必要了解一个叫“简化线性基”的东西。\r\n下文的矩阵中，每一行就是线性基每一个元素的二进制拆分，从左到右是从高位到低位。\r\n一般我们构建的线性基，在每一行的第一个 \\(1\\) 上方，还可能有其它的 \\(1\\)，比如这样： \\[\r\n\\begin{bmatrix}\r\n1 &amp; 1 &amp; 0 &amp; 0 \\\\\r\n0 &amp; 1 &amp; 1 &amp; 0 \\\\\r\n0 &amp; 0 &amp; 0 &amp; 1 \\\\\r\n\\end{bmatrix}\r\n\\]\r\n在上面的例子中，我们把第一行异或上第二行，就可以得到一个本质相同的线性基：\r\n\\[\r\n\\begin{bmatrix}\r\n1 &amp; 0 &amp; 1 &amp; 0 \\\\\r\n0 &amp; 1 &amp; 1 &amp; 0 \\\\\r\n0 &amp; 0 &amp; 0 &amp; 1 \\\\\r\n\\end{bmatrix}\r\n\\] 熟悉线性代数的读者可能知道，这就是一个简化阶梯形矩阵。\r\n这样的矩阵满足对于每行的第一个非 \\(0\\) 元素，它的上方全都是 \\(0\\)。\r\n这样的线性基被成为简化线性基，它具有一些其它线性基没有的性质：\r\n\r\n这种基能张成的最大元素就是每一行的异或和（最高位选了肯定更优）\r\n一个简化线性基唯一对应一个线性空间，因为两个简化线性基不能通过行与行的相互异或来得到对方\r\n\r\n这两条性质恰恰与题目的限制吻合。\r\n我们只需计数每行的异或和 \\(\\le K\\)\r\n，且每行第一个 \\(1\\) 上方都是 \\(0\\) 的矩阵个数即可。\r\n数位 DP，设状态 \\(f[pos][cnt][done]\\) 表示现在处理到第 \\(pos\\) 列，线性基一共加入了 \\(cnt\\)\r\n个元素，当前的异或和有没有顶到上界。\r\n分类讨论：\r\n\r\n如果没有顶到上界，那么对于这一列，我们可以不新开元素，已经加入的\r\n\\(cnt\\)\r\n个元素在这一列就可以随意取值，方案数为 \\(2^{cnt}\\)\r\n，如果新开元素，已有的元素在这一列必须为 \\(0\\)，方案数为 \\(1\\)。\r\n如果顶到了上界：\r\n\r\n如果我们令这一位的异或和为 \\(0\\)，那么就无法新开元素，只能让已有的 \\(cnt\\) 个元素保证异或和为 \\(0\\)，方案数为 \\(2^{cnt - 1}\\)。\r\n如果我们令这一维的异或和为 \\(1\\)，我们可以新开一个元素，也可以不新开元素，并保证已有的元素异或和为\r\n\\(1\\)，方案数也为 \\(2^{cnt - 1}\\)（注意特判 \\(cnt = 0\\) 的情况）\r\n\r\n\r\n本题至此已经结束，是一道考察对线性基理解和相关应用的好题，如果有线性代数的知识储备，理解线性基也不是什么难事。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 40,P = 1e9 + 7;int f[N][N][2];int Pow2[N];int K;int dfs(int pos,int cnt,int done)&#123;\tif(pos == -1) return 1;\tif(~f[pos][cnt][done]) return f[pos][cnt][done];\tint res = 0,num = ((long long)K &gt;&gt; pos) &amp; 1;\tif(!done)\t\tres = (dfs(pos - 1,cnt + 1,done) + 1ll * Pow2[cnt] * dfs(pos - 1,cnt,done) % P) % P;\telse\t&#123;\t\tres = 1ll * (cnt ? Pow2[cnt - 1] : 1) * dfs(pos - 1,cnt,!num) % P;\t\tif(num)\t\t\tres = (res + 1ll * (cnt ? Pow2[cnt - 1] : 0) * dfs(pos - 1,cnt,1) % P) % P,\t\t\tres = (res + dfs(pos - 1,cnt + 1,1)) % P;\t&#125;\tf[pos][cnt][done] = res;\treturn res;&#125;int main()&#123;\tcin &gt;&gt; K;\tPow2[0] = 1;\tfor(int i = 1;i &lt; N;i++)\t\tPow2[i] = 2ll * Pow2[i - 1] % P;\tmemset(f,-1,sizeof f);\tcout &lt;&lt; dfs(N - 1,0,1) &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["counting","linear algebra"]},{"title":"ARC130E 题解","url":"/posts/2210858697/","content":"思路基本全部正确，但是棋差一着，没有注意到转移点只有一个。\r\n说明所谓的思维题，并没有那么不可做。\r\n\r\n题意：对于一个长度为 \\(n\\)\r\n的正整数序列 \\(A\\)\r\n，定义一次操作为：选出最小值所在的位置（多个则任取），将下标加入 \\(B\\) 序列的末尾，并将对应位置 \\(+1\\)。\r\n我们做了 \\(K\\) 次操作，得到了序列\r\n\\(B\\)。现在你知道序列 \\(B\\)，须求出是否存在一个初始序列 \\(A\\) 能得到这个 \\(B\\)，存在则输出字典序最小解。\r\n\\(1 \\le n,K \\le 3 \\times\r\n10^5\\)。\r\n观察一个 \\(A\\)\r\n序列在操作过程中发生的变化。\r\n我们发现，我们会先把当前所有的最小值 \\(+1\\)，然后再取出当前的所有最小值，再全部\r\n\\(+1\\)。\r\n因此，我们定义 \\(C_i\\) 为第 \\(i\\) 次操作前的序列最小值，那么 \\(0 \\le C_{i+1} - C_i \\le 1\\)。\r\n\\(C_i\\)\r\n的变化有明显的分段特征，我们考虑把 \\(B\\) 序列分段，每段的 \\(C_i\\) 都是一样的。\r\n稍微手玩一下可以得到分段方案合法的充要条件：\r\n除最后一段外，每段中出现的元素集合都必须包含上一段出现的所有元素。这也等价于必须包含这一段之前出现的所有元素。\r\n最后一段我们等会考虑，先考虑前面的段。\r\n我们考虑对于一个右端点 \\(r\\)，什么样的左端点 \\(l\\) 可以使 \\([l,r]\\)\r\n被分为合法段，显然，这与其他的段怎么划分是没有关系的。\r\n首先，\\([1,r]\\)\r\n中出现的元素，都必须在 \\([l,r]\\)\r\n中出现。同时，\\([l,r]\\)\r\n中不能出现重复的元素。\r\n设 \\([1,r]\\) 中有 \\(t\\) 个不同元素，那么 \\(l\\) 要么是 \\(r -\r\nt + 1\\)，要么无解。这说明对于每个 \\(r\\) 只有最多一个合法的 \\(l\\)。\r\n而对于最后一段而言，它合法只需要没有重复元素即可。\r\n上述结论表明，如果我们确定了最后一段的端点，前面的划分方案是唯一的。\r\n那么我们如何确定这个点，使得字典序最小？\r\n考虑去掉最后一段之后，所有点在操作完后应该全部相等，那么我们当然让前面的段数越少越好（因为每个点被加几次已经确定了），在段数相等的条件下，我们会选择尽量靠后的点，因为最后一段相当于在这个“相等\"的值上额外\r\n\\(+1\\)，我们当然要让这个 \\(+1\\) 越少越好。\r\n确定这个点之后，反推出初始方案即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5 + 5,inf = 0x3f3f3f3f;int n,k;int b[N],a[N];int f[N],lst[N],ton[N];int main()&#123;\tcin &gt;&gt; n &gt;&gt; k;\tfor(int i = 1;i &lt;= k;i++) cin &gt;&gt; b[i];\tint pre = 0;\tfor(int i = 1,cnt = 0;i &lt;= k;i++)\t&#123;\t\tpre = max(pre,ton[b[i]]);\t\tif(!ton[b[i]]) ++cnt;\t\tton[b[i]] = i;\t\tif(i - pre == cnt) f[i] = f[pre] + 1;\t\telse f[i] = inf;\t\t// printf(&quot;%d %d %d\\n&quot;,f[i],lst[i],cnt);\t&#125;\tint p = k;\tmemset(ton,0,sizeof ton);\tfor(int i = k;i &gt;= 1;i--)\t&#123;\t\tif(ton[b[i]]) break;\t\tton[b[i]] = true;\t\tp = i;\t&#125;\tint Mn = -1;\tfor(int i = p - 1;i &lt; k;i++)\t\tif(Mn == -1 || f[i] &lt;= f[Mn]) Mn = i;\tif(f[Mn] &gt;= inf) return puts(&quot;-1&quot;),0;\tfor(int i = 1;i &lt;= n;i++) a[i] = f[Mn] + 1;\tfor(int i = 1;i &lt;= Mn;i++) a[b[i]]--;\tfor(int i = 1;i &lt;= n;i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\\n&quot;);\treturn 0;&#125;\r\n","tags":["thinking","constructive algorithm"]},{"title":"CF1286E Fedya the Potter Strikes Back 题解","url":"/posts/2273955663/","content":"事实证明卡住的地方比我预想的要弱智一些，构思的时候已经想到了均摊，但对\r\nborder\r\n的变化规律似乎缺乏更深的理解，也对最值相关缺乏研究，导致没有想到另一个均摊。\r\n\r\n当然，这题也带来一个直觉，就是 border 相关的工程一般比较轻量级。\r\n第一眼是 border 的四种求法中的 SAM，后来发现显然不用这么复杂，考虑\r\nKMP 的过程即可。\r\n注意到一个前缀的所有 border 是 KMP\r\n失配树上的一条祖先链。想借此维护，但变化量看上去并不小，主要是 \\(nxt[i]\\) 变为 \\(nxt[i - 1] + 1\\)\r\n的时候，可能接上了一条完全不同的祖先链，然后就卡在这儿了。\r\n但事实上，我们直接考虑每个 border\r\n串，在加入一个字符之后，它要么长度也加 \\(1\\)，要么就不是 border 串了。\r\n注意到处理完上述变化之后，最多只会有一个长度为 \\(1\\) 的 border 串新加入进来（因为剩下的\r\nborder 串都是由上一轮的 border 整体加 \\(1\\) 而来）。\r\n所以删除操作可以暴力执行，我们可以找到每个要删除的 border\r\n串，然后更新相应的信息。\r\n那么如何快速找到那些要删除的 border 串呢。\r\n之前说过，一个前缀的所有 border 是失配树上的祖先链，也就是 \\(nxt_i,nxt_{nxt_i},\\dots,0\\)，我们对于每个\r\n\\(i\\)，维护最深的一个后继字符与它不同的祖先\r\n\\(anc[i]\\)，即满足 $s[i + 1] !=\r\ns[anc[i] + 1] $ 的最深的点。在遍历祖先的过程中，使用 \\(anc[i]\\) 加速即可。\r\n至于 border 串长整体 \\(+1\\)\r\n怎么做，设当前加入了 \\(n\\)\r\n个字符，考察一个长度为 \\(l\\) 的 \\(border\\) 串，它的区间从加入前的 \\([n - l + 1,n - 1]\\) 变为了 \\([n - l +\r\n1,n]\\)，我们发现，对于这些串，它们的权值只是对当前加入的 \\(w_n\\) 取了个 \\(\\min\\)。\r\n那么现在就是要维护一堆数，支持对所有数取 \\(\\min\\) 和维护和。\r\n我们可以用 map 维护每种权值的出现次数，要对 \\(w_i\\) 取 \\(\\min\\) 时，把比 \\(w_i\\) 大的权值都直接变为 \\(w_i\\) 即可。\r\n考察 map 中不同元素个数的变化情况，容易证明这里的均摊复杂度是 \\(\\Theta(n \\log n)\\) 的。\r\n所以总时间复杂度是 \\(\\Theta(n \\log\r\nn)\\) 的。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;template&lt;typename T&gt;inline void write(const T &amp;a)&#123;\tif(a &gt;= 10) write(a / 10);\tputchar(a % 10 + &#x27;0&#x27;);&#125;const int N = 6e5 + 5,MASK = (1 &lt;&lt; 30) - 1;typedef long long ll;typedef __int128 lll;int n;int w[N],s[N];int stk[N],top;map&lt;int,int&gt; mp;int nxt[N];ll ans;lll lastans;int anc[N]; // 第一个后继字符与其不同的祖先，找到那些被删除的 borderinline int Qpos(int pos)&#123;\treturn w[*lower_bound(stk + 1,stk + top + 1,pos)];&#125;int main()&#123;\tcin &gt;&gt; n;\tint j = 0;\tnxt[1] = 0;\tchar ch;\tcin &gt;&gt; ch &gt;&gt; w[1];\ts[1] = ch - &#x27;a&#x27;;\tlastans = w[1];\tstk[++top] = 1;\twrite(lastans);\tputchar(&#x27;\\n&#x27;);\tfor(int i = 2;i &lt;= n;i++)\t&#123;\t\tchar ch;\t\tcin &gt;&gt; ch &gt;&gt; w[i];ch -= &#x27;a&#x27;;\t\tw[i] ^= lastans &amp; MASK;\t\ts[i] = (ch + lastans) % 26;\t\twhile(j &amp;&amp; s[i] != s[j + 1]) j = nxt[j];\t\tif(s[i] == s[j + 1]) ++j;\t\tnxt[i] = j;\t\tif(s[i] == s[nxt[i - 1] + 1]) anc[i - 1] = anc[nxt[i - 1]];\t\telse anc[i - 1] = nxt[i - 1];\t\tfor(int k = i - 1;k;)\t\t&#123;\t\t\tif(s[k + 1] == s[i]) k = anc[k];\t\t\telse\t\t\t&#123;\t\t\t\tint val = Qpos(i - k);\t\t\t\t--mp[val];\t\t\t\tif(mp[val] == 0) mp.erase(val);\t\t\t\tans -= val;\t\t\t\tk = nxt[k];\t\t\t&#125;\t\t&#125;\t\tif(s[1] == s[i])\t\t\t++mp[w[i]],ans += w[i];\t\twhile(top &amp;&amp; w[stk[top]] &gt;= w[i])\t\t\t--top;\t\tstk[++top] = i;\t\tint num = 0;\t\tauto it = mp.upper_bound(w[i]);\t\twhile(it != mp.end())\t\t&#123;\t\t\tnum += it -&gt; second;\t\t\tans -= 1ll * (it -&gt; first - w[i]) * it -&gt; second;\t\t\tmp.erase(it);\t\t\tit = mp.upper_bound(w[i]);\t\t&#125;\t\tmp[w[i]] += num;\t\tlastans += w[stk[1]] + ans;\t\twrite(lastans);\t\tputchar(&#x27;\\n&#x27;);\t&#125;\treturn 0;&#125;\r\n这是一道总结 border\r\n变化规律和最值变化规律的好题，对向后加入字符的问题，border\r\n有比较简明的变化方式；对很多数不断地 \\(\\operatorname{chkmin}\\)，也可以使用均摊复杂度做到优秀的结果。\r\n思考的大方向没有什么问题，但是细节并没有想清楚，这是需要改进的。\r\n","tags":["string theory"]},{"title":"CF1415F 题解","url":"/posts/1876701072/","content":"遇到新题型，茫然无措是必然的，但只有冷静下来，运用自己掌握的思维模式，才能从茫然中找到柳暗花明。\r\n\r\n考虑已经确定了本体和分身完成的任务集合，怎么判定合法性。\r\n设本体完成的任务为 A 类，分身完成的任务为 B 类。\r\n把 \\((t,x)\\)\r\n看成二维平面上的点，容易绘制以下图像：\r\n\r\n我们的行动轨迹需要经过上图所有的点。\r\nA 类任务可以限制人的行动轨迹，相比 B\r\n类任务具有更加”稳定“的约束，我们考虑研究两个 A 任务之间的间隔。\r\n\r\n右图是两个 A 夹着一段极长的 B ，左图是一段极长的 A。\r\n蓝色是不管 B 的路线，红色是管 B 的路线。\r\n容易发现，一段极长的 A，只会贡献一个 B，一段极长的 B\r\n的非开头部分 只会由夹着这一段的两个 A\r\n解决（开头那个被绿色圈住的部分可能已经被前一段解决）\r\n（上述图片来自 @command_block，感谢 cmd 的题解）\r\n两个 A 之间的间隔，就是一段 B 的极长连续段。\r\n假设这些 \\(B\\) 任务按时间顺序为\r\n\\(p_1,p_2,\\dots,p_k\\)，\\(p_i\\) 对应的时间区间为 \\([l_i,r_i]\\)，其实就是 \\([t_{p_{i-1}},t_{p_i}]\\)。\r\n设初始时间为 \\(t\\)，初始位置为 \\(x\\)，假设下一个任务为 \\(p_i\\)，那么如果 \\(t + | x - x_{p_i} | &gt;\r\nr_i\\)，则方案不合法，否则 \\(t\\)\r\n变为 \\(\\max(l_i,t + |x -\r\nx_{p_i}|)\\)，\\(x\\)\r\n也对应变化（对 \\(l_i\\) 取 \\(\\max\\) 是因为，假如我在 \\(t_{p_{i-1}}\\) 之前就到达了 \\(x_{p_i}\\)，我也必须等到 \\(t_{p_{i-1}}\\)\r\n的时候才能撤销原本放在那里的分身，把它移到当前位置）\r\n观察上述的贪心算法，我们只需在 \\(dp\\) 的时候维护上面的 \\(t\\) ，然后一个一个加入 B 类任务即可。\r\n具体地，设 \\(dp_{i,0/1}\\) 表示任务\r\n\\(i\\) 是 B 类，任务 \\(i\\) 是/否已经被 \\(i - 1\\) 之前的某一段 A\r\n解决。（也就是那个绿色圈的情况）\r\n对于 \\(f_{i,0}\\) ，当前本体肯定在\r\n\\(x_i\\)，对于 \\(f_{i,1}\\)，\\(i -\r\n1\\) 是 A 类，并且本体在 \\(x_{i-1}\\)。\r\n记 \\(g_{l,r}\\) 表示任务 \\(l \\sim r\\) 是否能成为一段 A。\r\n记 \\((a,b) = |x_a - x_b|\\)。\r\n对于 \\(f_{i,0}\\):\r\n\r\n\\(i - 1\\) 是 B 类\r\n\r\n从 \\(f_{i-1,0}\\) 转移：\\(f_{i,0} \\gets \\max(f_{i-1,0} + (i - 1,i),t_{i-1})\r\n,(f_{i-1,0} + (i - 1,i) \\le t_i)\\)\r\n从 \\(f_{i-1,1}\\) 转移：\\(f_{i,0} \\gets \\max(f_{i-1,1} + (i -\r\n2,i),t_{i-1}),(f_{i-1,1} + (i - 2,i) \\le t_i)\\)\r\n\r\n\\(i - 1\\) 是 A 类\r\n枚举 A 类极长连续段 \\([j + 1,i -\r\n1]\\)。\r\n\\(f_{i,0} \\gets t_{i - 1} + (i -\r\n1,i)\\)\r\n条件：\r\n\\(g_{j + 1,i - 1}\\) 为真\r\n且 \\(\\min(f_{j,0} + dis(j,j + 1),f_{j-1,1}\r\n+ dis(j - 1,j + 1)) \\le t_{j+1}\\) （\\(j\\) 可以走到 \\(j\r\n+ 1\\)）\r\n且 \\(t_{i-1} + (i - 1,i) \\le t_i\\)\r\n（可以从 \\(i - 1\\) 走到 \\(i\\)）\r\n\r\n对于 \\(f_{i,1}\\)：\r\n\\(f_{i,1} \\gets t_{i-1}\\)\r\n条件：\r\n枚举 A 类极长连续段 \\([j + 1,i -\r\n1]\\)。\r\n存在一个 \\(j\\) 满足：\r\n\r\n\\(g_{j +1,i - 1}\\) 为真\r\n且 \\(\\min(f_{j,0} + dis(j,j +\r\n1),f_{j-1,1} + dis(j - 1,j + 1)) \\le t_{j+1}\\) （\\(j\\) 可以走到 \\(j\r\n+ 1\\)）\r\n且存在一个 \\(k \\in [j + 1,i - 2],(i,k)\r\n+ (i,k + 1) \\le t_{k + 1} - t_k\\)\r\n（存在一个空隙使得人可以拐出来，先放好分身再走回去） 或者 \\(\\max(\\min(f_{j,0} + dis(j,i),f_{j,1} + dis(j -\r\n1,i)),t_j) + dis(i,j + 1) \\le t_{j+1}\\) （这一段 A 的开头和上一段\r\nB 的结尾之间有个空隙可以让人出来放分身）\r\n\r\n把转移都分讨完后，代码就比较简单了：\r\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll llinf = 0x3f3f3f3f3f3f3f3f;const int N = 5e3 + 5;int n;struct node &#123;ll x,t;&#125; p[N];bool cmp(const node &amp;a,const node &amp;b) &#123; return a.t &lt; b.t;&#125;ll dis(int x,int y) &#123; return abs(p[x].x - p[y].x);&#125;ll f[N][2];bool g[N];int main()&#123;\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++)\t\tcin &gt;&gt; p[i].t &gt;&gt; p[i].x;\tp[++n].t = 0;p[n].x = 0;\tp[++n].t = llinf - 1;p[n].x = 0;\tsort(p + 1,p + n + 1,cmp);\tf[1][1] = llinf;\tfor(int i = 2;i &lt;= n;i++)\t&#123;\t\tg[i - 1] = dis(i - 1,i) &lt;= p[i].t - p[i - 1].t;\t\tf[i][0] = f[i][1] = llinf;\t\tll now = f[i - 1][0] + dis(i - 1,i);\t\tif(now &lt;= p[i].t) f[i][0] = min(f[i][0],max(now,p[i - 1].t));\t\tnow = f[i - 1][1] + dis(i - 2,i);\t\tif(now &lt;= p[i].t) f[i][0] = min(f[i][0],max(now,p[i - 1].t));\t\tbool flag = 0;\t\tfor(int j = i - 2;j &gt;= 1;j--) // 枚举 A 类极长连续段 [j + 1,i - 1]\t\t&#123;\t\t\tif(j + 2 &lt; i)\t\t\t&#123;\t\t\t\tif(!g[j + 1]) break;\t\t\t\tflag |= (dis(i,j + 1) + dis(i,j + 2) &lt;= p[j + 2].t - p[j + 1].t);\t\t\t&#125;\t\t\t// B 类 j 要接上 A 类 j + 1\t\t\tif(min(f[j][0] + dis(j,j + 1),f[j][1] + dis(j - 1,j + 1)) &lt;= p[j + 1].t)\t\t\t&#123;\t\t\t\tif(flag || max(min(f[j][1] + dis(j - 1,i),f[j][0] + dis(j,i)),p[j].t) + dis(i,j + 1) &lt;= p[j + 1].t)\t\t\t\t\tf[i][1] = p[i - 1].t;\t\t\t\tif(g[i - 1]) f[i][0] = min(f[i][0],p[i - 1].t + dis(i - 1,i));\t\t\t&#125;\t\t&#125;\t&#125;\tif(min(f[n][0],f[n][1]) &lt; llinf) puts(&quot;YES&quot;);\telse puts(&quot;NO&quot;);\treturn 0;&#125;\r\n总的来说，是一道比较复杂的 DP 题，非常具有 CF\r\n风格，虽然最后的转移情况很多，但并没有思维上的难度，真正的难点主要在前面的状态设计和对问题的刻画。注意到\r\nA 类和 B 类各自的贡献条件是十分重要的，这样才能开始后面的转化。\r\n愈是复杂，愈要冷静。\r\n","tags":["DP"]},{"title":"P6789 题解","url":"/posts/2277016046/","content":"要打开此题的突破口，Kruskal 和拆贡献都要想到。我只想到了 Kruskal\r\n，所以寄了。大概在此种计数最优方案的题中，以已有的最优化算法为基础，进行贡献拆解是常见的套路。\r\n类似的题还有：P4517 JSOI2018 防御网络。\r\n\r\n对于一张确定的图，这道题是要我们求出边权和最大的基环树森林。\r\n而基环树森林与生成树是类似的，可以套用 Kruskal\r\n算法的模型，将边从大到小排序，如果加入一条边仍满足条件就加进去（因为\r\n“基环树森林”\r\n的限制可以像“生成树”一样导出一个拟阵，所以我们才能贪心地加边）。\r\n那么我们考察某一条边 \\((u,v,w)\\)\r\n的贡献，看它什么时候会被加进去。\r\n假设我们已经做完了边权大于 \\(w\\)\r\n的所有边，那么这条边就面临两种产生贡献的情况：\r\n\r\n\\(u,v\\)\r\n连通，且该连通块是棵树，\r\n\\(u,v\\)\r\n不连通，且连起来的两个连通块要么是树，要么是基环树，且不都是基环树。\r\n\r\n我们发现第二类贡献的形式非常麻烦，首先这个基环树的限制不好处理，其次我们还要讨论三种情况。\r\n正难则反，我们考虑这条边不会产生贡献的情况。\r\n那就是：\r\n\r\n\\(u,v\\)\r\n连通，且该连通块不是树。\r\n\\(u,v\\)\r\n不连通，且连起来的两个连通块都不是树。\r\n\r\n对于第一类贡献，考虑算出 \\(f[S]\\)\r\n表示点集 \\(S\\)\r\n的导出子图的生成树个数，这可以通过枚举子集做到 \\(\\Theta(3^n)\\)。\r\n具体地，枚举最后加入的一条边所连接起的两个连通块 \\(T\\) 和 \\(S-T\\)，然后在连接这两个连通块的边中任选一条作为“最后加入的一条边”\r\n即可。\r\n为了避免重复的枚举，我们选出一个特殊点 \\(pos\\)，钦定 \\(T\\)\r\n包含这个点。（在很多图计数中，会看到“枚举 \\(1\\)\r\n号点所在的连通块”，其实就是这个意思，避免算重）\r\n（注意：类加完答案之后要除以 \\(|S| -\r\n1\\)，因为同一棵树会被这种方法算这么多次）\r\n如何快速求出两个连通块之间连了多少条边？预处理 \\(cnt[S]\\) 表示点集 \\(S\\) 的导出子图有多少条边，那么边数就是\r\n\\(cnt[S] - cnt[T] - cnt[S - T]\\)。\r\n我们还要算出 \\(g[S]\\) 表示点集 \\(S\\)\r\n的导出子图的连通子图的个数，这个也可以用一个容斥做到 \\(\\Theta(3^n)\\)，即枚举特殊点 \\(pos\\) 所在的连通块点集。\r\n那么第一类贡献就很好计算了，直接枚举 \\(u,v\\) 所在的连通块即可。\r\n第二类贡献也很好计算，我们枚举 \\(u,v\\) 分别属于哪两个连通块，设为 \\(A,B\\)，那因为一个连通块 \\(S\\) 不是树的方案数就是 \\(g[S] - f[S]\\)，贡献系数就是 \\((g[A] - f[A])(g[B] - f[B])\\)，因为在 \\(A\\cup B\\) 外的边可以任意排布，我们还需乘上\r\n\\(cnt[U - A - B]\\)，其中 \\(U\\) 为全集。\r\n注意到上面算的一直都是方案数，我们除以总数将其转为概率，再用总概率\r\n\\(\\dfrac{1}{2}\\) 去减即可（\\(\\dfrac{1}{2}\\)\r\n是因为当前考虑的这条边必须选）。\r\n总时间复杂度为 \\(\\Theta(m\r\n3^n)\\)，略微卡常，需要一些剪枝。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 17,Sz = 1 &lt;&lt; 15,M = 65,P = 998244353;inline int Add(int a,int b) &#123; return (a + b &gt;= P) ? (a + b - P) : (a + b);&#125;inline int Sub(int a,int b) &#123; return (a &lt; b) ? (a - b + P) : (a - b);&#125;inline int qpow(int a,int b) &#123; int res = 1;while(b) &#123;if(b&amp;1) res = 1ll * res * a % P;a = 1ll * a * a % P;b &gt;&gt;= 1;&#125; return res;&#125;struct Edge&#123;\tint u,v,w;\tEdge()&#123;&#125;\tEdge(const int _u,const int _v,const int _w):\t\tu(_u),v(_v),w(_w)&#123;&#125;\tbool operator &lt; (const Edge &amp;rhs) const &#123; return w &gt; rhs.w;&#125;&#125;;int n,m;Edge e[M];int f[Sz],g[Sz];int pop[Sz];int cnt[Sz]; // 每个点集的导出子图的边数int Pow2[M];int inv[N];int Solve(int x) // 当前扫到第 x 条边&#123;\tmemset(cnt,0,sizeof cnt);\tfor(int i = 1;i &lt; x;i++)\t\t++cnt[(1 &lt;&lt; e[i].u) | (1 &lt;&lt; e[i].v)];\tfor(int j = 0;j &lt; n;j++)\t\tfor(int i = 0;i &lt; (1 &lt;&lt; n);i++)\t\t\tif((i &gt;&gt; j) &amp; 1)\t\t\t\tcnt[i] += cnt[i ^ (1 &lt;&lt; j)];\tf[0] = g[0] = 0;\tint all = (1 &lt;&lt; n) - 1;\tfor(int S = 1;S &lt;= all;++S)\t&#123;\t\tif(pop[S] == 1) &#123;f[S] = g[S] = 1;continue;&#125;\t\tif(cnt[S] &lt; pop[S] - 1) &#123; f[S] = g[S] = 0;continue;&#125;\t\tf[S] = 0;g[S] = Pow2[cnt[S]];\t\tint z = S &amp; (-S),w = S ^ z;\t\tfor(int T = w;T;T = (T - 1) &amp; w)\t\t&#123;\t\t\tint bu = S ^ T,num = cnt[S] - cnt[T] - cnt[bu]; // bu 中包含了特殊点 z\t\t\tf[S] = Add(f[S], 1ll * f[T] * f[bu] % P * num % P);\t\t\tg[S] = Sub(g[S],1ll * g[bu] * Pow2[cnt[T]] % P);\t\t&#125;\t\tf[S] = 1ll * f[S] * inv[pop[S] - 1] % P;\t&#125;\tfor(int S = 1;S &lt;= all;++S)\t\tg[S] = Sub(g[S],f[S]);\tint res = 0;\tint u = 1 &lt;&lt; e[x].u,v = 1 &lt;&lt; e[x].v;\tfor(int S = 1;S &lt;= all;++S)\t&#123;\t\tif(!(S &amp; u) || !(S &amp; v)) continue;\t\tres = Add(res,1ll * g[S] * Pow2[cnt[all ^ S]] % P);\t&#125;\t// 第二类贡献\tfor(int A = 1;A &lt;= all;++A)\t&#123;\t\tif((A &amp; v) || !(A &amp; u)) continue;\t\tint buA = all ^ A;\t\tfor(int B = buA;B;B = (B - 1) &amp; buA)\t\t&#123;\t\t\tif(!(B &amp; v)) continue;\t\t\tres = Add(res,1ll * g[A] * g[B] % P * Pow2[cnt[all ^ A ^ B]] % P);\t\t&#125;\t&#125;\tint allp = (P + 1) / 2;\tres = 1ll * res * qpow(Pow2[x],P - 2) % P;\tres = Sub(allp,res);\tres = 1ll * res * e[x].w % P;\treturn res;&#125;int main()&#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1;i &lt;= m;i++)\t&#123;\t\tcin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;\t\t--e[i].u;--e[i].v;\t&#125;\tsort(e + 1,e + m + 1);\t\tfor(int i = 1;i &lt; (1 &lt;&lt; n);i++) pop[i] = pop[i &gt;&gt; 1] + (i &amp; 1);\tPow2[0] = 1;\tfor(int i = 1;i &lt;= m;i++) Pow2[i] = 2ll * Pow2[i - 1] % P;\tinv[1] = 1;\tfor(int i = 2;i &lt;= n;i++) inv[i] = 1ll * inv[P % i] * (P - P / i) % P;\tint ans = 0;\tfor(int i = 1;i &lt;= m;i++)\t\tans = Add(ans,Solve(i));\tcout &lt;&lt; ans &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["counting","graph theory"]},{"title":"ABC221G 题解","url":"/posts/348044818/","content":"转化题意还是很妙的，但后半部分不知道如何评价。 \r\n看到题之后，一眼会有一个直接考虑四种方向，直接 DP\r\n的思路，显然做不得。\r\n问题主要在于没法将两维独立开来。\r\n这说明直接考虑 \\((x,y)\\)\r\n行不通，我们得考察一些性质更好的量。\r\n考察 \\((x + y,x - y)\\)（即将坐标轴\r\n45 度旋转，我也不知道出题人是怎么想到的）\r\n如果 \\(x \\gets x + D\\)，那么 \\(x + y\\) 和 \\(x -\r\ny\\) 都会加上 \\(D\\)。\r\n如果 \\(x \\gets x -D\\)，那么 \\(x + y\\) 和 \\(x -\r\ny\\) 都会减去 \\(D\\)。\r\n如果 \\(y \\gets y + D\\)，那么 \\(x + y\\) 会加 \\(D\\)，\\(x -\r\ny\\) 会减 \\(D\\)。\r\n如果 \\(y \\gets y - D\\)，那么 \\(x + y\\) 会减 \\(D\\)，\\(x -\r\ny\\) 会加 \\(D\\)。\r\n容易发现，此时 \\(x + y\\) 要么 \\(+D\\)，要么 \\(-D\\)，且 \\(x +\r\ny\\) 的决策和 \\(x - y\\)\r\n无关。\r\n用 bitset 优化 01 背包，看看 \\(x +\r\ny\\) 和 \\(x - y\\)\r\n是否均能被表出即可。\r\n为了避免在背包时出现负数，我们先默认每个 \\(d_i\\) 都取减号，取加号时，认为其带来 \\(2d_i\\) 的贡献。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e3 + 5,S = 3.6e6 + 5;bitset&lt;S&gt; f[N];int n,d[N],sumd;int x,y;int ans[N];int main()&#123;\tcin &gt;&gt; n &gt;&gt; x &gt;&gt; y;\tfor(int i = 1;i &lt;= n;i++) cin &gt;&gt; d[i],sumd += d[i];\tint a = x + y,b = x - y;\tif(abs(a) &gt; sumd || abs(b) &gt; sumd) return puts(&quot;No&quot;),0;\tif((a + sumd) &amp; 1) return puts(&quot;No&quot;),0;\tif((b + sumd) &amp; 1) return puts(&quot;No&quot;),0;\ta = (a + sumd) / 2;b = (b + sumd) / 2;\tf[0][0] = 1;\tfor(int i = 1;i &lt;= n;i++)\t\tf[i] = f[i - 1] | (f[i - 1] &lt;&lt; d[i]);\tif(!f[n][a] || !f[n][b]) return puts(&quot;No&quot;),0;\tputs(&quot;Yes&quot;);\tfor(int i = n;i &gt;= 1;i--)\t&#123;\t\tif(!f[i - 1][a]) &#123;ans[i] += 1;a -= d[i];&#125;\t\tif(!f[i - 1][b]) &#123;ans[i] += 2;b -= d[i];&#125;\t&#125;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\t// 默认是 -，那一位有值就是 +\t\tif(ans[i] == 0) putchar(&#x27;L&#x27;);\t\tif(ans[i] == 1) putchar(&#x27;U&#x27;);\t\tif(ans[i] == 2) putchar(&#x27;D&#x27;);\t\tif(ans[i] == 3) putchar(&#x27;R&#x27;);\t&#125;\treturn 0;\treturn 0;&#125;\r\n","tags":["DP"]},{"title":"ARC137E 题解","url":"/posts/3886443264/","content":"对与区间有关的建模不够熟悉，即使想到了根据面包师建模，也难以建出东西来。\r\n需要对这方面加以训练。\r\n\r\n题意：\r\n有 \\(n\\) 天，\\(m\\) 个面包师，第 \\(i\\) 个面包师需要花 \\(C_i\\) 元雇佣，雇佣过后，他会在第 \\(L_i\\) 到第 \\(R_i\\) 天，每天给你生产一个面包。\r\n每天有个预期销售量 \\(A_i\\)，如果你当天产出了 \\(x_i\\) 个面包，你实际只能卖出 \\(\\min(x_i,A_i)\\) 个面包。\r\n卖出一个面包可以获得 \\(D\\)\r\n元的收益。现在你是面包铺老板，请最大化自己的收益。\r\n\\(1 \\le n,m \\le 2000,1 \\le C_i,D \\le\r\n10^9\\)。\r\n对面包建模是比较寄的。\r\n那不妨根据面包师建模。\r\n先把答案取反，变成最小费用模型。\r\n尝试建边 \\(i + 1 \\to i\\)\r\n代表每一天的情况，因为这一天卖 \\(A_i\\)\r\n个面包，每个可以带来 \\(-D\\)\r\n的贡献，溢出的则没贡献，所以建边 \\((i +\r\n1,i,a_i,-D),(i+1,i,m - a_i,0)\\)。\r\n对于一个面包师，建边 \\((L_i,R_i +\r\n1,1,C_i)\\)，那么这就是一个循环流模型。我们每次增广一个圈，就相当于选择了一个面包师。\r\n注意到边有负权，我们使用带负权的最小费用流\r\n即可完成计算。\r\n因为这张图非常特殊，每个点连向 \\(S&#39;\\) 与连向 \\(T&#39;\\)\r\n的边的数量是相等的，所以我们甚至不需要虚拟源汇，直接以 \\(1\\) 为源点，\\(n +\r\n1\\) 为汇点跑就可以了。\r\n所以我们总共只需要建出三类边：\r\n\r\n\\((i,i + 1,A_i,-D)\\)\r\n\\((i,i + 1,m - A_i,0)\\)\r\n\\((L_i,R_i + 1,1,C_i)\\)\r\n\r\n注意： 本题在新图中需要保证流量不超过 \\(m\\) ，因为在新图中有可能增广出大于 \\(m\\)\r\n的流量，但这些东西是对应不回原来的流量意义的。\r\n因为这题 \\(n\\) 稍大，需要 \\(O(n^2 \\log n)\\)\r\n的原始对偶算法方可通过（我写了但被卡常乐），所以我最终使用的是 AtCoder\r\nLibrary 自带的费用流，跑得很快。\r\n#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/mincostflow&gt;#pragma GCC optimize(3)using namespace std;typedef long long ll;const ll llinf = 0x3f3f3f3f3f3f3f3f;int n,m,D;ll ans;int main()&#123;\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; D;\tatcoder::mcf_graph&lt;ll,ll&gt; G(n+2);\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tint a;\t\tcin &gt;&gt; a;\t\tG.add_edge(i,i + 1,a,D);\t\tG.add_edge(i,i + 1,m - a,0);\t\tans += 1ll * D * a;\t&#125;\tfor(int i = 1;i &lt;= m;i++)\t&#123;\t\tint l,r,c;\t\tcin &gt;&gt; l &gt;&gt; r &gt;&gt; c;\t\tG.add_edge(l,r + 1,1,c);\t&#125;\tcout &lt;&lt; ans - G.flow(1,n + 1,m).second &lt;&lt; endl;\treturn 0;&#125;\r\n","tags":["graph theory","flow"]},{"title":"Hello World","url":"/posts/1243066710/","content":"Welcome to Hexo! This is your very\r\nfirst post. Check documentation for\r\nmore info. If you get any problems when using Hexo, you can find the\r\nanswer in troubleshooting or\r\nyou can ask me on GitHub.\r\nQuick Start\r\nCreate a new post\r\n$ hexo new &quot;My New Post&quot;\r\nMore info: Writing\r\nRun server\r\n$ hexo server\r\nMore info: Server\r\nGenerate static files\r\n$ hexo generate\r\nMore info: Generating\r\nDeploy to remote sites\r\n$ hexo deploy\r\nMore info: Deployment\r\n"},{"title":"P3785 题解","url":"/posts/2705340643/","content":"妙妙题，一开始打全局平衡二叉树的单 \\(\\log\\)，300\r\n行没调出来。后来获知此题有线性做法。确实十分高妙，有一种字符串的美。\r\n\r\n题意：给出两个字符串 \\(S,T\\)，问能否将 \\(T\\) 划分为三个子串 \\(T_1,T_2,T_3\\)，并将其以某个顺序拼接可以组合出\r\n\\(S\\)，若能请构造方案。\\(n = |S| = |T| \\le 10^6\\)。\r\n看到这题，当然要分六种情况：\r\n\\(S = T_1T_2T_3\\)\r\n，直接判断即可。\r\n\\(S = T_2T_3T_1\\) 或 \\(S =\r\nT_3T_1T_2\\)，我们发现有两个部分实际上是一段，所以我们只需要考虑将\r\n\\(S\\) 划为两段，枚举端点，用 Hash\r\n判断相等即可。\r\n\\(S = T_3T_2T_1\\)\r\n这是本文要讲述的重点。\r\n构造新串 \\(P = S_1 T_n S_2 T_{n-1} \\dots\r\nS_n T_1\\) （这个转化很妙，虽然我也不知道怎么想到的）。\r\n那么原问题相当于把 \\(P\\)\r\n划分为三个长度为偶数的回文串。\r\n枚举第一个回文串 \\(P[1\\dots\r\n2x]\\)，那么问题变为判断 \\(P[2x + 1\\dots\r\n2n]\\) 是否能被划分为两个偶回文串。\r\n这里我们需要用到回文串划分的一个结论：\r\n\r\n那么，如果存在划分，那必有一种方案中有最长回文前缀或最长回文后缀。\r\n也就是说，我们如果只需找到一种回文串划分，只需考虑这个串的最长回文前缀和最长回文后缀即可。\r\n我们发现，把上述结论改成“偶回文串”，也是没有任何问题的。\r\n对 \\(P\\) 串跑一遍\r\nManacher，这样任意后缀的最长回文前缀和最长回文后缀都容易递推预处理了。\r\n具体的，设 \\(mxp_i\\) 表示 \\([i,2n]\\) 的最长回文前缀，那么有 \\(mxp_i \\ge mxp_{i - 1} - 2\\)。\r\n这样就可以从 \\(i - 1\\) 递推到 \\(i\\) 了，在 \\(i\\) 处再算上 \\(k\r\n- len[k] = i\\) 的位置的贡献即可。（\\(len[k]\\) 表示以 \\(k\\)\r\n为靠右的那个回文中心时的最长回文长度的一半）。\r\n\\(S = T_1T_3T_2\\)。\r\n枚举 \\(T_1 = S[1 \\dots i]\\) ，只需令\r\n\\(P = S_{i + 1} T_n \\dots S_n T_{i+1}\\)\r\n，然后判断是否存在偶回文划分即可。\r\n但是我们要处理很多个 \\(P\\) 。\r\n注意到 \\(P\\) 的最长偶回文前缀就是\r\n\\(T^R\\) 在 \\(S^R\\) 中对应位置的最长匹配长度 $ * 2$，用\r\nKMP 跑出这个值即可。最长偶回文后缀同理。\r\n具体细节可见代码。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;namespace FastIO &#123;\t#define iL (1 &lt;&lt; 20)\tchar ibuf[iL],*iS = ibuf + iL,*iT = ibuf + iL;\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf,1,iL,stdin),iS == iT ? EOF : *iS++) : *iS++)\ttemplate&lt;typename T&gt;\tinline void read(T &amp;a)\t&#123;\t\tchar ch;int sign = 0;\t\tfor(ch = gc();!isdigit(ch);ch = gc())\t\t\tif(ch == &#x27;-&#x27;) sign = 1;\t\ta = ch &amp; 15;\t\tfor(ch = gc();isdigit(ch);ch = gc())\t\t\ta = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch &amp; 15);\t\tif(sign) a = -a;\t&#125;\tchar Out[iL],*iter = Out;\t#define flush() fwrite(Out,1,iter - Out,stdout),iter = Out\ttemplate&lt;typename T&gt;\tinline void write(T x,char end = &#x27;\\n&#x27;)\t&#123;\t\tint c[40],l = 0;if(x &lt; 0) *iter++ = &#x27;-&#x27;,x = -x;\t\tdo c[++l] = x % 10,x /= 10; while(x);\t\twhile(l) *iter++ = c[l--] + &#x27;0&#x27;;\t\t*iter++ = end;flush();\t&#125;\t#undef iL \t#undef gc \t#undef flush&#125;using namespace FastIO;const int N = 1e6 + 5;typedef unsigned long long ull;const int base = 1333331;int n,m;int s[N],t[N];int nxt[N &lt;&lt; 1],mth[2][N &lt;&lt; 1];ull hsh[2][N],Pow[N];void KMP(int *s,int *t,int n,int *mth)&#123;\tint j = 0;nxt[1] = 0;\tfor(int i = 1;i &lt; n;i++)\t&#123;\t\twhile(j &amp;&amp; t[i + 1] != t[j + 1]) j = nxt[j];\t\tif(t[i + 1] == t[j + 1]) ++j;\t\tnxt[i + 1] = j;\t&#125;\tj = 0;\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\twhile(j &amp;&amp; s[i] != t[j + 1]) j = nxt[j];\t\tif(s[i] == t[j + 1]) ++j;\t\tif(j == i) j = nxt[j];\t\tmth[i] = j;\t&#125;&#125;inline int Hash(ull *hsh,int l,int r) &#123; return hsh[r] - hsh[l - 1] * Pow[r - l + 1];&#125;int len[N &lt;&lt; 1];int mxp[N &lt;&lt; 1],mxs[N &lt;&lt; 1];int ts[N &lt;&lt; 1];inline void work()&#123;\tread(n);read(m);\tfor(int i = 1;i &lt;= n;i++) read(s[i]);\tfor(int i = 1;i &lt;= n;i++) read(t[i]);\tPow[0] = 1;\tfor(int i = 1;i &lt;= n;i++) Pow[i] = Pow[i - 1] * base;\thsh[0][0] = 1;\tfor(int i = 1;i &lt;= n;i++) hsh[0][i] = hsh[0][i - 1] * base + s[i];\thsh[1][0] = 1;\tfor(int i = 1;i &lt;= n;i++) hsh[1][i] = hsh[1][i - 1] * base + t[i];\tint flg = 1;\tfor(int i = 1;i &lt;= n;i++) flg &amp;= (s[i] == t[i]);\tif(flg) &#123; printf(&quot;YES\\n1 1\\n2 2\\n3 %d\\n&quot;,n);return;&#125;\tfor(int i = 1;i &lt;= n;i++)\t\tif(Hash(hsh[1],1,i) == Hash(hsh[0],n - i + 1,n) &amp;&amp; Hash(hsh[1],i + 1,n) == Hash(hsh[0],1,n - i))\t\t&#123;\t\t\tif(i == 1) printf(&quot;YES\\n%d %d\\n%d %d\\n%d %d\\n&quot;,i + 1,i + 1,i + 2,n,1,i);\t\t\telse printf(&quot;YES\\n%d %d\\n%d %d\\n%d %d\\n&quot;,i + 1,n,1,1,2,i);\t\t\treturn;\t\t&#125;\tKMP(s,t,n,mth[0]);\tKMP(t,s,n,mth[1]);\tfor(int i = n;i &gt;= 1;i--)\t&#123;\t\tint l = mth[0][i];\t\tif(l &gt; 0 &amp;&amp; Hash(hsh[1],l + 1,i) == Hash(hsh[0],1,i - l))\t\t\t&#123; printf(&quot;YES\\n%d %d\\n%d %d\\n%d %d\\n&quot;,l + 1,i,1,l,i + 1,n);return;&#125;\t\tl = mth[1][i];\t\tif(l &gt; 0 &amp;&amp; Hash(hsh[0],l + 1,i) == Hash(hsh[1],1,i - l))\t\t\t&#123; printf(&quot;YES\\n%d %d\\n%d %d\\n%d %d\\n&quot;,i - l + 1,i,1,i - l,i + 1,n);return;&#125;\t        if(s[i] != t[i]) break;\t&#125;\treverse(s + 1,s + n + 1);\treverse(t + 1,t + n + 1);\tKMP(s,t,n,mth[0]);\tKMP(t,s,n,mth[1]);\treverse(s + 1,s + n + 1);\treverse(t + 1,t + n + 1);\treverse(mth[0] + 1,mth[0] + n + 1);\treverse(mth[1] + 1,mth[1] + n + 1);\tfor(int i = 1;i &lt;= n;i++)\t&#123;\t\tint l = mth[0][i];\t\tif(l &gt; 0 &amp;&amp; Hash(hsh[0],i + l,n) == Hash(hsh[1],i,n - l))\t\t\t&#123; printf(&quot;YES\\n%d %d\\n%d %d\\n%d %d\\n&quot;,1,i - 1,n - l + 1,n,i,n - l);return;&#125;\t\tl = mth[1][i];\t\tif(l &gt; 0 &amp;&amp; Hash(hsh[0],i,n - l) == Hash(hsh[1],i + l,n))\t\t\t&#123; printf(&quot;YES\\n%d %d\\n%d %d\\n%d %d\\n&quot;,1,i - 1,i + l,n,i,i + l - 1);return;&#125;        if(s[i] != t[i]) break;\t&#125;\tts[0] = m + 1;\tfor(int i = 1;i &lt;= n;i++)\t\tts[2 * i - 1] = s[i],ts[2 * i] = t[n - i + 1];\tint l = 0,r = 0;\tfor(int i = 1;i &lt;= 2 * n;i++) mxp[i] = mxs[i] = 0;\tfor(int i = 1;i &lt;= 2 * n;i++)\t&#123;\t\tif(r &gt; i) len[i] = min(len[2 * l - i],r - i);        else len[i] = 0;\t\twhile(i + len[i] &lt;= 2 * n &amp;&amp; ts[i + len[i]] == ts[i - len[i] - 1])\t\t\t++len[i];\t\tif(i + len[i] &gt; r)\t\t\tl = i,r = i + len[i];\t\tif(i + len[i] &gt; 2 * n)\t\t&#123;\t\t\tmxs[i - len[i]] = 2 * len[i];\t\t\tmxp[i - len[i] + 1] = max(mxp[i - len[i] + 1],2 * len[i] - 2);\t\t&#125;\t\telse mxp[i - len[i]] = max(mxp[i - len[i]],2 * len[i]);\t&#125;\tfor(int i = 2;i &lt;= 2 * n;i++) mxp[i] = max(mxp[i],mxp[i - 1] - 2);\tfor(int i = 2 * n - 1;i &gt;= 1;i--) mxs[i] = max(mxs[i],mxs[i + 1]);\tfor(int i = 1;i &lt; n;i++)\t&#123;\t\tif(Hash(hsh[0],1,i) != Hash(hsh[1],n - i + 1,n))\t\t\tcontinue;\t\tint l = mxp[2 * i + 1] / 2;\t\tif(l &gt; 0 &amp;&amp; Hash(hsh[0],i + l + 1,n) == Hash(hsh[1],1,n - i - l))\t\t\t&#123; printf(&quot;YES\\n%d %d\\n%d %d\\n%d %d\\n&quot;,n - i + 1,n,n - i - l + 1,n - i,1,n - i - l);return;&#125;\t\tl = mxs[2 * i + 1] / 2;\t\tif(l &gt; 0 &amp;&amp; Hash(hsh[0],i + 1,n - l) == Hash(hsh[1],l + 1,n - i))\t\t\t&#123; printf(&quot;YES\\n%d %d\\n%d %d\\n%d %d\\n&quot;,n - i + 1,n,l + 1,n - i,1,l);return;&#125;\t&#125;\tprintf(&quot;NO\\n&quot;);&#125;int main()&#123;\tint T;\tcin &gt;&gt; T;\twhile(T--) work();\treturn 0;&#125;\r\n","tags":["string theory"]}]